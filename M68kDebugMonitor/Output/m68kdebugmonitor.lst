680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 28 Feb 2024      Time: 13:51:29          Source: C:\USERS\ADMIN\DESKTOP\ASSIGNMENT3\SPI_CONTROLLER\M68KDEBUGMONITOR\OUTPUT\M68KDEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0546 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  30A2      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  23D6      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\USERS\ADMIN\DESKTOP\ASSIGNMENT3\SPI_CONTROLLER\M68KV6.0-800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     478   ; unsigned int i, x, y, z, PortA_Count;
                     479   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     480   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     481   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     482   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     483   ; unsigned int PC, SSP, USP ;
                     484   ; unsigned short int SR;
                     485   ; // Breakpoint variables
                     486   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     487   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     488   ; unsigned int BreakPointSetOrCleared[8] ;
                     489   ; unsigned int InstructionSize ;
                     490   ; // watchpoint variables
                     491   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     492   ; unsigned int WatchPointSetOrCleared[8] ;
                     493   ; char WatchPointString[8][100] ;
                     494   ; char    TempString[100] ;
                     495   ; /************************************************************************************
                     496   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     497   ; ************************************************************************************/
                     498   ; void Wait1ms(void)
                     499   ; {
                     500   _Wait1ms:
00000932  2F02       501          move.l    D2,-(A7)
                     502   ; long int  i ;
                     503   ; for(i = 0; i < 1000; i ++)
00000934  4282       504          clr.l     D2
                     505   Wait1ms_1:
00000936  0C82 0000  506          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       507          bge.s     Wait1ms_3
0000093E  5282       508          addq.l    #1,D2
00000940  60F4       509          bra       Wait1ms_1
                     510   Wait1ms_3:
00000942  241F       511          move.l    (A7)+,D2
00000944  4E75       512          rts
                     513   ; ;
                     514   ; }
                     515   ; /************************************************************************************
                     516   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     517   ; **************************************************************************************/
                     518   ; void Wait3ms(void)
                     519   ; {
                     520   _Wait3ms:
00000946  2F02       521          move.l    D2,-(A7)
                     522   ; int i ;
                     523   ; for(i = 0; i < 3; i++)
00000948  4282       524          clr.l     D2
                     525   Wait3ms_1:
0000094A  0C82 0000  526          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       527          bge.s     Wait3ms_3
                     528   ; Wait1ms() ;
00000952  4EB8 0932  529          jsr       _Wait1ms
00000956  5282       530          addq.l    #1,D2
00000958  60F0       531          bra       Wait3ms_1
                     532   Wait3ms_3:
0000095A  241F       533          move.l    (A7)+,D2
0000095C  4E75       534          rts
                     535   ; }
                     536   ; /*********************************************************************************************
                     537   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     538   ; *********************************************************************************************/
                     539   ; void Init_LCD(void)
                     540   ; {
                     541   _Init_LCD:
                     542   ; LCDcommand = (char)(0x0c) ;
0000095E  13FC 000C  543          move.b    #12,4194336
00000962  0040 0020 
                     544   ; Wait3ms() ;
00000966  4EB8 0946  545          jsr       _Wait3ms
                     546   ; LCDcommand = (char)(0x38) ;
0000096A  13FC 0038  547          move.b    #56,4194336
0000096E  0040 0020 
                     548   ; Wait3ms() ;
00000972  4EB8 0946  549          jsr       _Wait3ms
00000976  4E75       550          rts
                     551   ; }
                     552   ; /******************************************************************************
                     553   ; *subroutine to output a single character held in d1 to the LCD display
                     554   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     555   ; *current cursor position
                     556   ; *******************************************************************************/
                     557   ; void Outchar(int c)
                     558   ; {
                     559   _Outchar:
00000978  4E56 0000  560          link      A6,#0
                     561   ; LCDdata = (char)(c);
0000097C  202E 0008  562          move.l    8(A6),D0
00000980  13C0 0040  563          move.b    D0,4194338
00000984  0022      
                     564   ; Wait1ms() ;
00000986  4EB8 0932  565          jsr       _Wait1ms
0000098A  4E5E       566          unlk      A6
0000098C  4E75       567          rts
                     568   ; }
                     569   ; /**********************************************************************************
                     570   ; *subroutine to output a message at the current cursor position of the LCD display
                     571   ; ************************************************************************************/
                     572   ; void OutMess(char *theMessage)
                     573   ; {
                     574   _OutMess:
0000098E  4E56 FFFC  575          link      A6,#-4
                     576   ; char c ;
                     577   ; while((c = *theMessage++) != (char)(0))
                     578   OutMess_1:
00000992  206E 0008  579          move.l    8(A6),A0
00000996  52AE 0008  580          addq.l    #1,8(A6)
0000099A  1D50 FFFF  581          move.b    (A0),-1(A6)
0000099E  1010       582          move.b    (A0),D0
000009A0  6712       583          beq.s     OutMess_3
                     584   ; Outchar(c) ;
000009A2  122E FFFF  585          move.b    -1(A6),D1
000009A6  4881       586          ext.w     D1
000009A8  48C1       587          ext.l     D1
000009AA  2F01       588          move.l    D1,-(A7)
000009AC  4EB8 0978  589          jsr       _Outchar
000009B0  584F       590          addq.w    #4,A7
000009B2  60DE       591          bra       OutMess_1
                     592   OutMess_3:
000009B4  4E5E       593          unlk      A6
000009B6  4E75       594          rts
                     595   ; }
                     596   ; /******************************************************************************
                     597   ; *subroutine to clear the line by issuing 24 space characters
                     598   ; *******************************************************************************/
                     599   ; void Clearln(void)
                     600   ; {
                     601   _Clearln:
000009B8  2F02       602          move.l    D2,-(A7)
                     603   ; unsigned char i ;
                     604   ; for(i = 0; i < 24; i ++)
000009BA  4202       605          clr.b     D2
                     606   Clearln_1:
000009BC  0C02 0018  607          cmp.b     #24,D2
000009C0  640E       608          bhs.s     Clearln_3
                     609   ; Outchar(' ') ;  /* write a space char to the LCD display */
000009C2  4878 0020  610          pea       32
000009C6  4EB8 0978  611          jsr       _Outchar
000009CA  584F       612          addq.w    #4,A7
000009CC  5202       613          addq.b    #1,D2
000009CE  60EC       614          bra       Clearln_1
                     615   Clearln_3:
000009D0  241F       616          move.l    (A7)+,D2
000009D2  4E75       617          rts
                     618   ; }
                     619   ; /******************************************************************************
                     620   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     621   ; *******************************************************************************/
                     622   ; void Oline0(char *theMessage)
                     623   ; {
                     624   _Oline0:
000009D4  4E56 0000  625          link      A6,#0
                     626   ; LCDcommand = (char)(0x80) ;
000009D8  13FC 0080  627          move.b    #128,4194336
000009DC  0040 0020 
                     628   ; Wait3ms();
000009E0  4EB8 0946  629          jsr       _Wait3ms
                     630   ; Clearln() ;
000009E4  4EB8 09B8  631          jsr       _Clearln
                     632   ; LCDcommand = (char)(0x80) ;
000009E8  13FC 0080  633          move.b    #128,4194336
000009EC  0040 0020 
                     634   ; Wait3ms() ;
000009F0  4EB8 0946  635          jsr       _Wait3ms
                     636   ; OutMess(theMessage) ;
000009F4  2F2E 0008  637          move.l    8(A6),-(A7)
000009F8  4EB8 098E  638          jsr       _OutMess
000009FC  584F       639          addq.w    #4,A7
000009FE  4E5E       640          unlk      A6
00000A00  4E75       641          rts
                     642   ; }
                     643   ; /******************************************************************************
                     644   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     645   ; *******************************************************************************/
                     646   ; void Oline1(char *theMessage)
                     647   ; {
                     648   _Oline1:
00000A02  4E56 0000  649          link      A6,#0
                     650   ; LCDcommand = (char)(0xC0) ;
00000A06  13FC 00C0  651          move.b    #192,4194336
00000A0A  0040 0020 
                     652   ; Wait3ms();
00000A0E  4EB8 0946  653          jsr       _Wait3ms
                     654   ; Clearln() ;
00000A12  4EB8 09B8  655          jsr       _Clearln
                     656   ; LCDcommand = (char)(0xC0) ;
00000A16  13FC 00C0  657          move.b    #192,4194336
00000A1A  0040 0020 
                     658   ; Wait3ms() ;
00000A1E  4EB8 0946  659          jsr       _Wait3ms
                     660   ; OutMess(theMessage) ;
00000A22  2F2E 0008  661          move.l    8(A6),-(A7)
00000A26  4EB8 098E  662          jsr       _OutMess
00000A2A  584F       663          addq.w    #4,A7
00000A2C  4E5E       664          unlk      A6
00000A2E  4E75       665          rts
                     666   ; }
                     667   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     668   ; {
                     669   _InstallExceptionHandler:
00000A30  4E56 FFFC  670          link      A6,#-4
                     671   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  672          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     673   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A3C  206E FFFC  674          move.l    -4(A6),A0
00000A40  202E 000C  675          move.l    12(A6),D0
00000A44  E588       676          lsl.l     #2,D0
00000A46  21AE 0008  677          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       678          unlk      A6
00000A4E  4E75       679          rts
                     680   ; }
                     681   ; void TestLEDS(void)
                     682   ; {
                     683   _TestLEDS:
00000A50  48E7 3000  684          movem.l   D2/D3,-(A7)
                     685   ; int delay ;
                     686   ; unsigned char count = 0 ;
00000A54  4202       687          clr.b     D2
                     688   ; while(1)    {
                     689   TestLEDS_1:
                     690   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000A56  1002       691          move.b    D2,D0
00000A58  E908       692          lsl.b     #4,D0
00000A5A  1202       693          move.b    D2,D1
00000A5C  C23C 000F  694          and.b     #15,D1
00000A60  D001       695          add.b     D1,D0
00000A62  13C0 0040  696          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  697          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  698          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  699          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  700          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  701          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  702          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  703          move.b    D0,4194304
00000A90  0000      
                     704   ; for(delay = 0; delay < 200000; delay ++)
00000A92  4283       705          clr.l     D3
                     706   TestLEDS_4:
00000A94  0C83 0003  707          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       708          bge.s     TestLEDS_6
00000A9C  5283       709          addq.l    #1,D3
00000A9E  60F4       710          bra       TestLEDS_4
                     711   TestLEDS_6:
                     712   ; ;
                     713   ; count ++;
00000AA0  5202       714          addq.b    #1,D2
00000AA2  60B2       715          bra       TestLEDS_1
                     716   ; }
                     717   ; }
                     718   ; void SwitchTest(void)
                     719   ; {
                     720   _SwitchTest:
00000AA4  48E7 3020  721          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  722          lea       _printf.L,A2
00000AAC  3532      
                     723   ; int i, switches = 0 ;
00000AAE  4283       724          clr.l     D3
                     725   ; printf("\r\n") ;
00000AB0  4879 0000  726          pea       @m68kde~2_1.L
00000AB4  3E44      
00000AB6  4E92       727          jsr       (A2)
00000AB8  584F       728          addq.w    #4,A7
                     729   ; while(1)    {
                     730   SwitchTest_1:
                     731   ; switches = (PortB << 8) | (PortA) ;
00000ABA  1039 0040  732          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  733          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       734          lsl.l     #8,D0
00000AC8  1239 0040  735          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  736          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       737          or.l      D1,D0
00000AD6  2600       738          move.l    D0,D3
                     739   ; printf("\rSwitches SW[7-0] = ") ;
00000AD8  4879 0000  740          pea       @m68kde~2_2.L
00000ADC  3E48      
00000ADE  4E92       741          jsr       (A2)
00000AE0  584F       742          addq.w    #4,A7
                     743   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000AE2  243C 0000  744          move.l    #128,D2
00000AE6  0080      
                     745   SwitchTest_4:
00000AE8  0C82 0000  746          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       747          ble.s     SwitchTest_6
                     748   ; if((switches & i) == 0)
00000AF0  2003       749          move.l    D3,D0
00000AF2  C082       750          and.l     D2,D0
00000AF4  660C       751          bne.s     SwitchTest_7
                     752   ; printf("0") ;
00000AF6  4879 0000  753          pea       @m68kde~2_3.L
00000AFA  3E5E      
00000AFC  4E92       754          jsr       (A2)
00000AFE  584F       755          addq.w    #4,A7
00000B00  600A       756          bra.s     SwitchTest_8
                     757   SwitchTest_7:
                     758   ; else
                     759   ; printf("1") ;
00000B02  4879 0000  760          pea       @m68kde~2_4.L
00000B06  3E60      
00000B08  4E92       761          jsr       (A2)
00000B0A  584F       762          addq.w    #4,A7
                     763   SwitchTest_8:
00000B0C  E282       764          asr.l     #1,D2
00000B0E  60D8       765          bra       SwitchTest_4
                     766   SwitchTest_6:
00000B10  60A8       767          bra       SwitchTest_1
                     768   ; }
                     769   ; }
                     770   ; }
                     771   ; /*********************************************************************************************
                     772   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     773   ; *********************************************************************************************/
                     774   ; void Init_RS232(void)
                     775   ; {
                     776   _Init_RS232:
                     777   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  778          move.b    #21,4194368
00000B16  0040 0040 
                     779   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  780          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       781          rts
                     782   ; }
                     783   ; int kbhit(void)
                     784   ; {
                     785   _kbhit:
                     786   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  787          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  788          and.b     #1,D0
00000B2E  0C00 0001  789          cmp.b     #1,D0
00000B32  6604       790          bne.s     kbhit_1
                     791   ; return 1 ;
00000B34  7001       792          moveq     #1,D0
00000B36  6002       793          bra.s     kbhit_3
                     794   kbhit_1:
                     795   ; else
                     796   ; return 0 ;
00000B38  4280       797          clr.l     D0
                     798   kbhit_3:
00000B3A  4E75       799          rts
                     800   ; }
                     801   ; /*********************************************************************************************************
                     802   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     803   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     804   ; **  to allow the board to communicate with HyperTerminal Program
                     805   ; **
                     806   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     807   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     808   ; **  call _putch() also
                     809   ; *********************************************************************************************************/
                     810   ; int _putch( int c)
                     811   ; {
                     812   __putch:
00000B3C  4E56 0000  813          link      A6,#0
                     814   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     815   _putch_1:
00000B40  1039 0040  816          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  817          and.b     #2,D0
00000B4A  0C00 0002  818          cmp.b     #2,D0
00000B4E  6702       819          beq.s     _putch_3
00000B50  60EE       820          bra       _putch_1
                     821   _putch_3:
                     822   ; ;
                     823   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  824          move.l    8(A6),D0
00000B56  C03C 007F  825          and.b     #127,D0
00000B5A  13C0 0040  826          move.b    D0,4194370
00000B5E  0042      
                     827   ; return c ;                                              // putchar() expects the character to be returned
00000B60  202E 0008  828          move.l    8(A6),D0
00000B64  4E5E       829          unlk      A6
00000B66  4E75       830          rts
                     831   ; }
                     832   ; /*********************************************************************************************************
                     833   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     834   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     835   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     836   ; **
                     837   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     838   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     839   ; **  call _getch() also
                     840   ; *********************************************************************************************************/
                     841   ; int _getch( void )
                     842   ; {
                     843   __getch:
00000B68  2F02       844          move.l    D2,-(A7)
                     845   ; int c ;
                     846   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     847   _getch_1:
00000B6A  1039 0040  848          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  849          and.b     #1,D0
00000B74  0C00 0001  850          cmp.b     #1,D0
00000B78  6702       851          beq.s     _getch_3
00000B7A  60EE       852          bra       _getch_1
                     853   _getch_3:
                     854   ; ;
                     855   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  856          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  857          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  858          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       859          move.l    D0,D2
                     860   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     861   ; if(Echo)
00000B90  4AB9 0B00  862          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       863          beq.s     _getch_4
                     864   ; _putch(c);
00000B98  2F02       865          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  866          jsr       __putch
00000B9E  584F       867          addq.w    #4,A7
                     868   _getch_4:
                     869   ; return c ;
00000BA0  2002       870          move.l    D2,D0
00000BA2  241F       871          move.l    (A7)+,D2
00000BA4  4E75       872          rts
                     873   ; }
                     874   ; // flush the input stream for any unread characters
                     875   ; void FlushKeyboard(void)
                     876   ; {
                     877   _FlushKeyboard:
00000BA6  4E56 FFFC  878          link      A6,#-4
                     879   ; char c ;
                     880   ; while(1)    {
                     881   FlushKeyboard_1:
                     882   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  883          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  884          and.b     #1,D0
00000BB4  0C00 0001  885          cmp.b     #1,D0
00000BB8  6610       886          bne.s     FlushKeyboard_4
                     887   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000BBA  1039 0040  888          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  889          and.b     #127,D0
00000BC4  1D40 FFFF  890          move.b    D0,-1(A6)
00000BC8  6002       891          bra.s     FlushKeyboard_5
                     892   FlushKeyboard_4:
                     893   ; else
                     894   ; return ;
00000BCA  6002       895          bra.s     FlushKeyboard_6
                     896   FlushKeyboard_5:
00000BCC  60DC       897          bra       FlushKeyboard_1
                     898   FlushKeyboard_6:
00000BCE  4E5E       899          unlk      A6
00000BD0  4E75       900          rts
                     901   ; }
                     902   ; }
                     903   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     904   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     905   ; char xtod(int c)
                     906   ; {
                     907   _xtod:
00000BD2  4E56 0000  908          link      A6,#0
00000BD6  2F02       909          move.l    D2,-(A7)
00000BD8  242E 0008  910          move.l    8(A6),D2
                     911   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  912          cmp.b     #57,D2
00000BE0  6E08       913          bgt.s     xtod_1
                     914   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       915          move.b    D2,D0
00000BE4  0400 0030  916          sub.b     #48,D0
00000BE8  6014       917          bra.s     xtod_3
                     918   xtod_1:
                     919   ; else if((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  920          cmp.b     #70,D2
00000BEE  6F08       921          ble.s     xtod_4
                     922   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       923          move.b    D2,D0
00000BF2  0400 0057  924          sub.b     #87,D0
00000BF6  6006       925          bra.s     xtod_3
                     926   xtod_4:
                     927   ; else
                     928   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       929          move.b    D2,D0
00000BFA  0400 0037  930          sub.b     #55,D0
                     931   xtod_3:
00000BFE  241F       932          move.l    (A7)+,D2
00000C00  4E5E       933          unlk      A6
00000C02  4E75       934          rts
                     935   ; }
                     936   ; int Get2HexDigits(char *CheckSumPtr)
                     937   ; {
                     938   _Get2HexDigits:
00000C04  4E56 0000  939          link      A6,#0
00000C08  2F02       940          move.l    D2,-(A7)
                     941   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       942          move.l    D0,-(A7)
00000C0C  4EB8 0B68  943          jsr       __getch
00000C10  2200       944          move.l    D0,D1
00000C12  201F       945          move.l    (A7)+,D0
00000C14  2F01       946          move.l    D1,-(A7)
00000C16  4EB8 0BD2  947          jsr       _xtod
00000C1A  584F       948          addq.w    #4,A7
00000C1C  C0BC 0000  949          and.l     #255,D0
00000C20  00FF      
00000C22  E980       950          asl.l     #4,D0
00000C24  2F00       951          move.l    D0,-(A7)
00000C26  2F01       952          move.l    D1,-(A7)
00000C28  4EB8 0B68  953          jsr       __getch
00000C2C  221F       954          move.l    (A7)+,D1
00000C2E  2F00       955          move.l    D0,-(A7)
00000C30  4EB8 0BD2  956          jsr       _xtod
00000C34  584F       957          addq.w    #4,A7
00000C36  2200       958          move.l    D0,D1
00000C38  201F       959          move.l    (A7)+,D0
00000C3A  C2BC 0000  960          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       961          or.l      D1,D0
00000C42  2400       962          move.l    D0,D2
                     963   ; if(CheckSumPtr)
00000C44  4AAE 0008  964          tst.l     8(A6)
00000C48  6706       965          beq.s     Get2HexDigits_1
                     966   ; *CheckSumPtr += i ;
00000C4A  206E 0008  967          move.l    8(A6),A0
00000C4E  D510       968          add.b     D2,(A0)
                     969   Get2HexDigits_1:
                     970   ; return i ;
00000C50  2002       971          move.l    D2,D0
00000C52  241F       972          move.l    (A7)+,D2
00000C54  4E5E       973          unlk      A6
00000C56  4E75       974          rts
                     975   ; }
                     976   ; int Get4HexDigits(char *CheckSumPtr)
                     977   ; {
                     978   _Get4HexDigits:
00000C58  4E56 0000  979          link      A6,#0
                     980   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  981          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  982          jsr       _Get2HexDigits
00000C64  584F       983          addq.w    #4,A7
00000C66  E180       984          asl.l     #8,D0
00000C68  2F00       985          move.l    D0,-(A7)
00000C6A  2F2E 0008  986          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04  987          jsr       _Get2HexDigits
00000C72  584F       988          addq.w    #4,A7
00000C74  2200       989          move.l    D0,D1
00000C76  201F       990          move.l    (A7)+,D0
00000C78  8081       991          or.l      D1,D0
00000C7A  4E5E       992          unlk      A6
00000C7C  4E75       993          rts
                     994   ; }
                     995   ; int Get6HexDigits(char *CheckSumPtr)
                     996   ; {
                     997   _Get6HexDigits:
00000C7E  4E56 0000  998          link      A6,#0
                     999   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1000          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1001          jsr       _Get4HexDigits
00000C8A  584F      1002          addq.w    #4,A7
00000C8C  E180      1003          asl.l     #8,D0
00000C8E  2F00      1004          move.l    D0,-(A7)
00000C90  2F2E 0008 1005          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1006          jsr       _Get2HexDigits
00000C98  584F      1007          addq.w    #4,A7
00000C9A  2200      1008          move.l    D0,D1
00000C9C  201F      1009          move.l    (A7)+,D0
00000C9E  8081      1010          or.l      D1,D0
00000CA0  4E5E      1011          unlk      A6
00000CA2  4E75      1012          rts
                    1013   ; }
                    1014   ; int Get8HexDigits(char *CheckSumPtr)
                    1015   ; {
                    1016   _Get8HexDigits:
00000CA4  4E56 0000 1017          link      A6,#0
                    1018   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1019          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1020          jsr       _Get4HexDigits
00000CB0  584F      1021          addq.w    #4,A7
00000CB2  E180      1022          asl.l     #8,D0
00000CB4  E180      1023          asl.l     #8,D0
00000CB6  2F00      1024          move.l    D0,-(A7)
00000CB8  2F2E 0008 1025          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1026          jsr       _Get4HexDigits
00000CC0  584F      1027          addq.w    #4,A7
00000CC2  2200      1028          move.l    D0,D1
00000CC4  201F      1029          move.l    (A7)+,D0
00000CC6  8081      1030          or.l      D1,D0
00000CC8  4E5E      1031          unlk      A6
00000CCA  4E75      1032          rts
                    1033   ; }
                    1034   ; void DumpMemory(void)   // simple dump memory fn
                    1035   ; {
                    1036   _DumpMemory:
00000CCC  48E7 3C30 1037          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000CD0  45F9 0000 1038          lea       _printf.L,A2
00000CD4  3532      
00000CD6  47F9 0000 1039          lea       _putch.L,A3
00000CDA  344E      
                    1040   ; int i, j ;
                    1041   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1042   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000CDC  4879 0000 1043          pea       @m68kde~2_5.L
00000CE0  3E62      
00000CE2  4E92      1044          jsr       (A2)
00000CE4  584F      1045          addq.w    #4,A7
                    1046   ; printf("\r\nEnter Start Address: ") ;
00000CE6  4879 0000 1047          pea       @m68kde~2_6.L
00000CEA  3E9C      
00000CEC  4E92      1048          jsr       (A2)
00000CEE  584F      1049          addq.w    #4,A7
                    1050   ; RamPtr = Get8HexDigits(0) ;
00000CF0  42A7      1051          clr.l     -(A7)
00000CF2  4EB8 0CA4 1052          jsr       _Get8HexDigits
00000CF6  584F      1053          addq.w    #4,A7
00000CF8  2600      1054          move.l    D0,D3
                    1055   ; while(1)    {
                    1056   DumpMemory_1:
                    1057   ; for(i = 0; i < 16; i ++)    {
00000CFA  4285      1058          clr.l     D5
                    1059   DumpMemory_4:
00000CFC  0C85 0000 1060          cmp.l     #16,D5
00000D00  0010      
00000D02  6C00 0096 1061          bge       DumpMemory_6
                    1062   ; printf("\r\n%08x ", RamPtr) ;
00000D06  2F03      1063          move.l    D3,-(A7)
00000D08  4879 0000 1064          pea       @m68kde~2_7.L
00000D0C  3EB4      
00000D0E  4E92      1065          jsr       (A2)
00000D10  504F      1066          addq.w    #8,A7
                    1067   ; for(j=0; j < 16; j ++)  {
00000D12  4282      1068          clr.l     D2
                    1069   DumpMemory_7:
00000D14  0C82 0000 1070          cmp.l     #16,D2
00000D18  0010      
00000D1A  6C24      1071          bge.s     DumpMemory_9
                    1072   ; printf("%02X",RamPtr[j]) ;
00000D1C  2043      1073          move.l    D3,A0
00000D1E  1230 2800 1074          move.b    0(A0,D2.L),D1
00000D22  C2BC 0000 1075          and.l     #255,D1
00000D26  00FF      
00000D28  2F01      1076          move.l    D1,-(A7)
00000D2A  4879 0000 1077          pea       @m68kde~2_8.L
00000D2E  3EBC      
00000D30  4E92      1078          jsr       (A2)
00000D32  504F      1079          addq.w    #8,A7
                    1080   ; putchar(' ') ;
00000D34  4878 0020 1081          pea       32
00000D38  4E93      1082          jsr       (A3)
00000D3A  584F      1083          addq.w    #4,A7
00000D3C  5282      1084          addq.l    #1,D2
00000D3E  60D4      1085          bra       DumpMemory_7
                    1086   DumpMemory_9:
                    1087   ; }
                    1088   ; // now display the data as ASCII at the end
                    1089   ; printf("  ") ;
00000D40  4879 0000 1090          pea       @m68kde~2_9.L
00000D44  3EC2      
00000D46  4E92      1091          jsr       (A2)
00000D48  584F      1092          addq.w    #4,A7
                    1093   ; for(j = 0; j < 16; j++) {
00000D4A  4282      1094          clr.l     D2
                    1095   DumpMemory_10:
00000D4C  0C82 0000 1096          cmp.l     #16,D2
00000D50  0010      
00000D52  6C00 003A 1097          bge       DumpMemory_12
                    1098   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000D56  2043      1099          move.l    D3,A0
00000D58  1030 2800 1100          move.b    0(A0,D2.L),D0
00000D5C  C03C 007F 1101          and.b     #127,D0
00000D60  1800      1102          move.b    D0,D4
                    1103   ; if((c > (char)(0x7f)) || (c < ' '))
00000D62  0C04 007F 1104          cmp.b     #127,D4
00000D66  6206      1105          bhi.s     DumpMemory_15
00000D68  0C04 0020 1106          cmp.b     #32,D4
00000D6C  640A      1107          bhs.s     DumpMemory_13
                    1108   DumpMemory_15:
                    1109   ; putchar('.') ;
00000D6E  4878 002E 1110          pea       46
00000D72  4E93      1111          jsr       (A3)
00000D74  584F      1112          addq.w    #4,A7
00000D76  6012      1113          bra.s     DumpMemory_14
                    1114   DumpMemory_13:
                    1115   ; else
                    1116   ; putchar(RamPtr[j]) ;
00000D78  2043      1117          move.l    D3,A0
00000D7A  1230 2800 1118          move.b    0(A0,D2.L),D1
00000D7E  C2BC 0000 1119          and.l     #255,D1
00000D82  00FF      
00000D84  2F01      1120          move.l    D1,-(A7)
00000D86  4E93      1121          jsr       (A3)
00000D88  584F      1122          addq.w    #4,A7
                    1123   DumpMemory_14:
00000D8A  5282      1124          addq.l    #1,D2
00000D8C  60BE      1125          bra       DumpMemory_10
                    1126   DumpMemory_12:
                    1127   ; }
                    1128   ; RamPtr = RamPtr + 16 ;
00000D8E  0683 0000 1129          add.l     #16,D3
00000D92  0010      
00000D94  5285      1130          addq.l    #1,D5
00000D96  6000 FF64 1131          bra       DumpMemory_4
                    1132   DumpMemory_6:
                    1133   ; }
                    1134   ; printf("\r\n") ;
00000D9A  4879 0000 1135          pea       @m68kde~2_1.L
00000D9E  3E44      
00000DA0  4E92      1136          jsr       (A2)
00000DA2  584F      1137          addq.w    #4,A7
                    1138   ; c = _getch() ;
00000DA4  4EB8 0B68 1139          jsr       __getch
00000DA8  1800      1140          move.b    D0,D4
                    1141   ; if(c == 0x1b)          // break on ESC
00000DAA  0C04 001B 1142          cmp.b     #27,D4
00000DAE  6602      1143          bne.s     DumpMemory_16
                    1144   ; break ;
00000DB0  6004      1145          bra.s     DumpMemory_3
                    1146   DumpMemory_16:
00000DB2  6000 FF46 1147          bra       DumpMemory_1
                    1148   DumpMemory_3:
00000DB6  4CDF 0C3C 1149          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DBA  4E75      1150          rts
                    1151   ; }
                    1152   ; }
                    1153   ; void FillMemory()
                    1154   ; {
                    1155   _FillMemory:
00000DBC  48E7 3820 1156          movem.l   D2/D3/D4/A2,-(A7)
00000DC0  45F9 0000 1157          lea       _printf.L,A2
00000DC4  3532      
                    1158   ; char *StartRamPtr, *EndRamPtr ;
                    1159   ; unsigned char FillData ;
                    1160   ; printf("\r\nFill Memory Block") ;
00000DC6  4879 0000 1161          pea       @m68kde~2_10.L
00000DCA  3EC6      
00000DCC  4E92      1162          jsr       (A2)
00000DCE  584F      1163          addq.w    #4,A7
                    1164   ; printf("\r\nEnter Start Address: ") ;
00000DD0  4879 0000 1165          pea       @m68kde~2_6.L
00000DD4  3E9C      
00000DD6  4E92      1166          jsr       (A2)
00000DD8  584F      1167          addq.w    #4,A7
                    1168   ; StartRamPtr = Get8HexDigits(0) ;
00000DDA  42A7      1169          clr.l     -(A7)
00000DDC  4EB8 0CA4 1170          jsr       _Get8HexDigits
00000DE0  584F      1171          addq.w    #4,A7
00000DE2  2400      1172          move.l    D0,D2
                    1173   ; printf("\r\nEnter End Address: ") ;
00000DE4  4879 0000 1174          pea       @m68kde~2_11.L
00000DE8  3EDA      
00000DEA  4E92      1175          jsr       (A2)
00000DEC  584F      1176          addq.w    #4,A7
                    1177   ; EndRamPtr = Get8HexDigits(0) ;
00000DEE  42A7      1178          clr.l     -(A7)
00000DF0  4EB8 0CA4 1179          jsr       _Get8HexDigits
00000DF4  584F      1180          addq.w    #4,A7
00000DF6  2800      1181          move.l    D0,D4
                    1182   ; printf("\r\nEnter Fill Data: ") ;
00000DF8  4879 0000 1183          pea       @m68kde~2_12.L
00000DFC  3EF0      
00000DFE  4E92      1184          jsr       (A2)
00000E00  584F      1185          addq.w    #4,A7
                    1186   ; FillData = Get2HexDigits(0) ;
00000E02  42A7      1187          clr.l     -(A7)
00000E04  4EB8 0C04 1188          jsr       _Get2HexDigits
00000E08  584F      1189          addq.w    #4,A7
00000E0A  1600      1190          move.b    D0,D3
                    1191   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00000E0C  C6BC 0000 1192          and.l     #255,D3
00000E10  00FF      
00000E12  2F03      1193          move.l    D3,-(A7)
00000E14  2F04      1194          move.l    D4,-(A7)
00000E16  2F02      1195          move.l    D2,-(A7)
00000E18  4879 0000 1196          pea       @m68kde~2_13.L
00000E1C  3F04      
00000E1E  4E92      1197          jsr       (A2)
00000E20  DEFC 0010 1198          add.w     #16,A7
                    1199   ; while(StartRamPtr < EndRamPtr)
                    1200   FillMemory_1:
00000E24  B484      1201          cmp.l     D4,D2
00000E26  6408      1202          bhs.s     FillMemory_3
                    1203   ; *StartRamPtr++ = FillData ;
00000E28  2042      1204          move.l    D2,A0
00000E2A  5282      1205          addq.l    #1,D2
00000E2C  1083      1206          move.b    D3,(A0)
00000E2E  60F4      1207          bra       FillMemory_1
                    1208   FillMemory_3:
00000E30  4CDF 041C 1209          movem.l   (A7)+,D2/D3/D4/A2
00000E34  4E75      1210          rts
                    1211   ; }
                    1212   ; void Load_SRecordFile()
                    1213   ; {
                    1214   _Load_SRecordFile:
00000E36  4E56 FFDC 1215          link      A6,#-36
00000E3A  48E7 3F3C 1216          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E3E  45EE FFFA 1217          lea       -6(A6),A2
00000E42  47F8 0C04 1218          lea       _Get2HexDigits.L,A3
00000E46  49F9 0000 1219          lea       _printf.L,A4
00000E4A  3532      
                    1220   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00000E4C  42AE FFEE 1221          clr.l     -18(A6)
00000E50  3A7C 0000 1222          move.w    #0,A5
                    1223   ; int result, ByteCount ;
                    1224   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1225   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1226   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00000E54  7E00      1227          moveq     #0,D7
                    1228   ; AddressFail = 0 ;
00000E56  42AE FFEA 1229          clr.l     -22(A6)
                    1230   ; Echo = 0 ;                              // don't echo S records during download
00000E5A  42B9 0B00 1231          clr.l     _Echo.L
00000E5E  00E0      
                    1232   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00000E60  4879 0000 1233          pea       @m68kde~2_14.L
00000E64  3F34      
00000E66  4E94      1234          jsr       (A4)
00000E68  584F      1235          addq.w    #4,A7
                    1236   ; while(1)    {
                    1237   Load_SRecordFile_1:
                    1238   ; CheckSum = 0 ;
00000E6A  4212      1239          clr.b     (A2)
                    1240   ; do {
                    1241   Load_SRecordFile_4:
                    1242   ; c = toupper(_getch()) ;
00000E6C  2F00      1243          move.l    D0,-(A7)
00000E6E  4EB8 0B68 1244          jsr       __getch
00000E72  2200      1245          move.l    D0,D1
00000E74  201F      1246          move.l    (A7)+,D0
00000E76  2F01      1247          move.l    D1,-(A7)
00000E78  4EB9 0000 1248          jsr       _toupper
00000E7C  3516      
00000E7E  584F      1249          addq.w    #4,A7
00000E80  1C00      1250          move.b    D0,D6
                    1251   ; if(c == 0x1b )      // if break
00000E82  0C06 001B 1252          cmp.b     #27,D6
00000E86  6604      1253          bne.s     Load_SRecordFile_6
                    1254   ; return;
00000E88  6000 0132 1255          bra       Load_SRecordFile_8
                    1256   Load_SRecordFile_6:
00000E8C  0C06 0053 1257          cmp.b     #83,D6
00000E90  66DA      1258          bne       Load_SRecordFile_4
                    1259   ; }while(c != (char)('S'));   // wait for S start of header
                    1260   ; HeaderType = _getch() ;
00000E92  4EB8 0B68 1261          jsr       __getch
00000E96  1600      1262          move.b    D0,D3
                    1263   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000E98  0C03 0030 1264          cmp.b     #48,D3
00000E9C  6706      1265          beq.s     Load_SRecordFile_11
00000E9E  0C03 0035 1266          cmp.b     #53,D3
00000EA2  6604      1267          bne.s     Load_SRecordFile_9
                    1268   Load_SRecordFile_11:
                    1269   ; continue ;
00000EA4  6000 00D2 1270          bra       Load_SRecordFile_23
                    1271   Load_SRecordFile_9:
                    1272   ; if(HeaderType >= (char)('7'))
00000EA8  0C03 0037 1273          cmp.b     #55,D3
00000EAC  6D04      1274          blt.s     Load_SRecordFile_12
                    1275   ; break ;                 // end load on s7,s8,s9 records
00000EAE  6000 00CC 1276          bra       Load_SRecordFile_3
                    1277   Load_SRecordFile_12:
                    1278   ; // get the bytecount
                    1279   ; ByteCount = Get2HexDigits(&CheckSum) ;
00000EB2  2F0A      1280          move.l    A2,-(A7)
00000EB4  4E93      1281          jsr       (A3)
00000EB6  584F      1282          addq.w    #4,A7
00000EB8  2D40 FFF6 1283          move.l    D0,-10(A6)
                    1284   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1285   ; if(HeaderType == (char)('1')) {
00000EBC  0C03 0031 1286          cmp.b     #49,D3
00000EC0  660E      1287          bne.s     Load_SRecordFile_14
                    1288   ; AddressSize = 2 ;       // 2 byte address
00000EC2  7A02      1289          moveq     #2,D5
                    1290   ; Address = Get4HexDigits(&CheckSum);
00000EC4  2F0A      1291          move.l    A2,-(A7)
00000EC6  4EB8 0C58 1292          jsr       _Get4HexDigits
00000ECA  584F      1293          addq.w    #4,A7
00000ECC  2800      1294          move.l    D0,D4
00000ECE  6020      1295          bra.s     Load_SRecordFile_17
                    1296   Load_SRecordFile_14:
                    1297   ; }
                    1298   ; else if (HeaderType == (char)('2')) {
00000ED0  0C03 0032 1299          cmp.b     #50,D3
00000ED4  660E      1300          bne.s     Load_SRecordFile_16
                    1301   ; AddressSize = 3 ;       // 3 byte address
00000ED6  7A03      1302          moveq     #3,D5
                    1303   ; Address = Get6HexDigits(&CheckSum) ;
00000ED8  2F0A      1304          move.l    A2,-(A7)
00000EDA  4EB8 0C7E 1305          jsr       _Get6HexDigits
00000EDE  584F      1306          addq.w    #4,A7
00000EE0  2800      1307          move.l    D0,D4
00000EE2  600C      1308          bra.s     Load_SRecordFile_17
                    1309   Load_SRecordFile_16:
                    1310   ; }
                    1311   ; else    {
                    1312   ; AddressSize = 4 ;       // 4 byte address
00000EE4  7A04      1313          moveq     #4,D5
                    1314   ; Address = Get8HexDigits(&CheckSum) ;
00000EE6  2F0A      1315          move.l    A2,-(A7)
00000EE8  4EB8 0CA4 1316          jsr       _Get8HexDigits
00000EEC  584F      1317          addq.w    #4,A7
00000EEE  2800      1318          move.l    D0,D4
                    1319   Load_SRecordFile_17:
                    1320   ; }
                    1321   ; RamPtr = (char *)(Address) ;                            // point to download area
00000EF0  2D44 FFFC 1322          move.l    D4,-4(A6)
                    1323   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00000EF4  202E FFF6 1324          move.l    -10(A6),D0
00000EF8  9085      1325          sub.l     D5,D0
00000EFA  5380      1326          subq.l    #1,D0
00000EFC  2D40 FFE2 1327          move.l    D0,-30(A6)
                    1328   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F00  4282      1329          clr.l     D2
                    1330   Load_SRecordFile_18:
00000F02  B4AE FFE2 1331          cmp.l     -30(A6),D2
00000F06  6C1E      1332          bge.s     Load_SRecordFile_20
                    1333   ; DataByte = Get2HexDigits(&CheckSum) ;
00000F08  2F0A      1334          move.l    A2,-(A7)
00000F0A  4E93      1335          jsr       (A3)
00000F0C  584F      1336          addq.w    #4,A7
00000F0E  2D40 FFDE 1337          move.l    D0,-34(A6)
                    1338   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00000F12  202E FFDE 1339          move.l    -34(A6),D0
00000F16  206E FFFC 1340          move.l    -4(A6),A0
00000F1A  52AE FFFC 1341          addq.l    #1,-4(A6)
00000F1E  1080      1342          move.b    D0,(A0)
                    1343   ; ByteTotal++;
00000F20  524D      1344          addq.w    #1,A5
00000F22  5282      1345          addq.l    #1,D2
00000F24  60DC      1346          bra       Load_SRecordFile_18
                    1347   Load_SRecordFile_20:
                    1348   ; }
                    1349   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1350   ; ReadCheckSum = Get2HexDigits(0) ;
00000F26  42A7      1351          clr.l     -(A7)
00000F28  4E93      1352          jsr       (A3)
00000F2A  584F      1353          addq.w    #4,A7
00000F2C  1D40 FFFB 1354          move.b    D0,-5(A6)
                    1355   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00000F30  1012      1356          move.b    (A2),D0
00000F32  4600      1357          not.b     D0
00000F34  4880      1358          ext.w     D0
00000F36  C07C 00FF 1359          and.w     #255,D0
00000F3A  122E FFFB 1360          move.b    -5(A6),D1
00000F3E  4881      1361          ext.w     D1
00000F40  C27C 00FF 1362          and.w     #255,D1
00000F44  B041      1363          cmp.w     D1,D0
00000F46  6708      1364          beq.s     Load_SRecordFile_21
                    1365   ; LoadFailed = 1 ;
00000F48  7E01      1366          moveq     #1,D7
                    1367   ; FailedAddress = Address ;
00000F4A  2D44 FFE6 1368          move.l    D4,-26(A6)
                    1369   ; break;
00000F4E  602C      1370          bra.s     Load_SRecordFile_3
                    1371   Load_SRecordFile_21:
                    1372   ; }
                    1373   ; SRecordCount++ ;
00000F50  52AE FFEE 1374          addq.l    #1,-18(A6)
                    1375   ; // display feedback on progress
                    1376   ; if(SRecordCount % 25 == 0)
00000F54  2F2E FFEE 1377          move.l    -18(A6),-(A7)
00000F58  4878 0019 1378          pea       25
00000F5C  4EB9 0000 1379          jsr       LDIV
00000F60  3382      
00000F62  202F 0004 1380          move.l    4(A7),D0
00000F66  504F      1381          addq.w    #8,A7
00000F68  4A80      1382          tst.l     D0
00000F6A  660C      1383          bne.s     Load_SRecordFile_23
                    1384   ; putchar('.') ;
00000F6C  4878 002E 1385          pea       46
00000F70  4EB9 0000 1386          jsr       _putch
00000F74  344E      
00000F76  584F      1387          addq.w    #4,A7
                    1388   Load_SRecordFile_23:
00000F78  6000 FEF0 1389          bra       Load_SRecordFile_1
                    1390   Load_SRecordFile_3:
                    1391   ; }
                    1392   ; if(LoadFailed == 1) {
00000F7C  0C87 0000 1393          cmp.l     #1,D7
00000F80  0001      
00000F82  6610      1394          bne.s     Load_SRecordFile_25
                    1395   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00000F84  2F2E FFE6 1396          move.l    -26(A6),-(A7)
00000F88  4879 0000 1397          pea       @m68kde~2_15.L
00000F8C  3F64      
00000F8E  4E94      1398          jsr       (A4)
00000F90  504F      1399          addq.w    #8,A7
00000F92  600C      1400          bra.s     Load_SRecordFile_26
                    1401   Load_SRecordFile_25:
                    1402   ; }
                    1403   ; else
                    1404   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
00000F94  2F0D      1405          move.l    A5,-(A7)
00000F96  4879 0000 1406          pea       @m68kde~2_16.L
00000F9A  3F8A      
00000F9C  4E94      1407          jsr       (A4)
00000F9E  504F      1408          addq.w    #8,A7
                    1409   Load_SRecordFile_26:
                    1410   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1411   ; for(i = 0; i < 400000; i ++)
00000FA0  4282      1412          clr.l     D2
                    1413   Load_SRecordFile_27:
00000FA2  0C82 0006 1414          cmp.l     #400000,D2
00000FA6  1A80      
00000FA8  6C04      1415          bge.s     Load_SRecordFile_29
00000FAA  5282      1416          addq.l    #1,D2
00000FAC  60F4      1417          bra       Load_SRecordFile_27
                    1418   Load_SRecordFile_29:
                    1419   ; ;
                    1420   ; FlushKeyboard() ;
00000FAE  4EB8 0BA6 1421          jsr       _FlushKeyboard
                    1422   ; Echo = 1;
00000FB2  23FC 0000 1423          move.l    #1,_Echo.L
00000FB6  0001 0B00 
00000FBA  00E0      
                    1424   Load_SRecordFile_8:
00000FBC  4CDF 3CFC 1425          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FC0  4E5E      1426          unlk      A6
00000FC2  4E75      1427          rts
                    1428   ; }
                    1429   ; void MemoryChange(void)
                    1430   ; {
                    1431   _MemoryChange:
00000FC4  48E7 3820 1432          movem.l   D2/D3/D4/A2,-(A7)
00000FC8  45F9 0000 1433          lea       _printf.L,A2
00000FCC  3532      
                    1434   ; unsigned char *RamPtr,c ; // pointer to memory
                    1435   ; int Data ;
                    1436   ; printf("\r\nExamine and Change Memory") ;
00000FCE  4879 0000 1437          pea       @m68kde~2_17.L
00000FD2  3FAC      
00000FD4  4E92      1438          jsr       (A2)
00000FD6  584F      1439          addq.w    #4,A7
                    1440   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
00000FD8  4879 0000 1441          pea       @m68kde~2_18.L
00000FDC  3FC8      
00000FDE  4E92      1442          jsr       (A2)
00000FE0  584F      1443          addq.w    #4,A7
                    1444   ; printf("\r\nEnter Address: ") ;
00000FE2  4879 0000 1445          pea       @m68kde~2_19.L
00000FE6  400E      
00000FE8  4E92      1446          jsr       (A2)
00000FEA  584F      1447          addq.w    #4,A7
                    1448   ; RamPtr = Get8HexDigits(0) ;
00000FEC  42A7      1449          clr.l     -(A7)
00000FEE  4EB8 0CA4 1450          jsr       _Get8HexDigits
00000FF2  584F      1451          addq.w    #4,A7
00000FF4  2600      1452          move.l    D0,D3
                    1453   ; while(1)    {
                    1454   MemoryChange_1:
                    1455   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
00000FF6  2043      1456          move.l    D3,A0
00000FF8  1210      1457          move.b    (A0),D1
00000FFA  C2BC 0000 1458          and.l     #255,D1
00000FFE  00FF      
00001000  2F01      1459          move.l    D1,-(A7)
00001002  2F03      1460          move.l    D3,-(A7)
00001004  4879 0000 1461          pea       @m68kde~2_20.L
00001008  4020      
0000100A  4E92      1462          jsr       (A2)
0000100C  DEFC 000C 1463          add.w     #12,A7
                    1464   ; c = tolower(_getch()) ;
00001010  2F00      1465          move.l    D0,-(A7)
00001012  4EB8 0B68 1466          jsr       __getch
00001016  2200      1467          move.l    D0,D1
00001018  201F      1468          move.l    (A7)+,D0
0000101A  2F01      1469          move.l    D1,-(A7)
0000101C  4EB9 0000 1470          jsr       _tolower
00001020  34B2      
00001022  584F      1471          addq.w    #4,A7
00001024  1400      1472          move.b    D0,D2
                    1473   ; if(c == (char)(0x1b))
00001026  0C02 001B 1474          cmp.b     #27,D2
0000102A  6604      1475          bne.s     MemoryChange_4
                    1476   ; return ;                                // abort on escape
0000102C  6000 0090 1477          bra       MemoryChange_6
                    1478   MemoryChange_4:
                    1479   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001030  0C02 0030 1480          cmp.b     #48,D2
00001034  6506      1481          blo.s     MemoryChange_10
00001036  0C02 0039 1482          cmp.b     #57,D2
0000103A  6310      1483          bls.s     MemoryChange_9
                    1484   MemoryChange_10:
0000103C  0C02 0061 1485          cmp.b     #97,D2
00001040  6500 006E 1486          blo       MemoryChange_7
00001044  0C02 0066 1487          cmp.b     #102,D2
00001048  6200 0066 1488          bhi       MemoryChange_7
                    1489   MemoryChange_9:
                    1490   ; Data = (xtod(c) << 4) | (xtod(_getch()));
0000104C  C4BC 0000 1491          and.l     #255,D2
00001050  00FF      
00001052  2F02      1492          move.l    D2,-(A7)
00001054  4EB8 0BD2 1493          jsr       _xtod
00001058  584F      1494          addq.w    #4,A7
0000105A  C0BC 0000 1495          and.l     #255,D0
0000105E  00FF      
00001060  E980      1496          asl.l     #4,D0
00001062  2F00      1497          move.l    D0,-(A7)
00001064  2F01      1498          move.l    D1,-(A7)
00001066  4EB8 0B68 1499          jsr       __getch
0000106A  221F      1500          move.l    (A7)+,D1
0000106C  2F00      1501          move.l    D0,-(A7)
0000106E  4EB8 0BD2 1502          jsr       _xtod
00001072  584F      1503          addq.w    #4,A7
00001074  2200      1504          move.l    D0,D1
00001076  201F      1505          move.l    (A7)+,D0
00001078  C2BC 0000 1506          and.l     #255,D1
0000107C  00FF      
0000107E  8081      1507          or.l      D1,D0
00001080  2800      1508          move.l    D0,D4
                    1509   ; *RamPtr = (char)(Data) ;
00001082  2043      1510          move.l    D3,A0
00001084  1084      1511          move.b    D4,(A0)
                    1512   ; if(*RamPtr != Data) {
00001086  2043      1513          move.l    D3,A0
00001088  1010      1514          move.b    (A0),D0
0000108A  C0BC 0000 1515          and.l     #255,D0
0000108E  00FF      
00001090  B084      1516          cmp.l     D4,D0
00001092  671A      1517          beq.s     MemoryChange_11
                    1518   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
00001094  2043      1519          move.l    D3,A0
00001096  1210      1520          move.b    (A0),D1
00001098  C2BC 0000 1521          and.l     #255,D1
0000109C  00FF      
0000109E  2F01      1522          move.l    D1,-(A7)
000010A0  2F04      1523          move.l    D4,-(A7)
000010A2  4879 0000 1524          pea       @m68kde~2_21.L
000010A6  4032      
000010A8  4E92      1525          jsr       (A2)
000010AA  DEFC 000C 1526          add.w     #12,A7
                    1527   MemoryChange_11:
000010AE  6008      1528          bra.s     MemoryChange_13
                    1529   MemoryChange_7:
                    1530   ; }
                    1531   ; }
                    1532   ; else if(c == (char)('-'))
000010B0  0C02 002D 1533          cmp.b     #45,D2
000010B4  6602      1534          bne.s     MemoryChange_13
                    1535   ; RamPtr -= 2 ; ;
000010B6  5583      1536          subq.l    #2,D3
                    1537   MemoryChange_13:
                    1538   ; RamPtr ++ ;
000010B8  5283      1539          addq.l    #1,D3
000010BA  6000 FF3A 1540          bra       MemoryChange_1
                    1541   MemoryChange_6:
000010BE  4CDF 041C 1542          movem.l   (A7)+,D2/D3/D4/A2
000010C2  4E75      1543          rts
                    1544   ; }
                    1545   ; }
                    1546   ; /*******************************************************************
                    1547   ; ** SPI Initiallization
                    1548   ; ********************************************************************/
                    1549   ; /*************************************************************
                    1550   ; ** SPI Controller registers
                    1551   ; **************************************************************/
                    1552   ; // SPI Registers
                    1553   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                    1554   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                    1555   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                    1556   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                    1557   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                    1558   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                    1559   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                    1560   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                    1561   ; // and write FF to disable it
                    1562   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                    1563   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                    1564   ; /******************************************************************************************
                    1565   ; ** The following code is for the SPI controller
                    1566   ; *******************************************************************************************/
                    1567   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1568   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1569   ; int TestForSPITransmitDataComplete(void){
                    1570   _TestForSPITransmitDataComplete:
                    1571   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1572   ; //printf("\r\nTestForSPITransmitDataComplete SPI Status: %x", SPI_Status);
                    1573   ; return (((SPI_Status & 0x80)>>7)%2);
000010C4  1039 0040 1574          move.b    4227106,D0
000010C8  8022      
000010CA  C07C 00FF 1575          and.w     #255,D0
000010CE  C07C 0080 1576          and.w     #128,D0
000010D2  EE40      1577          asr.w     #7,D0
000010D4  C0BC 0000 1578          and.l     #65535,D0
000010D8  FFFF      
000010DA  81FC 0002 1579          divs.w    #2,D0
000010DE  4840      1580          swap      D0
000010E0  48C0      1581          ext.l     D0
000010E2  4E75      1582          rts
                    1583   ; }
                    1584   ; /************************************************************************************
                    1585   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1586   ; ************************************************************************************/
                    1587   ; void SPI_Init(void)
                    1588   ; {
                    1589   _SPI_Init:
                    1590   ; //TODO
                    1591   ; //
                    1592   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1593   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1594   ; //
                    1595   ; // Here are some settings we want to create
                    1596   ; //
                    1597   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1598   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1599   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1600   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1601   ; SPI_Control = 0x53; //0101_0011
000010E4  13FC 0053 1602          move.b    #83,4227104
000010E8  0040 8020 
                    1603   ; SPI_Ext = 0x00;//0000_0000
000010EC  4239 0040 1604          clr.b     4227110
000010F0  8026      
                    1605   ; Disable_SPI_CS();
000010F2  13FC 00FF 1606          move.b    #255,4227112
000010F6  0040 8028 
                    1607   ; SPI_Status = 0xC0; //1100_0000 --> clear the write collision and interrupt
000010FA  13FC 00C0 1608          move.b    #192,4227106
000010FE  0040 8022 
00001102  4E75      1609          rts
                    1610   ; //printf("\r\nSPI Status in SPI_Init: %x", SPI_Status);
                    1611   ; }
                    1612   ; /************************************************************************************
                    1613   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1614   ; ************************************************************************************/
                    1615   ; void WaitForSPITransmitComplete(void)
                    1616   ; {
                    1617   _WaitForSPITransmitComplete:
00001104  2F02      1618          move.l    D2,-(A7)
                    1619   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1620   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1621   ; // just in case they were set
                    1622   ; int test_complete = TestForSPITransmitDataComplete();
00001106  4EB8 10C4 1623          jsr       _TestForSPITransmitDataComplete
0000110A  2400      1624          move.l    D0,D2
                    1625   ; //printf("\r\nWaitForSPITransmitComplete: Before entering while loop SPIF: %x", test_complete);
                    1626   ; while(!test_complete){ // only on SPIF bit being set
                    1627   WaitForSPITransmitComplete_1:
0000110C  4A82      1628          tst.l     D2
0000110E  6608      1629          bne.s     WaitForSPITransmitComplete_3
                    1630   ; //printf("\r\nWaitForSPITransmitComplete: Inside while loop SPIF: %x", test_complete);
                    1631   ; test_complete = TestForSPITransmitDataComplete();
00001110  4EB8 10C4 1632          jsr       _TestForSPITransmitDataComplete
00001114  2400      1633          move.l    D0,D2
00001116  60F4      1634          bra       WaitForSPITransmitComplete_1
                    1635   WaitForSPITransmitComplete_3:
                    1636   ; }
                    1637   ; SPI_Status = 0xC0; //1100_0000 --> clear the write collision and interrupt
00001118  13FC 00C0 1638          move.b    #192,4227106
0000111C  0040 8022 
00001120  241F      1639          move.l    (A7)+,D2
00001122  4E75      1640          rts
                    1641   ; //printf("\r\nWaitForSPITransmitComplete: SPI Status after clearing in WaitForSPITransmit: %x", SPI_Status);
                    1642   ; }
                    1643   ; /************************************************************************************
                    1644   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1645   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1646   ; ************************************************************************************/
                    1647   ; int WriteSPIChar(int c)
                    1648   ; {
                    1649   _WriteSPIChar:
00001124  4E56 FFFC 1650          link      A6,#-4
                    1651   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1652   ; // wait for completion of transmission
                    1653   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1654   ; // by reading fom the SPI controller Data Register.
                    1655   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1656   ; //
                    1657   ; // modify '0' below to return back read byte from data register
                    1658   ; //
                    1659   ; // xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_nnnn_nnnn
                    1660   ; // 0x00FF
                    1661   ; int read_back;
                    1662   ; SPI_Data = c; // read lowermost byte
00001128  202E 0008 1663          move.l    8(A6),D0
0000112C  13C0 0040 1664          move.b    D0,4227108
00001130  8024      
                    1665   ; //printf("\r\nWriteSPIChar: Sending data: %x", c);
                    1666   ; WaitForSPITransmitComplete();
00001132  4EB8 1104 1667          jsr       _WaitForSPITransmitComplete
                    1668   ; read_back = SPI_Data;
00001136  1039 0040 1669          move.b    4227108,D0
0000113A  8024      
0000113C  C0BC 0000 1670          and.l     #255,D0
00001140  00FF      
00001142  2D40 FFFC 1671          move.l    D0,-4(A6)
                    1672   ; return read_back; //return read data
00001146  202E FFFC 1673          move.l    -4(A6),D0
0000114A  4E5E      1674          unlk      A6
0000114C  4E75      1675          rts
                    1676   ; }
                    1677   ; // writing dummy data to read useful data as output from read FIFO
                    1678   ; int  ReadSPIChar(void){
                    1679   _ReadSPIChar:
0000114E  4E56 FFFC 1680          link      A6,#-4
                    1681   ; int read_data;
                    1682   ; //printf("\r\nReadSPIChar: Calling WriteSPIChar to write dummy data");
                    1683   ; read_data = WriteSPIChar(0xCA); //write dummy data
00001152  4878 00CA 1684          pea       202
00001156  4EB8 1124 1685          jsr       _WriteSPIChar
0000115A  584F      1686          addq.w    #4,A7
0000115C  2D40 FFFC 1687          move.l    D0,-4(A6)
                    1688   ; //printf("\r\nReadSPIChar: Read Data: %x", read_data);
                    1689   ; return read_data; // expect to read useful data from read FIFO
00001160  202E FFFC 1690          move.l    -4(A6),D0
00001164  4E5E      1691          unlk      A6
00001166  4E75      1692          rts
                    1693   ; }
                    1694   ; void SetSPIFlashWriteEnableLatch(void){
                    1695   _SetSPIFlashWriteEnableLatch:
00001168  4E56 FFFC 1696          link      A6,#-4
                    1697   ; int issue_write_enable;
                    1698   ; Enable_SPI_CS();
0000116C  13FC 00FE 1699          move.b    #254,4227112
00001170  0040 8028 
                    1700   ; //printf("\r\nSetSPIFlashWriteEnableLatch: Issuing Write Enable command");
                    1701   ; issue_write_enable = WriteSPIChar(0x06);//write enable command
00001174  4878 0006 1702          pea       6
00001178  4EB8 1124 1703          jsr       _WriteSPIChar
0000117C  584F      1704          addq.w    #4,A7
0000117E  2D40 FFFC 1705          move.l    D0,-4(A6)
                    1706   ; Disable_SPI_CS();  // drive CS high
00001182  13FC 00FF 1707          move.b    #255,4227112
00001186  0040 8028 
0000118A  4E5E      1708          unlk      A6
0000118C  4E75      1709          rts
                    1710   ; }
                    1711   ; //
                    1712   ; void ClearSPIFlashWriteEnableLatch(void){
                    1713   _ClearSPIFlashWriteEnableLatch:
0000118E  4E56 FFFC 1714          link      A6,#-4
                    1715   ; int issue_write_disable;
                    1716   ; Enable_SPI_CS();
00001192  13FC 00FE 1717          move.b    #254,4227112
00001196  0040 8028 
                    1718   ; //printf("\r\nClearSPIFlashWriteEnableLatch: Issuing Write Disable command");
                    1719   ; issue_write_disable = WriteSPIChar(0x04); // write disable command
0000119A  4878 0004 1720          pea       4
0000119E  4EB8 1124 1721          jsr       _WriteSPIChar
000011A2  584F      1722          addq.w    #4,A7
000011A4  2D40 FFFC 1723          move.l    D0,-4(A6)
                    1724   ; Disable_SPI_CS();
000011A8  13FC 00FF 1725          move.b    #255,4227112
000011AC  0040 8028 
000011B0  4E5E      1726          unlk      A6
000011B2  4E75      1727          rts
                    1728   ; }
                    1729   ; //
                    1730   ; int  ReadSPIFlashStatusReg(void){
                    1731   _ReadSPIFlashStatusReg:
000011B4  2F02      1732          move.l    D2,-(A7)
                    1733   ; int status_reg_1;
                    1734   ; //printf("\r\nReadSPIFlashStatusReg: Issuing read status register 1 command");
                    1735   ; Enable_SPI_CS();
000011B6  13FC 00FE 1736          move.b    #254,4227112
000011BA  0040 8028 
                    1737   ; status_reg_1 = WriteSPIChar(0x05);
000011BE  4878 0005 1738          pea       5
000011C2  4EB8 1124 1739          jsr       _WriteSPIChar
000011C6  584F      1740          addq.w    #4,A7
000011C8  2400      1741          move.l    D0,D2
                    1742   ; //printf("\r\nReadSPIFlashStatusReg: Reading status register 1");
                    1743   ; status_reg_1 = ReadSPIChar(); // read status register 1 value
000011CA  4EB8 114E 1744          jsr       _ReadSPIChar
000011CE  2400      1745          move.l    D0,D2
                    1746   ; Disable_SPI_CS();
000011D0  13FC 00FF 1747          move.b    #255,4227112
000011D4  0040 8028 
                    1748   ; //printf("\r\nFlash Status Register 1: %x", status_reg_1);
                    1749   ; return status_reg_1;
000011D8  2002      1750          move.l    D2,D0
000011DA  241F      1751          move.l    (A7)+,D2
000011DC  4E75      1752          rts
                    1753   ; }
                    1754   ; ////
                    1755   ; //void WaitForSPIFlashWriteCompletion(void){
                    1756   ; //    int SPIFlashStatusReg;
                    1757   ; //    SPIFlashStatusReg = ReadSPIFlashStatusReg() & 0x01; // get LSB --> Busy Bit
                    1758   ; //    while(SPIFlashStatusReg){
                    1759   ; //        SPIFlashStatusReg = ReadSPIFlashStatusReg() & 0x01; // keep checking until busy bit = 0
                    1760   ; //    }
                    1761   ; //}
                    1762   ; void WaitForSPIFlashWriteCompletion(void){
                    1763   _WaitForSPIFlashWriteCompletion:
000011DE  4E56 FFF8 1764          link      A6,#-8
000011E2  2F02      1765          move.l    D2,-(A7)
                    1766   ; int write_complete = 1;
000011E4  7401      1767          moveq     #1,D2
                    1768   ; int issue_read_status_reg_1;
                    1769   ; int stat_reg;
                    1770   ; //printf("\r\nWaitForSPIFlashWriteCompletion: Issuing read status register 1 command");
                    1771   ; Enable_SPI_CS();
000011E6  13FC 00FE 1772          move.b    #254,4227112
000011EA  0040 8028 
                    1773   ; issue_read_status_reg_1 = WriteSPIChar(0x05); // read status register-1 command
000011EE  4878 0005 1774          pea       5
000011F2  4EB8 1124 1775          jsr       _WriteSPIChar
000011F6  584F      1776          addq.w    #4,A7
000011F8  2D40 FFF8 1777          move.l    D0,-8(A6)
                    1778   ; //printf("\r\nWaitForSPIFlashWriteCompletion: Polling read status register 1 command");
                    1779   ; while(write_complete){ // poll until flash write is completed
                    1780   WaitForSPIFlashWriteCompletion_1:
000011FC  4A82      1781          tst.l     D2
000011FE  6716      1782          beq.s     WaitForSPIFlashWriteCompletion_3
                    1783   ; stat_reg = ReadSPIChar();
00001200  4EB8 114E 1784          jsr       _ReadSPIChar
00001204  2D40 FFFC 1785          move.l    D0,-4(A6)
                    1786   ; //printf("\r\nWaitForSPIFlashWriteCompletion: Status_Reg:  %x", stat_reg);
                    1787   ; write_complete = stat_reg & 0x01;
00001208  202E FFFC 1788          move.l    -4(A6),D0
0000120C  C0BC 0000 1789          and.l     #1,D0
00001210  0001      
00001212  2400      1790          move.l    D0,D2
00001214  60E6      1791          bra       WaitForSPIFlashWriteCompletion_1
                    1792   WaitForSPIFlashWriteCompletion_3:
                    1793   ; //printf("\r\nWaitForSPIFlashWriteCompletion: write complete flag: %x", write_complete);
                    1794   ; }
                    1795   ; //printf("\r\nWaitForSPIFlashWriteCompletion: write complete flag: %x", write_complete);
                    1796   ; Disable_SPI_CS();
00001216  13FC 00FF 1797          move.b    #255,4227112
0000121A  0040 8028 
0000121E  241F      1798          move.l    (A7)+,D2
00001220  4E5E      1799          unlk      A6
00001222  4E75      1800          rts
                    1801   ; //printf("\r\nWaitForSPIFlashWriteCompletion: Write Completed");
                    1802   ; }
                    1803   ; //
                    1804   ; int  ReadSPIFlashByte( int FlashAddress){
                    1805   _ReadSPIFlashByte:
00001224  4E56 0000 1806          link      A6,#0
00001228  48E7 3020 1807          movem.l   D2/D3/A2,-(A7)
0000122C  45F8 1124 1808          lea       _WriteSPIChar.L,A2
00001230  262E 0008 1809          move.l    8(A6),D3
                    1810   ; int read_data;
                    1811   ; Enable_SPI_CS();
00001234  13FC 00FE 1812          move.b    #254,4227112
00001238  0040 8028 
                    1813   ; read_data = WriteSPIChar(0x03);
0000123C  4878 0003 1814          pea       3
00001240  4E92      1815          jsr       (A2)
00001242  584F      1816          addq.w    #4,A7
00001244  2400      1817          move.l    D0,D2
                    1818   ; read_data = WriteSPIChar((FlashAddress >> 16) & 0xFF); // write upper 8 bits of address
00001246  2203      1819          move.l    D3,D1
00001248  E081      1820          asr.l     #8,D1
0000124A  E081      1821          asr.l     #8,D1
0000124C  C2BC 0000 1822          and.l     #255,D1
00001250  00FF      
00001252  2F01      1823          move.l    D1,-(A7)
00001254  4E92      1824          jsr       (A2)
00001256  584F      1825          addq.w    #4,A7
00001258  2400      1826          move.l    D0,D2
                    1827   ; read_data = WriteSPIChar((FlashAddress >> 8) & 0xFF); // write middle 8 bits of address
0000125A  2203      1828          move.l    D3,D1
0000125C  E081      1829          asr.l     #8,D1
0000125E  C2BC 0000 1830          and.l     #255,D1
00001262  00FF      
00001264  2F01      1831          move.l    D1,-(A7)
00001266  4E92      1832          jsr       (A2)
00001268  584F      1833          addq.w    #4,A7
0000126A  2400      1834          move.l    D0,D2
                    1835   ; read_data = WriteSPIChar(FlashAddress & 0xFF); // write lower 8 bits of address
0000126C  2203      1836          move.l    D3,D1
0000126E  C2BC 0000 1837          and.l     #255,D1
00001272  00FF      
00001274  2F01      1838          move.l    D1,-(A7)
00001276  4E92      1839          jsr       (A2)
00001278  584F      1840          addq.w    #4,A7
0000127A  2400      1841          move.l    D0,D2
                    1842   ; read_data = ReadSPIChar();
0000127C  4EB8 114E 1843          jsr       _ReadSPIChar
00001280  2400      1844          move.l    D0,D2
                    1845   ; Disable_SPI_CS();
00001282  13FC 00FF 1846          move.b    #255,4227112
00001286  0040 8028 
                    1847   ; return read_data;
0000128A  2002      1848          move.l    D2,D0
0000128C  4CDF 040C 1849          movem.l   (A7)+,D2/D3/A2
00001290  4E5E      1850          unlk      A6
00001292  4E75      1851          rts
                    1852   ; }
                    1853   ; //
                    1854   ; void ReadSPIFlashData( int FlashAddress, unsigned char *MemoryAddress, int size){
                    1855   _ReadSPIFlashData:
00001294  4E56 0000 1856          link      A6,#0
00001298  48E7 3820 1857          movem.l   D2/D3/D4/A2,-(A7)
0000129C  45F8 1124 1858          lea       _WriteSPIChar.L,A2
000012A0  282E 0008 1859          move.l    8(A6),D4
                    1860   ; int issue_read;
                    1861   ; int i;
                    1862   ; Enable_SPI_CS();
000012A4  13FC 00FE 1863          move.b    #254,4227112
000012A8  0040 8028 
                    1864   ; issue_read = WriteSPIChar(0x03);
000012AC  4878 0003 1865          pea       3
000012B0  4E92      1866          jsr       (A2)
000012B2  584F      1867          addq.w    #4,A7
000012B4  2600      1868          move.l    D0,D3
                    1869   ; issue_read = WriteSPIChar((FlashAddress >> 16) & 0xFF); // write upper 8 bits of address
000012B6  2204      1870          move.l    D4,D1
000012B8  E081      1871          asr.l     #8,D1
000012BA  E081      1872          asr.l     #8,D1
000012BC  C2BC 0000 1873          and.l     #255,D1
000012C0  00FF      
000012C2  2F01      1874          move.l    D1,-(A7)
000012C4  4E92      1875          jsr       (A2)
000012C6  584F      1876          addq.w    #4,A7
000012C8  2600      1877          move.l    D0,D3
                    1878   ; issue_read = WriteSPIChar((FlashAddress >> 8) & 0xFF); // write middle 8 bits of address
000012CA  2204      1879          move.l    D4,D1
000012CC  E081      1880          asr.l     #8,D1
000012CE  C2BC 0000 1881          and.l     #255,D1
000012D2  00FF      
000012D4  2F01      1882          move.l    D1,-(A7)
000012D6  4E92      1883          jsr       (A2)
000012D8  584F      1884          addq.w    #4,A7
000012DA  2600      1885          move.l    D0,D3
                    1886   ; issue_read = WriteSPIChar(FlashAddress & 0xFF);
000012DC  2204      1887          move.l    D4,D1
000012DE  C2BC 0000 1888          and.l     #255,D1
000012E2  00FF      
000012E4  2F01      1889          move.l    D1,-(A7)
000012E6  4E92      1890          jsr       (A2)
000012E8  584F      1891          addq.w    #4,A7
000012EA  2600      1892          move.l    D0,D3
                    1893   ; for(i = 0; i < size; i++){
000012EC  4282      1894          clr.l     D2
                    1895   ReadSPIFlashData_1:
000012EE  B4AE 0010 1896          cmp.l     16(A6),D2
000012F2  6C10      1897          bge.s     ReadSPIFlashData_3
                    1898   ; MemoryAddress[i] = ReadSPIChar();
000012F4  4EB8 114E 1899          jsr       _ReadSPIChar
000012F8  206E 000C 1900          move.l    12(A6),A0
000012FC  1180 2800 1901          move.b    D0,0(A0,D2.L)
00001300  5282      1902          addq.l    #1,D2
00001302  60EA      1903          bra       ReadSPIFlashData_1
                    1904   ReadSPIFlashData_3:
                    1905   ; }
                    1906   ; Disable_SPI_CS();
00001304  13FC 00FF 1907          move.b    #255,4227112
00001308  0040 8028 
0000130C  4CDF 041C 1908          movem.l   (A7)+,D2/D3/D4/A2
00001310  4E5E      1909          unlk      A6
00001312  4E75      1910          rts
                    1911   ; }
                    1912   ; //
                    1913   ; void EraseSPIFlashChip(void){
                    1914   _EraseSPIFlashChip:
00001314  4E56 FFFC 1915          link      A6,#-4
                    1916   ; int issue_erase;
                    1917   ; printf("\r\nErasing Flash chip....");
00001318  4879 0000 1918          pea       @m68kde~2_22.L
0000131C  4066      
0000131E  4EB9 0000 1919          jsr       _printf
00001322  3532      
00001324  584F      1920          addq.w    #4,A7
                    1921   ; SetSPIFlashWriteEnableLatch();
00001326  4EB8 1168 1922          jsr       _SetSPIFlashWriteEnableLatch
                    1923   ; Enable_SPI_CS();
0000132A  13FC 00FE 1924          move.b    #254,4227112
0000132E  0040 8028 
                    1925   ; // printf("\r\nEraseSPIFlashChip: Issuing Chip Erase command");
                    1926   ; issue_erase = WriteSPIChar(0xC7);
00001332  4878 00C7 1927          pea       199
00001336  4EB8 1124 1928          jsr       _WriteSPIChar
0000133A  584F      1929          addq.w    #4,A7
0000133C  2D40 FFFC 1930          move.l    D0,-4(A6)
                    1931   ; Disable_SPI_CS();
00001340  13FC 00FF 1932          move.b    #255,4227112
00001344  0040 8028 
                    1933   ; // printf("\r\nWaiting for SPI Write Completion");
                    1934   ; WaitForSPIFlashWriteCompletion();
00001348  4EB8 11DE 1935          jsr       _WaitForSPIFlashWriteCompletion
                    1936   ; // printf("\r\nClearning SPI Write enable");
                    1937   ; ClearSPIFlashWriteEnableLatch();
0000134C  4EB8 118E 1938          jsr       _ClearSPIFlashWriteEnableLatch
                    1939   ; printf("\r\n********Finished erasing********");
00001350  4879 0000 1940          pea       @m68kde~2_23.L
00001354  4080      
00001356  4EB9 0000 1941          jsr       _printf
0000135A  3532      
0000135C  584F      1942          addq.w    #4,A7
0000135E  4E5E      1943          unlk      A6
00001360  4E75      1944          rts
                    1945   ; }
                    1946   ; //
                    1947   ; void WriteSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size){
                    1948   _WriteSPIFlashData:
00001362  4E56 FFFC 1949          link      A6,#-4
00001366  48E7 3E20 1950          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
0000136A  45F8 1124 1951          lea       _WriteSPIChar.L,A2
0000136E  2A2E 0008 1952          move.l    8(A6),D5
00001372  2C2E 0010 1953          move.l    16(A6),D6
                    1954   ; int issue_page_program;
                    1955   ; int num_bytes_to_write;
                    1956   ; int i;
                    1957   ; int mem_data;
                    1958   ; //printf("\r\nWriteSPIFlashData: Start Flash Address: %08x", FlashAddress);
                    1959   ; //printf("\r\nWriteSPIFlashData: Start Memory Address: %08x", MemoryAddress);
                    1960   ; // TODO: add erase sector before doing any writes
                    1961   ; // TODO: consider how to handle FlashAddress not being integer multiple of 256
                    1962   ; // TODO: consider how to handle if we write an incomplete page (case where num_bytes < 256)
                    1963   ; //printf("\r\nWriteSPIFlashData: -------------Entering loop -----------");
                    1964   ; //printf("\r\n*****Write Enabled*****");
                    1965   ; printf("\r\nWriting Program to flash....");
00001376  4879 0000 1966          pea       @m68kde~2_24.L
0000137A  40A4      
0000137C  4EB9 0000 1967          jsr       _printf
00001380  3532      
00001382  584F      1968          addq.w    #4,A7
                    1969   ; while(size > 0){
                    1970   WriteSPIFlashData_1:
00001384  0C86 0000 1971          cmp.l     #0,D6
00001388  0000      
0000138A  6F00 00A4 1972          ble       WriteSPIFlashData_3
                    1973   ; //printf("\r\nWriteSPIFlashData: *****Size(%d)*****", size);
                    1974   ; num_bytes_to_write = (size > 256) ? 256 : size; // max 256 bytes per page
0000138E  0C86 0000 1975          cmp.l     #256,D6
00001392  0100      
00001394  6F08      1976          ble.s     WriteSPIFlashData_4
00001396  303C 0100 1977          move.w    #256,D0
0000139A  48C0      1978          ext.l     D0
0000139C  6002      1979          bra.s     WriteSPIFlashData_5
                    1980   WriteSPIFlashData_4:
0000139E  2006      1981          move.l    D6,D0
                    1982   WriteSPIFlashData_5:
000013A0  2600      1983          move.l    D0,D3
                    1984   ; //printf("\r\nWriteSPIFlashData: *****Num bytes(%d)*****", num_bytes_to_write);
                    1985   ; SetSPIFlashWriteEnableLatch();
000013A2  4EB8 1168 1986          jsr       _SetSPIFlashWriteEnableLatch
                    1987   ; //printf("\r\n*****Write Enabled*****");
                    1988   ; Enable_SPI_CS();
000013A6  13FC 00FE 1989          move.b    #254,4227112
000013AA  0040 8028 
                    1990   ; issue_page_program = WriteSPIChar(0x02); // write the page program command
000013AE  4878 0002 1991          pea       2
000013B2  4E92      1992          jsr       (A2)
000013B4  584F      1993          addq.w    #4,A7
000013B6  2400      1994          move.l    D0,D2
                    1995   ; //printf("\r\nWriteSPIFlashData: *****Page Program Command Sent*****");
                    1996   ; issue_page_program = WriteSPIChar((FlashAddress >> 16) & 0x000000FF); // write upper 8 bits of address
000013B8  2205      1997          move.l    D5,D1
000013BA  E081      1998          asr.l     #8,D1
000013BC  E081      1999          asr.l     #8,D1
000013BE  C2BC 0000 2000          and.l     #255,D1
000013C2  00FF      
000013C4  2F01      2001          move.l    D1,-(A7)
000013C6  4E92      2002          jsr       (A2)
000013C8  584F      2003          addq.w    #4,A7
000013CA  2400      2004          move.l    D0,D2
                    2005   ; issue_page_program = WriteSPIChar((FlashAddress >> 8) & 0x000000FF); // write middle 8 bits of address
000013CC  2205      2006          move.l    D5,D1
000013CE  E081      2007          asr.l     #8,D1
000013D0  C2BC 0000 2008          and.l     #255,D1
000013D4  00FF      
000013D6  2F01      2009          move.l    D1,-(A7)
000013D8  4E92      2010          jsr       (A2)
000013DA  584F      2011          addq.w    #4,A7
000013DC  2400      2012          move.l    D0,D2
                    2013   ; issue_page_program = WriteSPIChar(FlashAddress & 0x000000FF); // write lower 8 bits of address
000013DE  2205      2014          move.l    D5,D1
000013E0  C2BC 0000 2015          and.l     #255,D1
000013E4  00FF      
000013E6  2F01      2016          move.l    D1,-(A7)
000013E8  4E92      2017          jsr       (A2)
000013EA  584F      2018          addq.w    #4,A7
000013EC  2400      2019          move.l    D0,D2
                    2020   ; //printf("\r\nWriteSPIFlashData: ------------- Finished sending address -----------");
                    2021   ; for (i = 0; i < num_bytes_to_write; i++){
000013EE  4284      2022          clr.l     D4
                    2023   WriteSPIFlashData_6:
000013F0  B883      2024          cmp.l     D3,D4
000013F2  6C20      2025          bge.s     WriteSPIFlashData_8
                    2026   ; //printf("\r\nWriteSPIFlashData: Writing data: %02x", MemoryAddress[i]);
                    2027   ; mem_data = MemoryAddress[i];
000013F4  206E 000C 2028          move.l    12(A6),A0
000013F8  1030 4800 2029          move.b    0(A0,D4.L),D0
000013FC  C0BC 0000 2030          and.l     #255,D0
00001400  00FF      
00001402  2D40 FFFC 2031          move.l    D0,-4(A6)
                    2032   ; issue_page_program = WriteSPIChar(mem_data); // write data from memory buffer in one byte chunks
00001406  2F2E FFFC 2033          move.l    -4(A6),-(A7)
0000140A  4E92      2034          jsr       (A2)
0000140C  584F      2035          addq.w    #4,A7
0000140E  2400      2036          move.l    D0,D2
00001410  5284      2037          addq.l    #1,D4
00001412  60DC      2038          bra       WriteSPIFlashData_6
                    2039   WriteSPIFlashData_8:
                    2040   ; }
                    2041   ; //printf("\r\nWriteSPIFlashData:-------------Finished loop -----------");
                    2042   ; Disable_SPI_CS();
00001414  13FC 00FF 2043          move.b    #255,4227112
00001418  0040 8028 
                    2044   ; WaitForSPIFlashWriteCompletion(); // wait until write is completed (polling for completion)
0000141C  4EB8 11DE 2045          jsr       _WaitForSPIFlashWriteCompletion
                    2046   ; //printf("\r\nWriteSPIFlashData: Finished SPI writing");
                    2047   ; FlashAddress += num_bytes_to_write;
00001420  DA83      2048          add.l     D3,D5
                    2049   ; MemoryAddress += num_bytes_to_write;
00001422  D7AE 000C 2050          add.l     D3,12(A6)
                    2051   ; //printf("\r\nWriteSPIFlashData: Flash Address: %08x", FlashAddress);
                    2052   ; //printf("\r\nWriteSPIFlashData: Memory Address: %08x", MemoryAddress);
                    2053   ; size -= num_bytes_to_write;
00001426  9C83      2054          sub.l     D3,D6
                    2055   ; ClearSPIFlashWriteEnableLatch();
00001428  4EB8 118E 2056          jsr       _ClearSPIFlashWriteEnableLatch
0000142C  6000 FF56 2057          bra       WriteSPIFlashData_1
                    2058   WriteSPIFlashData_3:
                    2059   ; //printf("\r\nWriteSPIFlashData: *****Write disabled*****");
                    2060   ; }
                    2061   ; printf("\r\n********Flash Programmed********");
00001430  4879 0000 2062          pea       @m68kde~2_25.L
00001434  40C4      
00001436  4EB9 0000 2063          jsr       _printf
0000143A  3532      
0000143C  584F      2064          addq.w    #4,A7
0000143E  4CDF 047C 2065          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001442  4E5E      2066          unlk      A6
00001444  4E75      2067          rts
                    2068   ; }
                    2069   ; /*******************************************************************
                    2070   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    2071   ; ********************************************************************/
                    2072   ; void ProgramFlashChip(void)
                    2073   ; {
                    2074   _ProgramFlashChip:
00001446  48E7 3F20 2075          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000144A  45F9 0000 2076          lea       _printf.L,A2
0000144E  3532      
                    2077   ; //
                    2078   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    2079   ; // TODO : then verify by reading it back and comparing to memory
                    2080   ; //
                    2081   ; int read_data;
                    2082   ; unsigned char* mem_pointer;
                    2083   ; int flash_address;
                    2084   ; int i;
                    2085   ; int size;
                    2086   ; int success;
                    2087   ; //unsigned char custom[4096] = { 0 };
                    2088   ; //unsigned char *temp;
                    2089   ; mem_pointer = 0x08000000; // source
00001450  263C 0800 2090          move.l    #134217728,D3
00001454  0000      
                    2091   ; flash_address = 0x00000000; // destination
00001456  4284      2092          clr.l     D4
                    2093   ; success = 1;
00001458  7E01      2094          moveq     #1,D7
                    2095   ; size = 262144;
0000145A  2C3C 0004 2096          move.l    #262144,D6
0000145E  0000      
                    2097   ; //printf("\r\nEnter the size of data to Read from RAM: ");
                    2098   ; //size = Get6HexDigits(0);
                    2099   ; EraseSPIFlashChip();
00001460  4EB8 1314 2100          jsr       _EraseSPIFlashChip
                    2101   ; //for(i = 0; i < size; i++){
                    2102   ; //    custom[i] = *(mem_pointer + i);
                    2103   ; //}
                    2104   ; // before writeSPIFlashData: flash_address (pass by value) = 0x00000000; custom (pass by reference), size
                    2105   ; WriteSPIFlashData(flash_address, mem_pointer, size);
00001464  2F06      2106          move.l    D6,-(A7)
00001466  2F03      2107          move.l    D3,-(A7)
00001468  2F04      2108          move.l    D4,-(A7)
0000146A  4EB8 1362 2109          jsr       _WriteSPIFlashData
0000146E  DEFC 000C 2110          add.w     #12,A7
                    2111   ; // after: flash_address unchanged, custom is changed by num_bytes_written, size unchanged since pass by value
                    2112   ; //mem_pointer = 0x08000000; // preserve the old value after WriteSPIFlashData
                    2113   ; printf("\r\nVerifying the read....");
00001472  4879 0000 2114          pea       @m68kde~2_26.L
00001476  40E8      
00001478  4E92      2115          jsr       (A2)
0000147A  584F      2116          addq.w    #4,A7
                    2117   ; for(i = flash_address; i < flash_address + size; i++){
0000147C  2404      2118          move.l    D4,D2
                    2119   ProgramFlashChip_1:
0000147E  2004      2120          move.l    D4,D0
00001480  D086      2121          add.l     D6,D0
00001482  B480      2122          cmp.l     D0,D2
00001484  6C00 0040 2123          bge       ProgramFlashChip_3
                    2124   ; read_data = ReadSPIFlashByte(i);
00001488  2F02      2125          move.l    D2,-(A7)
0000148A  4EB8 1224 2126          jsr       _ReadSPIFlashByte
0000148E  584F      2127          addq.w    #4,A7
00001490  2A00      2128          move.l    D0,D5
                    2129   ; //printf("\r\nRead Data: %02x", read_data);
                    2130   ; if(read_data != *(mem_pointer)){
00001492  2043      2131          move.l    D3,A0
00001494  1010      2132          move.b    (A0),D0
00001496  C0BC 0000 2133          and.l     #255,D0
0000149A  00FF      
0000149C  BA80      2134          cmp.l     D0,D5
0000149E  6720      2135          beq.s     ProgramFlashChip_4
                    2136   ; printf("\r\nError: Data mismatch at location %08x. Expected data = %02x; Actual Data %02x", i, *(mem_pointer), read_data);
000014A0  2F05      2137          move.l    D5,-(A7)
000014A2  2043      2138          move.l    D3,A0
000014A4  1210      2139          move.b    (A0),D1
000014A6  C2BC 0000 2140          and.l     #255,D1
000014AA  00FF      
000014AC  2F01      2141          move.l    D1,-(A7)
000014AE  2F02      2142          move.l    D2,-(A7)
000014B0  4879 0000 2143          pea       @m68kde~2_27.L
000014B4  4102      
000014B6  4E92      2144          jsr       (A2)
000014B8  DEFC 0010 2145          add.w     #16,A7
                    2146   ; success = 0;
000014BC  7E00      2147          moveq     #0,D7
                    2148   ; break;
000014BE  6006      2149          bra.s     ProgramFlashChip_3
                    2150   ProgramFlashChip_4:
                    2151   ; }
                    2152   ; mem_pointer += 1;
000014C0  5283      2153          addq.l    #1,D3
000014C2  5282      2154          addq.l    #1,D2
000014C4  60B8      2155          bra       ProgramFlashChip_1
                    2156   ProgramFlashChip_3:
                    2157   ; }
                    2158   ; if(success){
000014C6  4A87      2159          tst.l     D7
000014C8  670A      2160          beq.s     ProgramFlashChip_6
                    2161   ; printf("\r\n********Writing Completed********");
000014CA  4879 0000 2162          pea       @m68kde~2_28.L
000014CE  4152      
000014D0  4E92      2163          jsr       (A2)
000014D2  584F      2164          addq.w    #4,A7
                    2165   ProgramFlashChip_6:
000014D4  4CDF 04FC 2166          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000014D8  4E75      2167          rts
                    2168   ; }
                    2169   ; }
                    2170   ; /*************************************************************************
                    2171   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2172   ; **************************************************************************/
                    2173   ; void LoadFromFlashChip(void)
                    2174   ; {
                    2175   _LoadFromFlashChip:
000014DA  4E56 FFF0 2176          link      A6,#-16
                    2177   ; unsigned char* mem_pointer;
                    2178   ; int flash_address;
                    2179   ; int size;
                    2180   ; int i;
                    2181   ; mem_pointer = 0x08000000; // destination
000014DE  2D7C 0800 2182          move.l    #134217728,-16(A6)
000014E2  0000 FFF0 
                    2183   ; flash_address = 0x00000000; // source
000014E6  42AE FFF4 2184          clr.l     -12(A6)
                    2185   ; size = 262144;
000014EA  2D7C 0004 2186          move.l    #262144,-8(A6)
000014EE  0000 FFF8 
                    2187   ; //printf("\r\nEnter the size of data to write to RAM: ");
                    2188   ; //size = Get6HexDigits(0);
                    2189   ; printf("\r\nLoading Program From Flash....") ;
000014F2  4879 0000 2190          pea       @m68kde~2_29.L
000014F6  4176      
000014F8  4EB9 0000 2191          jsr       _printf
000014FC  3532      
000014FE  584F      2192          addq.w    #4,A7
                    2193   ; //
                    2194   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    2195   ; //
                    2196   ; ReadSPIFlashData(flash_address, mem_pointer, size);
00001500  2F2E FFF8 2197          move.l    -8(A6),-(A7)
00001504  2F2E FFF0 2198          move.l    -16(A6),-(A7)
00001508  2F2E FFF4 2199          move.l    -12(A6),-(A7)
0000150C  4EB8 1294 2200          jsr       _ReadSPIFlashData
00001510  DEFC 000C 2201          add.w     #12,A7
                    2202   ; printf("\r\n********Program loaded to RAM********") ;
00001514  4879 0000 2203          pea       @m68kde~2_30.L
00001518  4198      
0000151A  4EB9 0000 2204          jsr       _printf
0000151E  3532      
00001520  584F      2205          addq.w    #4,A7
00001522  4E5E      2206          unlk      A6
00001524  4E75      2207          rts
                    2208   ; }
                    2209   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2210   ; // IMPORTANT
                    2211   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2212   ; // has to be done with an interrupt (IRQ Level 6)
                    2213   ; //
                    2214   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2215   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2216   ; //
                    2217   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2218   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2219   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2220   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2221   ; // program area
                    2222   ; //
                    2223   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2224   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2225   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2226   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2227   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2228   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2229   ; void DumpRegisters()
                    2230   ; {
                    2231   _DumpRegisters:
00001526  48E7 3F3C 2232          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000152A  45F9 0000 2233          lea       _putch.L,A2
0000152E  344E      
00001530  47F9 0000 2234          lea       _printf.L,A3
00001534  3532      
00001536  49F9 0B00 2235          lea       _SR.L,A4
0000153A  012C      
0000153C  4BF9 0B00 2236          lea       _WatchPointString.L,A5
00001540  01C2      
                    2237   ; short i, x, j, k ;
                    2238   ; unsigned char c, *BytePointer;
                    2239   ; // buld up strings for displaying watchpoints
                    2240   ; for(x = 0; x < (short)(8); x++)
00001542  4242      2241          clr.w     D2
                    2242   DumpRegisters_1:
00001544  0C42 0008 2243          cmp.w     #8,D2
00001548  6C00 01C6 2244          bge       DumpRegisters_3
                    2245   ; {
                    2246   ; if(WatchPointSetOrCleared[x] == 1)
0000154C  48C2      2247          ext.l     D2
0000154E  2002      2248          move.l    D2,D0
00001550  E588      2249          lsl.l     #2,D0
00001552  41F9 0B00 2250          lea       _WatchPointSetOrCleared.L,A0
00001556  01A2      
00001558  2030 0800 2251          move.l    0(A0,D0.L),D0
0000155C  0C80 0000 2252          cmp.l     #1,D0
00001560  0001      
00001562  6600 0186 2253          bne       DumpRegisters_4
                    2254   ; {
                    2255   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
00001566  48C2      2256          ext.l     D2
00001568  2202      2257          move.l    D2,D1
0000156A  E589      2258          lsl.l     #2,D1
0000156C  41F9 0B00 2259          lea       _WatchPointAddress.L,A0
00001570  0182      
00001572  2F30 1800 2260          move.l    0(A0,D1.L),-(A7)
00001576  4879 0000 2261          pea       @m68kde~2_31.L
0000157A  41C0      
0000157C  220D      2262          move.l    A5,D1
0000157E  48C2      2263          ext.l     D2
00001580  2F00      2264          move.l    D0,-(A7)
00001582  2002      2265          move.l    D2,D0
00001584  C1FC 0064 2266          muls      #100,D0
00001588  D280      2267          add.l     D0,D1
0000158A  201F      2268          move.l    (A7)+,D0
0000158C  2F01      2269          move.l    D1,-(A7)
0000158E  4EB9 0000 2270          jsr       _sprintf
00001592  34CE      
00001594  DEFC 000C 2271          add.w     #12,A7
                    2272   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00001598  48C2      2273          ext.l     D2
0000159A  2002      2274          move.l    D2,D0
0000159C  E588      2275          lsl.l     #2,D0
0000159E  41F9 0B00 2276          lea       _WatchPointAddress.L,A0
000015A2  0182      
000015A4  2A30 0800 2277          move.l    0(A0,D0.L),D5
                    2278   ; for(j = 0; j < (short)(16); j+=2)
000015A8  4243      2279          clr.w     D3
                    2280   DumpRegisters_6:
000015AA  0C43 0010 2281          cmp.w     #16,D3
000015AE  6C00 0082 2282          bge       DumpRegisters_8
                    2283   ; {
                    2284   ; for(k = 0; k < (short)(2); k++)
000015B2  4246      2285          clr.w     D6
                    2286   DumpRegisters_9:
000015B4  0C46 0002 2287          cmp.w     #2,D6
000015B8  6C00 0052 2288          bge       DumpRegisters_11
                    2289   ; {
                    2290   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000015BC  2045      2291          move.l    D5,A0
000015BE  48C3      2292          ext.l     D3
000015C0  2203      2293          move.l    D3,D1
000015C2  48C6      2294          ext.l     D6
000015C4  D286      2295          add.l     D6,D1
000015C6  1230 1800 2296          move.b    0(A0,D1.L),D1
000015CA  C2BC 0000 2297          and.l     #255,D1
000015CE  00FF      
000015D0  2F01      2298          move.l    D1,-(A7)
000015D2  4879 0000 2299          pea       @m68kde~2_8.L
000015D6  3EBC      
000015D8  4879 0B00 2300          pea       _TempString.L
000015DC  04E2      
000015DE  4EB9 0000 2301          jsr       _sprintf
000015E2  34CE      
000015E4  DEFC 000C 2302          add.w     #12,A7
                    2303   ; strcat(WatchPointString[x], TempString) ;
000015E8  4879 0B00 2304          pea       _TempString.L
000015EC  04E2      
000015EE  220D      2305          move.l    A5,D1
000015F0  48C2      2306          ext.l     D2
000015F2  2F00      2307          move.l    D0,-(A7)
000015F4  2002      2308          move.l    D2,D0
000015F6  C1FC 0064 2309          muls      #100,D0
000015FA  D280      2310          add.l     D0,D1
000015FC  201F      2311          move.l    (A7)+,D0
000015FE  2F01      2312          move.l    D1,-(A7)
00001600  4EB9 0000 2313          jsr       _strcat
00001604  3500      
00001606  504F      2314          addq.w    #8,A7
00001608  5246      2315          addq.w    #1,D6
0000160A  60A8      2316          bra       DumpRegisters_9
                    2317   DumpRegisters_11:
                    2318   ; }
                    2319   ; strcat(WatchPointString[x]," ") ;
0000160C  4879 0000 2320          pea       @m68kde~2_32.L
00001610  41C8      
00001612  220D      2321          move.l    A5,D1
00001614  48C2      2322          ext.l     D2
00001616  2F00      2323          move.l    D0,-(A7)
00001618  2002      2324          move.l    D2,D0
0000161A  C1FC 0064 2325          muls      #100,D0
0000161E  D280      2326          add.l     D0,D1
00001620  201F      2327          move.l    (A7)+,D0
00001622  2F01      2328          move.l    D1,-(A7)
00001624  4EB9 0000 2329          jsr       _strcat
00001628  3500      
0000162A  504F      2330          addq.w    #8,A7
0000162C  5443      2331          addq.w    #2,D3
0000162E  6000 FF7A 2332          bra       DumpRegisters_6
                    2333   DumpRegisters_8:
                    2334   ; }
                    2335   ; strcat(WatchPointString[x], "  ") ;
00001632  4879 0000 2336          pea       @m68kde~2_9.L
00001636  3EC2      
00001638  220D      2337          move.l    A5,D1
0000163A  48C2      2338          ext.l     D2
0000163C  2F00      2339          move.l    D0,-(A7)
0000163E  2002      2340          move.l    D2,D0
00001640  C1FC 0064 2341          muls      #100,D0
00001644  D280      2342          add.l     D0,D1
00001646  201F      2343          move.l    (A7)+,D0
00001648  2F01      2344          move.l    D1,-(A7)
0000164A  4EB9 0000 2345          jsr       _strcat
0000164E  3500      
00001650  504F      2346          addq.w    #8,A7
                    2347   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00001652  48C2      2348          ext.l     D2
00001654  2002      2349          move.l    D2,D0
00001656  E588      2350          lsl.l     #2,D0
00001658  41F9 0B00 2351          lea       _WatchPointAddress.L,A0
0000165C  0182      
0000165E  2A30 0800 2352          move.l    0(A0,D0.L),D5
                    2353   ; for(j = 0; j < (short)(16); j++)
00001662  4243      2354          clr.w     D3
                    2355   DumpRegisters_12:
00001664  0C43 0010 2356          cmp.w     #16,D3
00001668  6C00 007E 2357          bge       DumpRegisters_14
                    2358   ; {
                    2359   ; c = ((char)(BytePointer[j]) & 0x7f) ;
0000166C  2045      2360          move.l    D5,A0
0000166E  48C3      2361          ext.l     D3
00001670  1030 3800 2362          move.b    0(A0,D3.L),D0
00001674  C03C 007F 2363          and.b     #127,D0
00001678  1E00      2364          move.b    D0,D7
                    2365   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
0000167A  0C07 007F 2366          cmp.b     #127,D7
0000167E  6206      2367          bhi.s     DumpRegisters_17
00001680  0C07 0020 2368          cmp.b     #32,D7
00001684  6416      2369          bhs.s     DumpRegisters_15
                    2370   DumpRegisters_17:
                    2371   ; sprintf(TempString, ".") ;
00001686  4879 0000 2372          pea       @m68kde~2_33.L
0000168A  41CA      
0000168C  4879 0B00 2373          pea       _TempString.L
00001690  04E2      
00001692  4EB9 0000 2374          jsr       _sprintf
00001696  34CE      
00001698  504F      2375          addq.w    #8,A7
0000169A  6026      2376          bra.s     DumpRegisters_16
                    2377   DumpRegisters_15:
                    2378   ; else
                    2379   ; sprintf(TempString, "%c", BytePointer[j]) ;
0000169C  2045      2380          move.l    D5,A0
0000169E  48C3      2381          ext.l     D3
000016A0  1230 3800 2382          move.b    0(A0,D3.L),D1
000016A4  C2BC 0000 2383          and.l     #255,D1
000016A8  00FF      
000016AA  2F01      2384          move.l    D1,-(A7)
000016AC  4879 0000 2385          pea       @m68kde~2_34.L
000016B0  41CC      
000016B2  4879 0B00 2386          pea       _TempString.L
000016B6  04E2      
000016B8  4EB9 0000 2387          jsr       _sprintf
000016BC  34CE      
000016BE  DEFC 000C 2388          add.w     #12,A7
                    2389   DumpRegisters_16:
                    2390   ; strcat(WatchPointString[x], TempString) ;
000016C2  4879 0B00 2391          pea       _TempString.L
000016C6  04E2      
000016C8  220D      2392          move.l    A5,D1
000016CA  48C2      2393          ext.l     D2
000016CC  2F00      2394          move.l    D0,-(A7)
000016CE  2002      2395          move.l    D2,D0
000016D0  C1FC 0064 2396          muls      #100,D0
000016D4  D280      2397          add.l     D0,D1
000016D6  201F      2398          move.l    (A7)+,D0
000016D8  2F01      2399          move.l    D1,-(A7)
000016DA  4EB9 0000 2400          jsr       _strcat
000016DE  3500      
000016E0  504F      2401          addq.w    #8,A7
000016E2  5243      2402          addq.w    #1,D3
000016E4  6000 FF7E 2403          bra       DumpRegisters_12
                    2404   DumpRegisters_14:
000016E8  6020      2405          bra.s     DumpRegisters_5
                    2406   DumpRegisters_4:
                    2407   ; }
                    2408   ; }
                    2409   ; else
                    2410   ; strcpy(WatchPointString[x], "") ;
000016EA  4879 0000 2411          pea       @m68kde~2_35.L
000016EE  41D0      
000016F0  220D      2412          move.l    A5,D1
000016F2  48C2      2413          ext.l     D2
000016F4  2F00      2414          move.l    D0,-(A7)
000016F6  2002      2415          move.l    D2,D0
000016F8  C1FC 0064 2416          muls      #100,D0
000016FC  D280      2417          add.l     D0,D1
000016FE  201F      2418          move.l    (A7)+,D0
00001700  2F01      2419          move.l    D1,-(A7)
00001702  4EB9 0000 2420          jsr       _strcpy
00001706  3360      
00001708  504F      2421          addq.w    #8,A7
                    2422   DumpRegisters_5:
0000170A  5242      2423          addq.w    #1,D2
0000170C  6000 FE36 2424          bra       DumpRegisters_1
                    2425   DumpRegisters_3:
                    2426   ; }
                    2427   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
00001710  2F39 0B00 2428          move.l    _a0.L,-(A7)
00001714  0104      
00001716  2F39 0B00 2429          move.l    _d0.L,-(A7)
0000171A  00E4      
0000171C  4879 0000 2430          pea       @m68kde~2_36.L
00001720  41D2      
00001722  4E93      2431          jsr       (A3)
00001724  DEFC 000C 2432          add.w     #12,A7
                    2433   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
00001728  2F39 0B00 2434          move.l    _a1.L,-(A7)
0000172C  0108      
0000172E  2F39 0B00 2435          move.l    _d1.L,-(A7)
00001732  00E8      
00001734  4879 0000 2436          pea       @m68kde~2_37.L
00001738  41EE      
0000173A  4E93      2437          jsr       (A3)
0000173C  DEFC 000C 2438          add.w     #12,A7
                    2439   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
00001740  2F39 0B00 2440          move.l    _a2.L,-(A7)
00001744  010C      
00001746  2F39 0B00 2441          move.l    _d2.L,-(A7)
0000174A  00EC      
0000174C  4879 0000 2442          pea       @m68kde~2_38.L
00001750  4208      
00001752  4E93      2443          jsr       (A3)
00001754  DEFC 000C 2444          add.w     #12,A7
                    2445   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
00001758  2F39 0B00 2446          move.l    _a3.L,-(A7)
0000175C  0110      
0000175E  2F39 0B00 2447          move.l    _d3.L,-(A7)
00001762  00F0      
00001764  4879 0000 2448          pea       @m68kde~2_39.L
00001768  4222      
0000176A  4E93      2449          jsr       (A3)
0000176C  DEFC 000C 2450          add.w     #12,A7
                    2451   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
00001770  2F39 0B00 2452          move.l    _a4.L,-(A7)
00001774  0114      
00001776  2F39 0B00 2453          move.l    _d4.L,-(A7)
0000177A  00F4      
0000177C  4879 0000 2454          pea       @m68kde~2_40.L
00001780  423C      
00001782  4E93      2455          jsr       (A3)
00001784  DEFC 000C 2456          add.w     #12,A7
                    2457   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
00001788  2F39 0B00 2458          move.l    _a5.L,-(A7)
0000178C  0118      
0000178E  2F39 0B00 2459          move.l    _d5.L,-(A7)
00001792  00F8      
00001794  4879 0000 2460          pea       @m68kde~2_41.L
00001798  4256      
0000179A  4E93      2461          jsr       (A3)
0000179C  DEFC 000C 2462          add.w     #12,A7
                    2463   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000017A0  2F39 0B00 2464          move.l    _a6.L,-(A7)
000017A4  011C      
000017A6  2F39 0B00 2465          move.l    _d6.L,-(A7)
000017AA  00FC      
000017AC  4879 0000 2466          pea       @m68kde~2_42.L
000017B0  4270      
000017B2  4E93      2467          jsr       (A3)
000017B4  DEFC 000C 2468          add.w     #12,A7
                    2469   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000017B8  3214      2470          move.w    (A4),D1
000017BA  C27C 2000 2471          and.w     #8192,D1
000017BE  0C41 2000 2472          cmp.w     #8192,D1
000017C2  6608      2473          bne.s     DumpRegisters_18
000017C4  2239 0B00 2474          move.l    _SSP.L,D1
000017C8  0124      
000017CA  6006      2475          bra.s     DumpRegisters_19
                    2476   DumpRegisters_18:
000017CC  2239 0B00 2477          move.l    _USP.L,D1
000017D0  0128      
                    2478   DumpRegisters_19:
000017D2  2F01      2479          move.l    D1,-(A7)
000017D4  2F39 0B00 2480          move.l    _d7.L,-(A7)
000017D8  0100      
000017DA  4879 0000 2481          pea       @m68kde~2_43.L
000017DE  428A      
000017E0  4E93      2482          jsr       (A3)
000017E2  DEFC 000C 2483          add.w     #12,A7
                    2484   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
000017E6  2F39 0B00 2485          move.l    _USP.L,-(A7)
000017EA  0128      
000017EC  4879 0000 2486          pea       @m68kde~2_44.L
000017F0  42A4      
000017F2  4E93      2487          jsr       (A3)
000017F4  504F      2488          addq.w    #8,A7
                    2489   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
000017F6  2F39 0B00 2490          move.l    _SSP.L,-(A7)
000017FA  0124      
000017FC  4879 0000 2491          pea       @m68kde~2_45.L
00001800  42C2      
00001802  4E93      2492          jsr       (A3)
00001804  504F      2493          addq.w    #8,A7
                    2494   ; printf("\r\n SR = $%04X   ",SR) ;
00001806  3214      2495          move.w    (A4),D1
00001808  C2BC 0000 2496          and.l     #65535,D1
0000180C  FFFF      
0000180E  2F01      2497          move.l    D1,-(A7)
00001810  4879 0000 2498          pea       @m68kde~2_46.L
00001814  42E4      
00001816  4E93      2499          jsr       (A3)
00001818  504F      2500          addq.w    #8,A7
                    2501   ; // display the status word in characters etc.
                    2502   ; printf("   [") ;
0000181A  4879 0000 2503          pea       @m68kde~2_47.L
0000181E  42F6      
00001820  4E93      2504          jsr       (A3)
00001822  584F      2505          addq.w    #4,A7
                    2506   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
00001824  3014      2507          move.w    (A4),D0
00001826  C07C 8000 2508          and.w     #32768,D0
0000182A  0C40 8000 2509          cmp.w     #32768,D0
0000182E  660A      2510          bne.s     DumpRegisters_20
00001830  4878 0054 2511          pea       84
00001834  4E92      2512          jsr       (A2)
00001836  584F      2513          addq.w    #4,A7
00001838  6008      2514          bra.s     DumpRegisters_21
                    2515   DumpRegisters_20:
0000183A  4878 002D 2516          pea       45
0000183E  4E92      2517          jsr       (A2)
00001840  584F      2518          addq.w    #4,A7
                    2519   DumpRegisters_21:
                    2520   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
00001842  3014      2521          move.w    (A4),D0
00001844  C07C 2000 2522          and.w     #8192,D0
00001848  0C40 2000 2523          cmp.w     #8192,D0
0000184C  660A      2524          bne.s     DumpRegisters_22
0000184E  4878 0053 2525          pea       83
00001852  4E92      2526          jsr       (A2)
00001854  584F      2527          addq.w    #4,A7
00001856  6008      2528          bra.s     DumpRegisters_23
                    2529   DumpRegisters_22:
00001858  4878 0055 2530          pea       85
0000185C  4E92      2531          jsr       (A2)
0000185E  584F      2532          addq.w    #4,A7
                    2533   DumpRegisters_23:
                    2534   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
00001860  3014      2535          move.w    (A4),D0
00001862  C07C 0400 2536          and.w     #1024,D0
00001866  0C40 0400 2537          cmp.w     #1024,D0
0000186A  660A      2538          bne.s     DumpRegisters_24
0000186C  4878 0031 2539          pea       49
00001870  4E92      2540          jsr       (A2)
00001872  584F      2541          addq.w    #4,A7
00001874  6008      2542          bra.s     DumpRegisters_25
                    2543   DumpRegisters_24:
00001876  4878 0030 2544          pea       48
0000187A  4E92      2545          jsr       (A2)
0000187C  584F      2546          addq.w    #4,A7
                    2547   DumpRegisters_25:
                    2548   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
0000187E  3014      2549          move.w    (A4),D0
00001880  C07C 0200 2550          and.w     #512,D0
00001884  0C40 0200 2551          cmp.w     #512,D0
00001888  660A      2552          bne.s     DumpRegisters_26
0000188A  4878 0031 2553          pea       49
0000188E  4E92      2554          jsr       (A2)
00001890  584F      2555          addq.w    #4,A7
00001892  6008      2556          bra.s     DumpRegisters_27
                    2557   DumpRegisters_26:
00001894  4878 0030 2558          pea       48
00001898  4E92      2559          jsr       (A2)
0000189A  584F      2560          addq.w    #4,A7
                    2561   DumpRegisters_27:
                    2562   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
0000189C  3014      2563          move.w    (A4),D0
0000189E  C07C 0100 2564          and.w     #256,D0
000018A2  0C40 0100 2565          cmp.w     #256,D0
000018A6  660A      2566          bne.s     DumpRegisters_28
000018A8  4878 0031 2567          pea       49
000018AC  4E92      2568          jsr       (A2)
000018AE  584F      2569          addq.w    #4,A7
000018B0  6008      2570          bra.s     DumpRegisters_29
                    2571   DumpRegisters_28:
000018B2  4878 0030 2572          pea       48
000018B6  4E92      2573          jsr       (A2)
000018B8  584F      2574          addq.w    #4,A7
                    2575   DumpRegisters_29:
                    2576   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000018BA  3014      2577          move.w    (A4),D0
000018BC  C07C 0010 2578          and.w     #16,D0
000018C0  0C40 0010 2579          cmp.w     #16,D0
000018C4  660A      2580          bne.s     DumpRegisters_30
000018C6  4878 0058 2581          pea       88
000018CA  4E92      2582          jsr       (A2)
000018CC  584F      2583          addq.w    #4,A7
000018CE  6008      2584          bra.s     DumpRegisters_31
                    2585   DumpRegisters_30:
000018D0  4878 002D 2586          pea       45
000018D4  4E92      2587          jsr       (A2)
000018D6  584F      2588          addq.w    #4,A7
                    2589   DumpRegisters_31:
                    2590   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
000018D8  3014      2591          move.w    (A4),D0
000018DA  C07C 0008 2592          and.w     #8,D0
000018DE  0C40 0008 2593          cmp.w     #8,D0
000018E2  660A      2594          bne.s     DumpRegisters_32
000018E4  4878 004E 2595          pea       78
000018E8  4E92      2596          jsr       (A2)
000018EA  584F      2597          addq.w    #4,A7
000018EC  6008      2598          bra.s     DumpRegisters_33
                    2599   DumpRegisters_32:
000018EE  4878 002D 2600          pea       45
000018F2  4E92      2601          jsr       (A2)
000018F4  584F      2602          addq.w    #4,A7
                    2603   DumpRegisters_33:
                    2604   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
000018F6  3014      2605          move.w    (A4),D0
000018F8  C07C 0004 2606          and.w     #4,D0
000018FC  0C40 0004 2607          cmp.w     #4,D0
00001900  660A      2608          bne.s     DumpRegisters_34
00001902  4878 005A 2609          pea       90
00001906  4E92      2610          jsr       (A2)
00001908  584F      2611          addq.w    #4,A7
0000190A  6008      2612          bra.s     DumpRegisters_35
                    2613   DumpRegisters_34:
0000190C  4878 002D 2614          pea       45
00001910  4E92      2615          jsr       (A2)
00001912  584F      2616          addq.w    #4,A7
                    2617   DumpRegisters_35:
                    2618   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
00001914  3014      2619          move.w    (A4),D0
00001916  C07C 0002 2620          and.w     #2,D0
0000191A  0C40 0002 2621          cmp.w     #2,D0
0000191E  660A      2622          bne.s     DumpRegisters_36
00001920  4878 0056 2623          pea       86
00001924  4E92      2624          jsr       (A2)
00001926  584F      2625          addq.w    #4,A7
00001928  6008      2626          bra.s     DumpRegisters_37
                    2627   DumpRegisters_36:
0000192A  4878 002D 2628          pea       45
0000192E  4E92      2629          jsr       (A2)
00001930  584F      2630          addq.w    #4,A7
                    2631   DumpRegisters_37:
                    2632   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
00001932  3014      2633          move.w    (A4),D0
00001934  C07C 0001 2634          and.w     #1,D0
00001938  0C40 0001 2635          cmp.w     #1,D0
0000193C  660A      2636          bne.s     DumpRegisters_38
0000193E  4878 0043 2637          pea       67
00001942  4E92      2638          jsr       (A2)
00001944  584F      2639          addq.w    #4,A7
00001946  6008      2640          bra.s     DumpRegisters_39
                    2641   DumpRegisters_38:
00001948  4878 002D 2642          pea       45
0000194C  4E92      2643          jsr       (A2)
0000194E  584F      2644          addq.w    #4,A7
                    2645   DumpRegisters_39:
                    2646   ; putchar(']') ;
00001950  4878 005D 2647          pea       93
00001954  4E92      2648          jsr       (A2)
00001956  584F      2649          addq.w    #4,A7
                    2650   ; printf("\r\n PC = $%08X  ", PC) ;
00001958  2F39 0B00 2651          move.l    _PC.L,-(A7)
0000195C  0120      
0000195E  4879 0000 2652          pea       @m68kde~2_48.L
00001962  42FC      
00001964  4E93      2653          jsr       (A3)
00001966  504F      2654          addq.w    #8,A7
                    2655   ; if(*(unsigned short int *)(PC) == 0x4e4e)
00001968  2039 0B00 2656          move.l    _PC.L,D0
0000196C  0120      
0000196E  2040      2657          move.l    D0,A0
00001970  3010      2658          move.w    (A0),D0
00001972  0C40 4E4E 2659          cmp.w     #20046,D0
00001976  660A      2660          bne.s     DumpRegisters_40
                    2661   ; printf("[@ BREAKPOINT]") ;
00001978  4879 0000 2662          pea       @m68kde~2_49.L
0000197C  430C      
0000197E  4E93      2663          jsr       (A3)
00001980  584F      2664          addq.w    #4,A7
                    2665   DumpRegisters_40:
                    2666   ; printf("\r\n") ;
00001982  4879 0000 2667          pea       @m68kde~2_1.L
00001986  3E44      
00001988  4E93      2668          jsr       (A3)
0000198A  584F      2669          addq.w    #4,A7
                    2670   ; for(i=0; i < 8; i++)    {
0000198C  4244      2671          clr.w     D4
                    2672   DumpRegisters_42:
0000198E  0C44 0008 2673          cmp.w     #8,D4
00001992  6C00 0040 2674          bge       DumpRegisters_44
                    2675   ; if(WatchPointSetOrCleared[i] == 1)
00001996  48C4      2676          ext.l     D4
00001998  2004      2677          move.l    D4,D0
0000199A  E588      2678          lsl.l     #2,D0
0000199C  41F9 0B00 2679          lea       _WatchPointSetOrCleared.L,A0
000019A0  01A2      
000019A2  2030 0800 2680          move.l    0(A0,D0.L),D0
000019A6  0C80 0000 2681          cmp.l     #1,D0
000019AA  0001      
000019AC  6622      2682          bne.s     DumpRegisters_45
                    2683   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000019AE  220D      2684          move.l    A5,D1
000019B0  48C4      2685          ext.l     D4
000019B2  2F00      2686          move.l    D0,-(A7)
000019B4  2004      2687          move.l    D4,D0
000019B6  C1FC 0064 2688          muls      #100,D0
000019BA  D280      2689          add.l     D0,D1
000019BC  201F      2690          move.l    (A7)+,D0
000019BE  2F01      2691          move.l    D1,-(A7)
000019C0  48C4      2692          ext.l     D4
000019C2  2F04      2693          move.l    D4,-(A7)
000019C4  4879 0000 2694          pea       @m68kde~2_50.L
000019C8  431C      
000019CA  4E93      2695          jsr       (A3)
000019CC  DEFC 000C 2696          add.w     #12,A7
                    2697   DumpRegisters_45:
000019D0  5244      2698          addq.w    #1,D4
000019D2  60BA      2699          bra       DumpRegisters_42
                    2700   DumpRegisters_44:
000019D4  4CDF 3CFC 2701          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000019D8  4E75      2702          rts
                    2703   ; }
                    2704   ; }
                    2705   ; // Trace Exception Handler
                    2706   ; void DumpRegistersandPause(void)
                    2707   ; {
                    2708   _DumpRegistersandPause:
000019DA  2F0A      2709          move.l    A2,-(A7)
000019DC  45F9 0000 2710          lea       _printf.L,A2
000019E0  3532      
                    2711   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
000019E2  4879 0000 2712          pea       @m68kde~2_51.L
000019E6  4328      
000019E8  4E92      2713          jsr       (A2)
000019EA  584F      2714          addq.w    #4,A7
                    2715   ; printf("\r\nBreak Points :[Disabled]") ;
000019EC  4879 0000 2716          pea       @m68kde~2_52.L
000019F0  4348      
000019F2  4E92      2717          jsr       (A2)
000019F4  584F      2718          addq.w    #4,A7
                    2719   ; DumpRegisters() ;
000019F6  4EB8 1526 2720          jsr       _DumpRegisters
                    2721   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
000019FA  4879 0000 2722          pea       @m68kde~2_53.L
000019FE  4364      
00001A00  4E92      2723          jsr       (A2)
00001A02  584F      2724          addq.w    #4,A7
                    2725   ; printf("\r\nPress <ESC> to Resume Program") ;
00001A04  4879 0000 2726          pea       @m68kde~2_54.L
00001A08  4390      
00001A0A  4E92      2727          jsr       (A2)
00001A0C  584F      2728          addq.w    #4,A7
                    2729   ; menu() ;
00001A0E  4EB9 0000 2730          jsr       _menu
00001A12  25BE      
00001A14  245F      2731          move.l    (A7)+,A2
00001A16  4E75      2732          rts
                    2733   ; }
                    2734   ; void ChangeRegisters(void)
                    2735   ; {
                    2736   _ChangeRegisters:
00001A18  4E56 FFFC 2737          link      A6,#-4
00001A1C  48E7 303C 2738          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00001A20  45F9 0000 2739          lea       _printf.L,A2
00001A24  3532      
00001A26  47EE FFFC 2740          lea       -4(A6),A3
00001A2A  49F8 0CA4 2741          lea       _Get8HexDigits.L,A4
00001A2E  4BF8 0B68 2742          lea       __getch.L,A5
                    2743   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2744   ; int reg_val ;
                    2745   ; char c, reg[3] ;
                    2746   ; reg[0] = tolower(_getch()) ;
00001A32  2F00      2747          move.l    D0,-(A7)
00001A34  4E95      2748          jsr       (A5)
00001A36  2200      2749          move.l    D0,D1
00001A38  201F      2750          move.l    (A7)+,D0
00001A3A  2F01      2751          move.l    D1,-(A7)
00001A3C  4EB9 0000 2752          jsr       _tolower
00001A40  34B2      
00001A42  584F      2753          addq.w    #4,A7
00001A44  1680      2754          move.b    D0,(A3)
                    2755   ; reg[1] = c = tolower(_getch()) ;
00001A46  2F00      2756          move.l    D0,-(A7)
00001A48  4E95      2757          jsr       (A5)
00001A4A  2200      2758          move.l    D0,D1
00001A4C  201F      2759          move.l    (A7)+,D0
00001A4E  2F01      2760          move.l    D1,-(A7)
00001A50  4EB9 0000 2761          jsr       _tolower
00001A54  34B2      
00001A56  584F      2762          addq.w    #4,A7
00001A58  1400      2763          move.b    D0,D2
00001A5A  1740 0001 2764          move.b    D0,1(A3)
                    2765   ; if(reg[0] == (char)('d'))  {    // change data register
00001A5E  1013      2766          move.b    (A3),D0
00001A60  0C00 0064 2767          cmp.b     #100,D0
00001A64  6600 00AE 2768          bne       ChangeRegisters_1
                    2769   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
00001A68  102B 0001 2770          move.b    1(A3),D0
00001A6C  0C00 0037 2771          cmp.b     #55,D0
00001A70  6E0A      2772          bgt.s     ChangeRegisters_5
00001A72  102B 0001 2773          move.b    1(A3),D0
00001A76  0C00 0030 2774          cmp.b     #48,D0
00001A7A  6C0E      2775          bge.s     ChangeRegisters_3
                    2776   ChangeRegisters_5:
                    2777   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
00001A7C  4879 0000 2778          pea       @m68kde~2_55.L
00001A80  43B0      
00001A82  4E92      2779          jsr       (A2)
00001A84  584F      2780          addq.w    #4,A7
                    2781   ; return ;
00001A86  6000 0244 2782          bra       ChangeRegisters_6
                    2783   ChangeRegisters_3:
                    2784   ; }
                    2785   ; else {
                    2786   ; printf("\r\nD%c = ", c) ;
00001A8A  4882      2787          ext.w     D2
00001A8C  48C2      2788          ext.l     D2
00001A8E  2F02      2789          move.l    D2,-(A7)
00001A90  4879 0000 2790          pea       @m68kde~2_56.L
00001A94  43DC      
00001A96  4E92      2791          jsr       (A2)
00001A98  504F      2792          addq.w    #8,A7
                    2793   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001A9A  42A7      2794          clr.l     -(A7)
00001A9C  4E94      2795          jsr       (A4)
00001A9E  584F      2796          addq.w    #4,A7
00001AA0  2600      2797          move.l    D0,D3
                    2798   ; }
                    2799   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2800   ; if(c == (char)('0'))
00001AA2  0C02 0030 2801          cmp.b     #48,D2
00001AA6  660A      2802          bne.s     ChangeRegisters_7
                    2803   ; d0 = reg_val ;
00001AA8  23C3 0B00 2804          move.l    D3,_d0.L
00001AAC  00E4      
00001AAE  6000 0060 2805          bra       ChangeRegisters_20
                    2806   ChangeRegisters_7:
                    2807   ; else if(c == (char)('1'))
00001AB2  0C02 0031 2808          cmp.b     #49,D2
00001AB6  660A      2809          bne.s     ChangeRegisters_9
                    2810   ; d1 = reg_val ;
00001AB8  23C3 0B00 2811          move.l    D3,_d1.L
00001ABC  00E8      
00001ABE  6000 0050 2812          bra       ChangeRegisters_20
                    2813   ChangeRegisters_9:
                    2814   ; else if(c == (char)('2'))
00001AC2  0C02 0032 2815          cmp.b     #50,D2
00001AC6  660A      2816          bne.s     ChangeRegisters_11
                    2817   ; d2 = reg_val ;
00001AC8  23C3 0B00 2818          move.l    D3,_d2.L
00001ACC  00EC      
00001ACE  6000 0040 2819          bra       ChangeRegisters_20
                    2820   ChangeRegisters_11:
                    2821   ; else if(c == (char)('3'))
00001AD2  0C02 0033 2822          cmp.b     #51,D2
00001AD6  6608      2823          bne.s     ChangeRegisters_13
                    2824   ; d3 = reg_val ;
00001AD8  23C3 0B00 2825          move.l    D3,_d3.L
00001ADC  00F0      
00001ADE  6030      2826          bra.s     ChangeRegisters_20
                    2827   ChangeRegisters_13:
                    2828   ; else if(c == (char)('4'))
00001AE0  0C02 0034 2829          cmp.b     #52,D2
00001AE4  6608      2830          bne.s     ChangeRegisters_15
                    2831   ; d4 = reg_val ;
00001AE6  23C3 0B00 2832          move.l    D3,_d4.L
00001AEA  00F4      
00001AEC  6022      2833          bra.s     ChangeRegisters_20
                    2834   ChangeRegisters_15:
                    2835   ; else if(c == (char)('5'))
00001AEE  0C02 0035 2836          cmp.b     #53,D2
00001AF2  6608      2837          bne.s     ChangeRegisters_17
                    2838   ; d5 = reg_val ;
00001AF4  23C3 0B00 2839          move.l    D3,_d5.L
00001AF8  00F8      
00001AFA  6014      2840          bra.s     ChangeRegisters_20
                    2841   ChangeRegisters_17:
                    2842   ; else if(c == (char)('6'))
00001AFC  0C02 0036 2843          cmp.b     #54,D2
00001B00  6608      2844          bne.s     ChangeRegisters_19
                    2845   ; d6 = reg_val ;
00001B02  23C3 0B00 2846          move.l    D3,_d6.L
00001B06  00FC      
00001B08  6006      2847          bra.s     ChangeRegisters_20
                    2848   ChangeRegisters_19:
                    2849   ; else
                    2850   ; d7 = reg_val ;
00001B0A  23C3 0B00 2851          move.l    D3,_d7.L
00001B0E  0100      
                    2852   ChangeRegisters_20:
00001B10  6000 01B6 2853          bra       ChangeRegisters_51
                    2854   ChangeRegisters_1:
                    2855   ; }
                    2856   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001B14  1013      2857          move.b    (A3),D0
00001B16  0C00 0061 2858          cmp.b     #97,D0
00001B1A  6600 00A6 2859          bne       ChangeRegisters_21
                    2860   ; if((c > (char)('7')) || (c < (char)('0'))) {
00001B1E  0C02 0037 2861          cmp.b     #55,D2
00001B22  6E06      2862          bgt.s     ChangeRegisters_25
00001B24  0C02 0030 2863          cmp.b     #48,D2
00001B28  6C0E      2864          bge.s     ChangeRegisters_23
                    2865   ChangeRegisters_25:
                    2866   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00001B2A  4879 0000 2867          pea       @m68kde~2_57.L
00001B2E  43E6      
00001B30  4E92      2868          jsr       (A2)
00001B32  584F      2869          addq.w    #4,A7
                    2870   ; return ;
00001B34  6000 0196 2871          bra       ChangeRegisters_6
                    2872   ChangeRegisters_23:
                    2873   ; }
                    2874   ; else {
                    2875   ; printf("\r\nA%c = ", c) ;
00001B38  4882      2876          ext.w     D2
00001B3A  48C2      2877          ext.l     D2
00001B3C  2F02      2878          move.l    D2,-(A7)
00001B3E  4879 0000 2879          pea       @m68kde~2_58.L
00001B42  4414      
00001B44  4E92      2880          jsr       (A2)
00001B46  504F      2881          addq.w    #8,A7
                    2882   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001B48  42A7      2883          clr.l     -(A7)
00001B4A  4E94      2884          jsr       (A4)
00001B4C  584F      2885          addq.w    #4,A7
00001B4E  2600      2886          move.l    D0,D3
                    2887   ; }
                    2888   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2889   ; if(c == (char)('0'))
00001B50  0C02 0030 2890          cmp.b     #48,D2
00001B54  660A      2891          bne.s     ChangeRegisters_26
                    2892   ; a0 = reg_val ;
00001B56  23C3 0B00 2893          move.l    D3,_a0.L
00001B5A  0104      
00001B5C  6000 0060 2894          bra       ChangeRegisters_39
                    2895   ChangeRegisters_26:
                    2896   ; else if(c == (char)('1'))
00001B60  0C02 0031 2897          cmp.b     #49,D2
00001B64  660A      2898          bne.s     ChangeRegisters_28
                    2899   ; a1 = reg_val ;
00001B66  23C3 0B00 2900          move.l    D3,_a1.L
00001B6A  0108      
00001B6C  6000 0050 2901          bra       ChangeRegisters_39
                    2902   ChangeRegisters_28:
                    2903   ; else if(c == (char)('2'))
00001B70  0C02 0032 2904          cmp.b     #50,D2
00001B74  660A      2905          bne.s     ChangeRegisters_30
                    2906   ; a2 = reg_val ;
00001B76  23C3 0B00 2907          move.l    D3,_a2.L
00001B7A  010C      
00001B7C  6000 0040 2908          bra       ChangeRegisters_39
                    2909   ChangeRegisters_30:
                    2910   ; else if(c == (char)('3'))
00001B80  0C02 0033 2911          cmp.b     #51,D2
00001B84  6608      2912          bne.s     ChangeRegisters_32
                    2913   ; a3 = reg_val ;
00001B86  23C3 0B00 2914          move.l    D3,_a3.L
00001B8A  0110      
00001B8C  6030      2915          bra.s     ChangeRegisters_39
                    2916   ChangeRegisters_32:
                    2917   ; else if(c == (char)('4'))
00001B8E  0C02 0034 2918          cmp.b     #52,D2
00001B92  6608      2919          bne.s     ChangeRegisters_34
                    2920   ; a4 = reg_val ;
00001B94  23C3 0B00 2921          move.l    D3,_a4.L
00001B98  0114      
00001B9A  6022      2922          bra.s     ChangeRegisters_39
                    2923   ChangeRegisters_34:
                    2924   ; else if(c == (char)('5'))
00001B9C  0C02 0035 2925          cmp.b     #53,D2
00001BA0  6608      2926          bne.s     ChangeRegisters_36
                    2927   ; a5 = reg_val ;
00001BA2  23C3 0B00 2928          move.l    D3,_a5.L
00001BA6  0118      
00001BA8  6014      2929          bra.s     ChangeRegisters_39
                    2930   ChangeRegisters_36:
                    2931   ; else if(c == (char)('6'))
00001BAA  0C02 0036 2932          cmp.b     #54,D2
00001BAE  6608      2933          bne.s     ChangeRegisters_38
                    2934   ; a6 = reg_val ;
00001BB0  23C3 0B00 2935          move.l    D3,_a6.L
00001BB4  011C      
00001BB6  6006      2936          bra.s     ChangeRegisters_39
                    2937   ChangeRegisters_38:
                    2938   ; else
                    2939   ; USP = reg_val ;
00001BB8  23C3 0B00 2940          move.l    D3,_USP.L
00001BBC  0128      
                    2941   ChangeRegisters_39:
00001BBE  6000 0108 2942          bra       ChangeRegisters_51
                    2943   ChangeRegisters_21:
                    2944   ; }
                    2945   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
00001BC2  1013      2946          move.b    (A3),D0
00001BC4  0C00 0075 2947          cmp.b     #117,D0
00001BC8  6600 004E 2948          bne       ChangeRegisters_40
00001BCC  0C02 0073 2949          cmp.b     #115,D2
00001BD0  6600 0046 2950          bne       ChangeRegisters_40
                    2951   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
00001BD4  2F00      2952          move.l    D0,-(A7)
00001BD6  4E95      2953          jsr       (A5)
00001BD8  2200      2954          move.l    D0,D1
00001BDA  201F      2955          move.l    (A7)+,D0
00001BDC  2F01      2956          move.l    D1,-(A7)
00001BDE  4EB9 0000 2957          jsr       _tolower
00001BE2  34B2      
00001BE4  584F      2958          addq.w    #4,A7
00001BE6  0C80 0000 2959          cmp.l     #112,D0
00001BEA  0070      
00001BEC  6618      2960          bne.s     ChangeRegisters_42
                    2961   ; printf("\r\nUser SP = ") ;
00001BEE  4879 0000 2962          pea       @m68kde~2_59.L
00001BF2  441E      
00001BF4  4E92      2963          jsr       (A2)
00001BF6  584F      2964          addq.w    #4,A7
                    2965   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001BF8  42A7      2966          clr.l     -(A7)
00001BFA  4E94      2967          jsr       (A4)
00001BFC  584F      2968          addq.w    #4,A7
00001BFE  23C0 0B00 2969          move.l    D0,_USP.L
00001C02  0128      
00001C04  600E      2970          bra.s     ChangeRegisters_43
                    2971   ChangeRegisters_42:
                    2972   ; }
                    2973   ; else {
                    2974   ; printf("\r\nIllegal Register....") ;
00001C06  4879 0000 2975          pea       @m68kde~2_60.L
00001C0A  442C      
00001C0C  4E92      2976          jsr       (A2)
00001C0E  584F      2977          addq.w    #4,A7
                    2978   ; return ;
00001C10  6000 00BA 2979          bra       ChangeRegisters_6
                    2980   ChangeRegisters_43:
00001C14  6000 00B2 2981          bra       ChangeRegisters_51
                    2982   ChangeRegisters_40:
                    2983   ; }
                    2984   ; }
                    2985   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00001C18  1013      2986          move.b    (A3),D0
00001C1A  0C00 0073 2987          cmp.b     #115,D0
00001C1E  6600 004E 2988          bne       ChangeRegisters_44
00001C22  0C02 0073 2989          cmp.b     #115,D2
00001C26  6600 0046 2990          bne       ChangeRegisters_44
                    2991   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00001C2A  2F00      2992          move.l    D0,-(A7)
00001C2C  4E95      2993          jsr       (A5)
00001C2E  2200      2994          move.l    D0,D1
00001C30  201F      2995          move.l    (A7)+,D0
00001C32  2F01      2996          move.l    D1,-(A7)
00001C34  4EB9 0000 2997          jsr       _tolower
00001C38  34B2      
00001C3A  584F      2998          addq.w    #4,A7
00001C3C  0C80 0000 2999          cmp.l     #112,D0
00001C40  0070      
00001C42  6618      3000          bne.s     ChangeRegisters_46
                    3001   ; printf("\r\nSystem SP = ") ;
00001C44  4879 0000 3002          pea       @m68kde~2_61.L
00001C48  4444      
00001C4A  4E92      3003          jsr       (A2)
00001C4C  584F      3004          addq.w    #4,A7
                    3005   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001C4E  42A7      3006          clr.l     -(A7)
00001C50  4E94      3007          jsr       (A4)
00001C52  584F      3008          addq.w    #4,A7
00001C54  23C0 0B00 3009          move.l    D0,_SSP.L
00001C58  0124      
00001C5A  600E      3010          bra.s     ChangeRegisters_47
                    3011   ChangeRegisters_46:
                    3012   ; }
                    3013   ; else {
                    3014   ; printf("\r\nIllegal Register....") ;
00001C5C  4879 0000 3015          pea       @m68kde~2_60.L
00001C60  442C      
00001C62  4E92      3016          jsr       (A2)
00001C64  584F      3017          addq.w    #4,A7
                    3018   ; return ;
00001C66  6000 0064 3019          bra       ChangeRegisters_6
                    3020   ChangeRegisters_47:
00001C6A  6000 005C 3021          bra       ChangeRegisters_51
                    3022   ChangeRegisters_44:
                    3023   ; }
                    3024   ; }
                    3025   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00001C6E  1013      3026          move.b    (A3),D0
00001C70  0C00 0070 3027          cmp.b     #112,D0
00001C74  6620      3028          bne.s     ChangeRegisters_48
00001C76  0C02 0063 3029          cmp.b     #99,D2
00001C7A  661A      3030          bne.s     ChangeRegisters_48
                    3031   ; printf("\r\nPC = ") ;
00001C7C  4879 0000 3032          pea       @m68kde~2_62.L
00001C80  4454      
00001C82  4E92      3033          jsr       (A2)
00001C84  584F      3034          addq.w    #4,A7
                    3035   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001C86  42A7      3036          clr.l     -(A7)
00001C88  4E94      3037          jsr       (A4)
00001C8A  584F      3038          addq.w    #4,A7
00001C8C  23C0 0B00 3039          move.l    D0,_PC.L
00001C90  0120      
00001C92  6000 0034 3040          bra       ChangeRegisters_51
                    3041   ChangeRegisters_48:
                    3042   ; }
                    3043   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
00001C96  1013      3044          move.b    (A3),D0
00001C98  0C00 0073 3045          cmp.b     #115,D0
00001C9C  6620      3046          bne.s     ChangeRegisters_50
00001C9E  0C02 0072 3047          cmp.b     #114,D2
00001CA2  661A      3048          bne.s     ChangeRegisters_50
                    3049   ; printf("\r\nSR = ") ;
00001CA4  4879 0000 3050          pea       @m68kde~2_63.L
00001CA8  445C      
00001CAA  4E92      3051          jsr       (A2)
00001CAC  584F      3052          addq.w    #4,A7
                    3053   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
00001CAE  42A7      3054          clr.l     -(A7)
00001CB0  4EB8 0C58 3055          jsr       _Get4HexDigits
00001CB4  584F      3056          addq.w    #4,A7
00001CB6  33C0 0B00 3057          move.w    D0,_SR.L
00001CBA  012C      
00001CBC  600A      3058          bra.s     ChangeRegisters_51
                    3059   ChangeRegisters_50:
                    3060   ; }
                    3061   ; else
                    3062   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
00001CBE  4879 0000 3063          pea       @m68kde~2_64.L
00001CC2  4464      
00001CC4  4E92      3064          jsr       (A2)
00001CC6  584F      3065          addq.w    #4,A7
                    3066   ChangeRegisters_51:
                    3067   ; DumpRegisters() ;
00001CC8  4EB8 1526 3068          jsr       _DumpRegisters
                    3069   ChangeRegisters_6:
00001CCC  4CDF 3C0C 3070          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001CD0  4E5E      3071          unlk      A6
00001CD2  4E75      3072          rts
                    3073   ; }
                    3074   ; void BreakPointDisplay(void)
                    3075   ; {
                    3076   _BreakPointDisplay:
00001CD4  48E7 3030 3077          movem.l   D2/D3/A2/A3,-(A7)
00001CD8  45F9 0000 3078          lea       _printf.L,A2
00001CDC  3532      
00001CDE  47F9 0B00 3079          lea       _BreakPointAddress.L,A3
00001CE2  012E      
                    3080   ; int i, BreakPointsSet = 0 ;
00001CE4  4283      3081          clr.l     D3
                    3082   ; // any break points  set
                    3083   ; for(i = 0; i < 8; i++)  {
00001CE6  4282      3084          clr.l     D2
                    3085   BreakPointDisplay_1:
00001CE8  0C82 0000 3086          cmp.l     #8,D2
00001CEC  0008      
00001CEE  6C1C      3087          bge.s     BreakPointDisplay_3
                    3088   ; if(BreakPointSetOrCleared[i] == 1)
00001CF0  2002      3089          move.l    D2,D0
00001CF2  E588      3090          lsl.l     #2,D0
00001CF4  41F9 0B00 3091          lea       _BreakPointSetOrCleared.L,A0
00001CF8  015E      
00001CFA  2030 0800 3092          move.l    0(A0,D0.L),D0
00001CFE  0C80 0000 3093          cmp.l     #1,D0
00001D02  0001      
00001D04  6602      3094          bne.s     BreakPointDisplay_4
                    3095   ; BreakPointsSet = 1;
00001D06  7601      3096          moveq     #1,D3
                    3097   BreakPointDisplay_4:
00001D08  5282      3098          addq.l    #1,D2
00001D0A  60DC      3099          bra       BreakPointDisplay_1
                    3100   BreakPointDisplay_3:
                    3101   ; }
                    3102   ; if(BreakPointsSet == 1) {
00001D0C  0C83 0000 3103          cmp.l     #1,D3
00001D10  0001      
00001D12  6616      3104          bne.s     BreakPointDisplay_6
                    3105   ; printf("\r\n\r\nNum     Address      Instruction") ;
00001D14  4879 0000 3106          pea       @m68kde~2_65.L
00001D18  44A0      
00001D1A  4E92      3107          jsr       (A2)
00001D1C  584F      3108          addq.w    #4,A7
                    3109   ; printf("\r\n---     ---------    -----------") ;
00001D1E  4879 0000 3110          pea       @m68kde~2_66.L
00001D22  44C6      
00001D24  4E92      3111          jsr       (A2)
00001D26  584F      3112          addq.w    #4,A7
00001D28  600A      3113          bra.s     BreakPointDisplay_7
                    3114   BreakPointDisplay_6:
                    3115   ; }
                    3116   ; else
                    3117   ; printf("\r\nNo BreakPoints Set") ;
00001D2A  4879 0000 3118          pea       @m68kde~2_67.L
00001D2E  44EA      
00001D30  4E92      3119          jsr       (A2)
00001D32  584F      3120          addq.w    #4,A7
                    3121   BreakPointDisplay_7:
                    3122   ; for(i = 0; i < 8; i++)  {
00001D34  4282      3123          clr.l     D2
                    3124   BreakPointDisplay_8:
00001D36  0C82 0000 3125          cmp.l     #8,D2
00001D3A  0008      
00001D3C  6C00 005A 3126          bge       BreakPointDisplay_10
                    3127   ; // put opcode back, then put break point back
                    3128   ; if(BreakPointSetOrCleared[i] == 1)  {
00001D40  2002      3129          move.l    D2,D0
00001D42  E588      3130          lsl.l     #2,D0
00001D44  41F9 0B00 3131          lea       _BreakPointSetOrCleared.L,A0
00001D48  015E      
00001D4A  2030 0800 3132          move.l    0(A0,D0.L),D0
00001D4E  0C80 0000 3133          cmp.l     #1,D0
00001D52  0001      
00001D54  6600 003E 3134          bne       BreakPointDisplay_11
                    3135   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001D58  2002      3136          move.l    D2,D0
00001D5A  E388      3137          lsl.l     #1,D0
00001D5C  41F9 0B00 3138          lea       _BreakPointInstruction.L,A0
00001D60  014E      
00001D62  2202      3139          move.l    D2,D1
00001D64  E589      3140          lsl.l     #2,D1
00001D66  2233 1800 3141          move.l    0(A3,D1.L),D1
00001D6A  2241      3142          move.l    D1,A1
00001D6C  32B0 0800 3143          move.w    0(A0,D0.L),(A1)
                    3144   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00001D70  2002      3145          move.l    D2,D0
00001D72  E588      3146          lsl.l     #2,D0
00001D74  2033 0800 3147          move.l    0(A3,D0.L),D0
00001D78  2040      3148          move.l    D0,A0
00001D7A  30BC 4E4E 3149          move.w    #20046,(A0)
                    3150   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00001D7E  2202      3151          move.l    D2,D1
00001D80  E589      3152          lsl.l     #2,D1
00001D82  2F33 1800 3153          move.l    0(A3,D1.L),-(A7)
00001D86  2F02      3154          move.l    D2,-(A7)
00001D88  4879 0000 3155          pea       @m68kde~2_68.L
00001D8C  4500      
00001D8E  4E92      3156          jsr       (A2)
00001D90  DEFC 000C 3157          add.w     #12,A7
                    3158   BreakPointDisplay_11:
00001D94  5282      3159          addq.l    #1,D2
00001D96  609E      3160          bra       BreakPointDisplay_8
                    3161   BreakPointDisplay_10:
                    3162   ; }
                    3163   ; }
                    3164   ; printf("\r\n") ;
00001D98  4879 0000 3165          pea       @m68kde~2_1.L
00001D9C  3E44      
00001D9E  4E92      3166          jsr       (A2)
00001DA0  584F      3167          addq.w    #4,A7
00001DA2  4CDF 0C0C 3168          movem.l   (A7)+,D2/D3/A2/A3
00001DA6  4E75      3169          rts
                    3170   ; }
                    3171   ; void WatchPointDisplay(void)
                    3172   ; {
                    3173   _WatchPointDisplay:
00001DA8  48E7 3020 3174          movem.l   D2/D3/A2,-(A7)
00001DAC  45F9 0000 3175          lea       _printf.L,A2
00001DB0  3532      
                    3176   ; int i ;
                    3177   ; int WatchPointsSet = 0 ;
00001DB2  4283      3178          clr.l     D3
                    3179   ; // any watchpoints set
                    3180   ; for(i = 0; i < 8; i++)  {
00001DB4  4282      3181          clr.l     D2
                    3182   WatchPointDisplay_1:
00001DB6  0C82 0000 3183          cmp.l     #8,D2
00001DBA  0008      
00001DBC  6C1C      3184          bge.s     WatchPointDisplay_3
                    3185   ; if(WatchPointSetOrCleared[i] == 1)
00001DBE  2002      3186          move.l    D2,D0
00001DC0  E588      3187          lsl.l     #2,D0
00001DC2  41F9 0B00 3188          lea       _WatchPointSetOrCleared.L,A0
00001DC6  01A2      
00001DC8  2030 0800 3189          move.l    0(A0,D0.L),D0
00001DCC  0C80 0000 3190          cmp.l     #1,D0
00001DD0  0001      
00001DD2  6602      3191          bne.s     WatchPointDisplay_4
                    3192   ; WatchPointsSet = 1;
00001DD4  7601      3193          moveq     #1,D3
                    3194   WatchPointDisplay_4:
00001DD6  5282      3195          addq.l    #1,D2
00001DD8  60DC      3196          bra       WatchPointDisplay_1
                    3197   WatchPointDisplay_3:
                    3198   ; }
                    3199   ; if(WatchPointsSet == 1) {
00001DDA  0C83 0000 3200          cmp.l     #1,D3
00001DDE  0001      
00001DE0  6616      3201          bne.s     WatchPointDisplay_6
                    3202   ; printf("\r\nNum     Address") ;
00001DE2  4879 0000 3203          pea       @m68kde~2_69.L
00001DE6  4510      
00001DE8  4E92      3204          jsr       (A2)
00001DEA  584F      3205          addq.w    #4,A7
                    3206   ; printf("\r\n---     ---------") ;
00001DEC  4879 0000 3207          pea       @m68kde~2_70.L
00001DF0  4522      
00001DF2  4E92      3208          jsr       (A2)
00001DF4  584F      3209          addq.w    #4,A7
00001DF6  600A      3210          bra.s     WatchPointDisplay_7
                    3211   WatchPointDisplay_6:
                    3212   ; }
                    3213   ; else
                    3214   ; printf("\r\nNo WatchPoints Set") ;
00001DF8  4879 0000 3215          pea       @m68kde~2_71.L
00001DFC  4536      
00001DFE  4E92      3216          jsr       (A2)
00001E00  584F      3217          addq.w    #4,A7
                    3218   WatchPointDisplay_7:
                    3219   ; for(i = 0; i < 8; i++)  {
00001E02  4282      3220          clr.l     D2
                    3221   WatchPointDisplay_8:
00001E04  0C82 0000 3222          cmp.l     #8,D2
00001E08  0008      
00001E0A  6C00 0038 3223          bge       WatchPointDisplay_10
                    3224   ; if(WatchPointSetOrCleared[i] == 1)
00001E0E  2002      3225          move.l    D2,D0
00001E10  E588      3226          lsl.l     #2,D0
00001E12  41F9 0B00 3227          lea       _WatchPointSetOrCleared.L,A0
00001E16  01A2      
00001E18  2030 0800 3228          move.l    0(A0,D0.L),D0
00001E1C  0C80 0000 3229          cmp.l     #1,D0
00001E20  0001      
00001E22  661C      3230          bne.s     WatchPointDisplay_11
                    3231   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00001E24  2202      3232          move.l    D2,D1
00001E26  E589      3233          lsl.l     #2,D1
00001E28  41F9 0B00 3234          lea       _WatchPointAddress.L,A0
00001E2C  0182      
00001E2E  2F30 1800 3235          move.l    0(A0,D1.L),-(A7)
00001E32  2F02      3236          move.l    D2,-(A7)
00001E34  4879 0000 3237          pea       @m68kde~2_68.L
00001E38  4500      
00001E3A  4E92      3238          jsr       (A2)
00001E3C  DEFC 000C 3239          add.w     #12,A7
                    3240   WatchPointDisplay_11:
00001E40  5282      3241          addq.l    #1,D2
00001E42  60C0      3242          bra       WatchPointDisplay_8
                    3243   WatchPointDisplay_10:
                    3244   ; }
                    3245   ; printf("\r\n") ;
00001E44  4879 0000 3246          pea       @m68kde~2_1.L
00001E48  3E44      
00001E4A  4E92      3247          jsr       (A2)
00001E4C  584F      3248          addq.w    #4,A7
00001E4E  4CDF 040C 3249          movem.l   (A7)+,D2/D3/A2
00001E52  4E75      3250          rts
                    3251   ; }
                    3252   ; void BreakPointClear(void)
                    3253   ; {
                    3254   _BreakPointClear:
00001E54  4E56 FFFC 3255          link      A6,#-4
00001E58  48E7 2020 3256          movem.l   D2/A2,-(A7)
00001E5C  45F9 0000 3257          lea       _printf.L,A2
00001E60  3532      
                    3258   ; unsigned int i ;
                    3259   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3260   ; BreakPointDisplay() ;
00001E62  4EB8 1CD4 3261          jsr       _BreakPointDisplay
                    3262   ; printf("\r\nEnter Break Point Number: ") ;
00001E66  4879 0000 3263          pea       @m68kde~2_72.L
00001E6A  454C      
00001E6C  4E92      3264          jsr       (A2)
00001E6E  584F      3265          addq.w    #4,A7
                    3266   ; i = xtod(_getch()) ;           // get break pointer number
00001E70  2F00      3267          move.l    D0,-(A7)
00001E72  4EB8 0B68 3268          jsr       __getch
00001E76  2200      3269          move.l    D0,D1
00001E78  201F      3270          move.l    (A7)+,D0
00001E7A  2F01      3271          move.l    D1,-(A7)
00001E7C  4EB8 0BD2 3272          jsr       _xtod
00001E80  584F      3273          addq.w    #4,A7
00001E82  C0BC 0000 3274          and.l     #255,D0
00001E86  00FF      
00001E88  2400      3275          move.l    D0,D2
                    3276   ; if((i < 0) || (i > 7))   {
00001E8A  0C82 0000 3277          cmp.l     #0,D2
00001E8E  0000      
00001E90  6508      3278          blo.s     BreakPointClear_3
00001E92  0C82 0000 3279          cmp.l     #7,D2
00001E96  0007      
00001E98  630E      3280          bls.s     BreakPointClear_1
                    3281   BreakPointClear_3:
                    3282   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001E9A  4879 0000 3283          pea       @m68kde~2_73.L
00001E9E  456A      
00001EA0  4E92      3284          jsr       (A2)
00001EA2  584F      3285          addq.w    #4,A7
                    3286   ; return ;
00001EA4  6000 0080 3287          bra       BreakPointClear_4
                    3288   BreakPointClear_1:
                    3289   ; }
                    3290   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00001EA8  2002      3291          move.l    D2,D0
00001EAA  E588      3292          lsl.l     #2,D0
00001EAC  41F9 0B00 3293          lea       _BreakPointSetOrCleared.L,A0
00001EB0  015E      
00001EB2  2030 0800 3294          move.l    0(A0,D0.L),D0
00001EB6  0C80 0000 3295          cmp.l     #1,D0
00001EBA  0001      
00001EBC  6600 005A 3296          bne       BreakPointClear_5
                    3297   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00001EC0  2002      3298          move.l    D2,D0
00001EC2  E588      3299          lsl.l     #2,D0
00001EC4  41F9 0B00 3300          lea       _BreakPointAddress.L,A0
00001EC8  012E      
00001ECA  2D70 0800 3301          move.l    0(A0,D0.L),-4(A6)
00001ECE  FFFC      
                    3302   ; BreakPointAddress[i] = 0 ;
00001ED0  2002      3303          move.l    D2,D0
00001ED2  E588      3304          lsl.l     #2,D0
00001ED4  41F9 0B00 3305          lea       _BreakPointAddress.L,A0
00001ED8  012E      
00001EDA  42B0 0800 3306          clr.l     0(A0,D0.L)
                    3307   ; BreakPointSetOrCleared[i] = 0 ;
00001EDE  2002      3308          move.l    D2,D0
00001EE0  E588      3309          lsl.l     #2,D0
00001EE2  41F9 0B00 3310          lea       _BreakPointSetOrCleared.L,A0
00001EE6  015E      
00001EE8  42B0 0800 3311          clr.l     0(A0,D0.L)
                    3312   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00001EEC  2002      3313          move.l    D2,D0
00001EEE  E388      3314          lsl.l     #1,D0
00001EF0  41F9 0B00 3315          lea       _BreakPointInstruction.L,A0
00001EF4  014E      
00001EF6  226E FFFC 3316          move.l    -4(A6),A1
00001EFA  32B0 0800 3317          move.w    0(A0,D0.L),(A1)
                    3318   ; BreakPointInstruction[i] = 0 ;
00001EFE  2002      3319          move.l    D2,D0
00001F00  E388      3320          lsl.l     #1,D0
00001F02  41F9 0B00 3321          lea       _BreakPointInstruction.L,A0
00001F06  014E      
00001F08  4270 0800 3322          clr.w     0(A0,D0.L)
                    3323   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00001F0C  4879 0000 3324          pea       @m68kde~2_74.L
00001F10  4586      
00001F12  4E92      3325          jsr       (A2)
00001F14  584F      3326          addq.w    #4,A7
00001F16  600A      3327          bra.s     BreakPointClear_6
                    3328   BreakPointClear_5:
                    3329   ; }
                    3330   ; else
                    3331   ; printf("\r\nBreak Point wasn't Set.....") ;
00001F18  4879 0000 3332          pea       @m68kde~2_75.L
00001F1C  45A4      
00001F1E  4E92      3333          jsr       (A2)
00001F20  584F      3334          addq.w    #4,A7
                    3335   BreakPointClear_6:
                    3336   ; BreakPointDisplay() ;
00001F22  4EB8 1CD4 3337          jsr       _BreakPointDisplay
                    3338   ; return ;
                    3339   BreakPointClear_4:
00001F26  4CDF 0404 3340          movem.l   (A7)+,D2/A2
00001F2A  4E5E      3341          unlk      A6
00001F2C  4E75      3342          rts
                    3343   ; }
                    3344   ; void WatchPointClear(void)
                    3345   ; {
                    3346   _WatchPointClear:
00001F2E  48E7 2020 3347          movem.l   D2/A2,-(A7)
00001F32  45F9 0000 3348          lea       _printf.L,A2
00001F36  3532      
                    3349   ; unsigned int i ;
                    3350   ; WatchPointDisplay() ;
00001F38  4EB8 1DA8 3351          jsr       _WatchPointDisplay
                    3352   ; printf("\r\nEnter Watch Point Number: ") ;
00001F3C  4879 0000 3353          pea       @m68kde~2_76.L
00001F40  45C2      
00001F42  4E92      3354          jsr       (A2)
00001F44  584F      3355          addq.w    #4,A7
                    3356   ; i = xtod(_getch()) ;           // get watch pointer number
00001F46  2F00      3357          move.l    D0,-(A7)
00001F48  4EB8 0B68 3358          jsr       __getch
00001F4C  2200      3359          move.l    D0,D1
00001F4E  201F      3360          move.l    (A7)+,D0
00001F50  2F01      3361          move.l    D1,-(A7)
00001F52  4EB8 0BD2 3362          jsr       _xtod
00001F56  584F      3363          addq.w    #4,A7
00001F58  C0BC 0000 3364          and.l     #255,D0
00001F5C  00FF      
00001F5E  2400      3365          move.l    D0,D2
                    3366   ; if((i < 0) || (i > 7))   {
00001F60  0C82 0000 3367          cmp.l     #0,D2
00001F64  0000      
00001F66  6508      3368          blo.s     WatchPointClear_3
00001F68  0C82 0000 3369          cmp.l     #7,D2
00001F6C  0007      
00001F6E  630E      3370          bls.s     WatchPointClear_1
                    3371   WatchPointClear_3:
                    3372   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001F70  4879 0000 3373          pea       @m68kde~2_73.L
00001F74  456A      
00001F76  4E92      3374          jsr       (A2)
00001F78  584F      3375          addq.w    #4,A7
                    3376   ; return ;
00001F7A  6000 004E 3377          bra       WatchPointClear_4
                    3378   WatchPointClear_1:
                    3379   ; }
                    3380   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00001F7E  2002      3381          move.l    D2,D0
00001F80  E588      3382          lsl.l     #2,D0
00001F82  41F9 0B00 3383          lea       _WatchPointSetOrCleared.L,A0
00001F86  01A2      
00001F88  2030 0800 3384          move.l    0(A0,D0.L),D0
00001F8C  0C80 0000 3385          cmp.l     #1,D0
00001F90  0001      
00001F92  6628      3386          bne.s     WatchPointClear_5
                    3387   ; WatchPointAddress[i] = 0 ;
00001F94  2002      3388          move.l    D2,D0
00001F96  E588      3389          lsl.l     #2,D0
00001F98  41F9 0B00 3390          lea       _WatchPointAddress.L,A0
00001F9C  0182      
00001F9E  42B0 0800 3391          clr.l     0(A0,D0.L)
                    3392   ; WatchPointSetOrCleared[i] = 0 ;
00001FA2  2002      3393          move.l    D2,D0
00001FA4  E588      3394          lsl.l     #2,D0
00001FA6  41F9 0B00 3395          lea       _WatchPointSetOrCleared.L,A0
00001FAA  01A2      
00001FAC  42B0 0800 3396          clr.l     0(A0,D0.L)
                    3397   ; printf("\r\nWatch Point Cleared.....\r\n") ;
00001FB0  4879 0000 3398          pea       @m68kde~2_77.L
00001FB4  45E0      
00001FB6  4E92      3399          jsr       (A2)
00001FB8  584F      3400          addq.w    #4,A7
00001FBA  600A      3401          bra.s     WatchPointClear_6
                    3402   WatchPointClear_5:
                    3403   ; }
                    3404   ; else
                    3405   ; printf("\r\nWatch Point Was not Set.....") ;
00001FBC  4879 0000 3406          pea       @m68kde~2_78.L
00001FC0  45FE      
00001FC2  4E92      3407          jsr       (A2)
00001FC4  584F      3408          addq.w    #4,A7
                    3409   WatchPointClear_6:
                    3410   ; WatchPointDisplay() ;
00001FC6  4EB8 1DA8 3411          jsr       _WatchPointDisplay
                    3412   ; return ;
                    3413   WatchPointClear_4:
00001FCA  4CDF 0404 3414          movem.l   (A7)+,D2/A2
00001FCE  4E75      3415          rts
                    3416   ; }
                    3417   ; void DisableBreakPoints(void)
                    3418   ; {
                    3419   _DisableBreakPoints:
00001FD0  4E56 FFFC 3420          link      A6,#-4
00001FD4  2F02      3421          move.l    D2,-(A7)
                    3422   ; int i ;
                    3423   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3424   ; for(i = 0; i < 8; i++)  {
00001FD6  4282      3425          clr.l     D2
                    3426   DisableBreakPoints_1:
00001FD8  0C82 0000 3427          cmp.l     #8,D2
00001FDC  0008      
00001FDE  6C00 003E 3428          bge       DisableBreakPoints_3
                    3429   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00001FE2  2002      3430          move.l    D2,D0
00001FE4  E588      3431          lsl.l     #2,D0
00001FE6  41F9 0B00 3432          lea       _BreakPointSetOrCleared.L,A0
00001FEA  015E      
00001FEC  2030 0800 3433          move.l    0(A0,D0.L),D0
00001FF0  0C80 0000 3434          cmp.l     #1,D0
00001FF4  0001      
00001FF6  6622      3435          bne.s     DisableBreakPoints_4
                    3436   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00001FF8  2002      3437          move.l    D2,D0
00001FFA  E588      3438          lsl.l     #2,D0
00001FFC  41F9 0B00 3439          lea       _BreakPointAddress.L,A0
00002000  012E      
00002002  2D70 0800 3440          move.l    0(A0,D0.L),-4(A6)
00002006  FFFC      
                    3441   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00002008  2002      3442          move.l    D2,D0
0000200A  E388      3443          lsl.l     #1,D0
0000200C  41F9 0B00 3444          lea       _BreakPointInstruction.L,A0
00002010  014E      
00002012  226E FFFC 3445          move.l    -4(A6),A1
00002016  32B0 0800 3446          move.w    0(A0,D0.L),(A1)
                    3447   DisableBreakPoints_4:
0000201A  5282      3448          addq.l    #1,D2
0000201C  60BA      3449          bra       DisableBreakPoints_1
                    3450   DisableBreakPoints_3:
0000201E  241F      3451          move.l    (A7)+,D2
00002020  4E5E      3452          unlk      A6
00002022  4E75      3453          rts
                    3454   ; }
                    3455   ; }
                    3456   ; }
                    3457   ; void EnableBreakPoints(void)
                    3458   ; {
                    3459   _EnableBreakPoints:
00002024  4E56 FFFC 3460          link      A6,#-4
00002028  2F02      3461          move.l    D2,-(A7)
                    3462   ; int i ;
                    3463   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3464   ; for(i = 0; i < 8; i++)  {
0000202A  4282      3465          clr.l     D2
                    3466   EnableBreakPoints_1:
0000202C  0C82 0000 3467          cmp.l     #8,D2
00002030  0008      
00002032  6C32      3468          bge.s     EnableBreakPoints_3
                    3469   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00002034  2002      3470          move.l    D2,D0
00002036  E588      3471          lsl.l     #2,D0
00002038  41F9 0B00 3472          lea       _BreakPointSetOrCleared.L,A0
0000203C  015E      
0000203E  2030 0800 3473          move.l    0(A0,D0.L),D0
00002042  0C80 0000 3474          cmp.l     #1,D0
00002046  0001      
00002048  6618      3475          bne.s     EnableBreakPoints_4
                    3476   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
0000204A  2002      3477          move.l    D2,D0
0000204C  E588      3478          lsl.l     #2,D0
0000204E  41F9 0B00 3479          lea       _BreakPointAddress.L,A0
00002052  012E      
00002054  2D70 0800 3480          move.l    0(A0,D0.L),-4(A6)
00002058  FFFC      
                    3481   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
0000205A  206E FFFC 3482          move.l    -4(A6),A0
0000205E  30BC 4E4E 3483          move.w    #20046,(A0)
                    3484   EnableBreakPoints_4:
00002062  5282      3485          addq.l    #1,D2
00002064  60C6      3486          bra       EnableBreakPoints_1
                    3487   EnableBreakPoints_3:
00002066  241F      3488          move.l    (A7)+,D2
00002068  4E5E      3489          unlk      A6
0000206A  4E75      3490          rts
                    3491   ; }
                    3492   ; }
                    3493   ; }
                    3494   ; void KillAllBreakPoints(void)
                    3495   ; {
                    3496   _KillAllBreakPoints:
0000206C  4E56 FFFC 3497          link      A6,#-4
00002070  2F02      3498          move.l    D2,-(A7)
                    3499   ; int i ;
                    3500   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3501   ; for(i = 0; i < 8; i++)  {
00002072  4282      3502          clr.l     D2
                    3503   KillAllBreakPoints_1:
00002074  0C82 0000 3504          cmp.l     #8,D2
00002078  0008      
0000207A  6C00 0052 3505          bge       KillAllBreakPoints_3
                    3506   ; // clear BP
                    3507   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
0000207E  2002      3508          move.l    D2,D0
00002080  E588      3509          lsl.l     #2,D0
00002082  41F9 0B00 3510          lea       _BreakPointAddress.L,A0
00002086  012E      
00002088  2D70 0800 3511          move.l    0(A0,D0.L),-4(A6)
0000208C  FFFC      
                    3512   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
0000208E  2002      3513          move.l    D2,D0
00002090  E388      3514          lsl.l     #1,D0
00002092  41F9 0B00 3515          lea       _BreakPointInstruction.L,A0
00002096  014E      
00002098  226E FFFC 3516          move.l    -4(A6),A1
0000209C  32B0 0800 3517          move.w    0(A0,D0.L),(A1)
                    3518   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
000020A0  2002      3519          move.l    D2,D0
000020A2  E588      3520          lsl.l     #2,D0
000020A4  41F9 0B00 3521          lea       _BreakPointAddress.L,A0
000020A8  012E      
000020AA  42B0 0800 3522          clr.l     0(A0,D0.L)
                    3523   ; BreakPointInstruction[i] = 0 ;
000020AE  2002      3524          move.l    D2,D0
000020B0  E388      3525          lsl.l     #1,D0
000020B2  41F9 0B00 3526          lea       _BreakPointInstruction.L,A0
000020B6  014E      
000020B8  4270 0800 3527          clr.w     0(A0,D0.L)
                    3528   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
000020BC  2002      3529          move.l    D2,D0
000020BE  E588      3530          lsl.l     #2,D0
000020C0  41F9 0B00 3531          lea       _BreakPointSetOrCleared.L,A0
000020C4  015E      
000020C6  42B0 0800 3532          clr.l     0(A0,D0.L)
000020CA  5282      3533          addq.l    #1,D2
000020CC  60A6      3534          bra       KillAllBreakPoints_1
                    3535   KillAllBreakPoints_3:
000020CE  241F      3536          move.l    (A7)+,D2
000020D0  4E5E      3537          unlk      A6
000020D2  4E75      3538          rts
                    3539   ; }
                    3540   ; //BreakPointDisplay() ;       // display the break points
                    3541   ; }
                    3542   ; void KillAllWatchPoints(void)
                    3543   ; {
                    3544   _KillAllWatchPoints:
000020D4  2F02      3545          move.l    D2,-(A7)
                    3546   ; int i ;
                    3547   ; for(i = 0; i < 8; i++)  {
000020D6  4282      3548          clr.l     D2
                    3549   KillAllWatchPoints_1:
000020D8  0C82 0000 3550          cmp.l     #8,D2
000020DC  0008      
000020DE  6C20      3551          bge.s     KillAllWatchPoints_3
                    3552   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
000020E0  2002      3553          move.l    D2,D0
000020E2  E588      3554          lsl.l     #2,D0
000020E4  41F9 0B00 3555          lea       _WatchPointAddress.L,A0
000020E8  0182      
000020EA  42B0 0800 3556          clr.l     0(A0,D0.L)
                    3557   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
000020EE  2002      3558          move.l    D2,D0
000020F0  E588      3559          lsl.l     #2,D0
000020F2  41F9 0B00 3560          lea       _WatchPointSetOrCleared.L,A0
000020F6  01A2      
000020F8  42B0 0800 3561          clr.l     0(A0,D0.L)
000020FC  5282      3562          addq.l    #1,D2
000020FE  60D8      3563          bra       KillAllWatchPoints_1
                    3564   KillAllWatchPoints_3:
00002100  241F      3565          move.l    (A7)+,D2
00002102  4E75      3566          rts
                    3567   ; }
                    3568   ; //WatchPointDisplay() ;       // display the break points
                    3569   ; }
                    3570   ; void SetBreakPoint(void)
                    3571   ; {
                    3572   _SetBreakPoint:
00002104  4E56 FFFC 3573          link      A6,#-4
00002108  48E7 3830 3574          movem.l   D2/D3/D4/A2/A3,-(A7)
0000210C  45F9 0000 3575          lea       _printf.L,A2
00002110  3532      
00002112  47F9 0B00 3576          lea       _BreakPointSetOrCleared.L,A3
00002116  015E      
                    3577   ; int i ;
                    3578   ; int BPNumber;
                    3579   ; int BPAddress;
                    3580   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3581   ; // see if any free break points
                    3582   ; for(i = 0; i < 8; i ++) {
00002118  4282      3583          clr.l     D2
                    3584   SetBreakPoint_1:
0000211A  0C82 0000 3585          cmp.l     #8,D2
0000211E  0008      
00002120  6C10      3586          bge.s     SetBreakPoint_3
                    3587   ; if( BreakPointSetOrCleared[i] == 0)
00002122  2002      3588          move.l    D2,D0
00002124  E588      3589          lsl.l     #2,D0
00002126  2033 0800 3590          move.l    0(A3,D0.L),D0
0000212A  6602      3591          bne.s     SetBreakPoint_4
                    3592   ; break ;         // if spare BP found allow user to set it
0000212C  6004      3593          bra.s     SetBreakPoint_3
                    3594   SetBreakPoint_4:
0000212E  5282      3595          addq.l    #1,D2
00002130  60E8      3596          bra       SetBreakPoint_1
                    3597   SetBreakPoint_3:
                    3598   ; }
                    3599   ; if(i == 8) {
00002132  0C82 0000 3600          cmp.l     #8,D2
00002136  0008      
00002138  660E      3601          bne.s     SetBreakPoint_6
                    3602   ; printf("\r\nNo FREE Break Points.....") ;
0000213A  4879 0000 3603          pea       @m68kde~2_79.L
0000213E  461E      
00002140  4E92      3604          jsr       (A2)
00002142  584F      3605          addq.w    #4,A7
                    3606   ; return ;
00002144  6000 00D6 3607          bra       SetBreakPoint_15
                    3608   SetBreakPoint_6:
                    3609   ; }
                    3610   ; printf("\r\nBreak Point Address: ") ;
00002148  4879 0000 3611          pea       @m68kde~2_80.L
0000214C  463A      
0000214E  4E92      3612          jsr       (A2)
00002150  584F      3613          addq.w    #4,A7
                    3614   ; BPAddress = Get8HexDigits(0) ;
00002152  42A7      3615          clr.l     -(A7)
00002154  4EB8 0CA4 3616          jsr       _Get8HexDigits
00002158  584F      3617          addq.w    #4,A7
0000215A  2600      3618          move.l    D0,D3
                    3619   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
0000215C  2803      3620          move.l    D3,D4
                    3621   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
0000215E  2003      3622          move.l    D3,D0
00002160  C0BC 0000 3623          and.l     #1,D0
00002164  0001      
00002166  0C80 0000 3624          cmp.l     #1,D0
0000216A  0001      
0000216C  660E      3625          bne.s     SetBreakPoint_9
                    3626   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
0000216E  4879 0000 3627          pea       @m68kde~2_81.L
00002172  4652      
00002174  4E92      3628          jsr       (A2)
00002176  584F      3629          addq.w    #4,A7
                    3630   ; return ;
00002178  6000 00A2 3631          bra       SetBreakPoint_15
                    3632   SetBreakPoint_9:
                    3633   ; }
                    3634   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
0000217C  0C83 0000 3635          cmp.l     #32768,D3
00002180  8000      
00002182  640E      3636          bhs.s     SetBreakPoint_11
                    3637   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
00002184  4879 0000 3638          pea       @m68kde~2_82.L
00002188  4688      
0000218A  4E92      3639          jsr       (A2)
0000218C  584F      3640          addq.w    #4,A7
                    3641   ; return ;
0000218E  6000 008C 3642          bra       SetBreakPoint_15
                    3643   SetBreakPoint_11:
                    3644   ; }
                    3645   ; // search for first free bp or existing same BP
                    3646   ; for(i = 0; i < 8; i++)  {
00002192  4282      3647          clr.l     D2
                    3648   SetBreakPoint_13:
00002194  0C82 0000 3649          cmp.l     #8,D2
00002198  0008      
0000219A  6C00 0080 3650          bge       SetBreakPoint_15
                    3651   ; if(BreakPointAddress[i] == BPAddress)   {
0000219E  2002      3652          move.l    D2,D0
000021A0  E588      3653          lsl.l     #2,D0
000021A2  41F9 0B00 3654          lea       _BreakPointAddress.L,A0
000021A6  012E      
000021A8  B6B0 0800 3655          cmp.l     0(A0,D0.L),D3
000021AC  6610      3656          bne.s     SetBreakPoint_16
                    3657   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
000021AE  2F03      3658          move.l    D3,-(A7)
000021B0  4879 0000 3659          pea       @m68kde~2_83.L
000021B4  46D0      
000021B6  4E92      3660          jsr       (A2)
000021B8  504F      3661          addq.w    #8,A7
                    3662   ; return ;
000021BA  6000 0060 3663          bra       SetBreakPoint_15
                    3664   SetBreakPoint_16:
                    3665   ; }
                    3666   ; if(BreakPointSetOrCleared[i] == 0) {
000021BE  2002      3667          move.l    D2,D0
000021C0  E588      3668          lsl.l     #2,D0
000021C2  2033 0800 3669          move.l    0(A3,D0.L),D0
000021C6  6600 004E 3670          bne       SetBreakPoint_18
                    3671   ; // set BP here
                    3672   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
000021CA  2002      3673          move.l    D2,D0
000021CC  E588      3674          lsl.l     #2,D0
000021CE  27BC 0000 3675          move.l    #1,0(A3,D0.L)
000021D2  0001 0800 
                    3676   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
000021D6  2044      3677          move.l    D4,A0
000021D8  2002      3678          move.l    D2,D0
000021DA  E388      3679          lsl.l     #1,D0
000021DC  43F9 0B00 3680          lea       _BreakPointInstruction.L,A1
000021E0  014E      
000021E2  3390 0800 3681          move.w    (A0),0(A1,D0.L)
                    3682   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
000021E6  2F04      3683          move.l    D4,-(A7)
000021E8  4879 0000 3684          pea       @m68kde~2_84.L
000021EC  4708      
000021EE  4E92      3685          jsr       (A2)
000021F0  504F      3686          addq.w    #8,A7
                    3687   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
000021F2  2044      3688          move.l    D4,A0
000021F4  30BC 4E4E 3689          move.w    #20046,(A0)
                    3690   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
000021F8  2002      3691          move.l    D2,D0
000021FA  E588      3692          lsl.l     #2,D0
000021FC  41F9 0B00 3693          lea       _BreakPointAddress.L,A0
00002200  012E      
00002202  2183 0800 3694          move.l    D3,0(A0,D0.L)
                    3695   ; printf("\r\n") ;
00002206  4879 0000 3696          pea       @m68kde~2_1.L
0000220A  3E44      
0000220C  4E92      3697          jsr       (A2)
0000220E  584F      3698          addq.w    #4,A7
                    3699   ; BreakPointDisplay() ;       // display the break points
00002210  4EB8 1CD4 3700          jsr       _BreakPointDisplay
                    3701   ; return ;
00002214  6006      3702          bra.s     SetBreakPoint_15
                    3703   SetBreakPoint_18:
00002216  5282      3704          addq.l    #1,D2
00002218  6000 FF7A 3705          bra       SetBreakPoint_13
                    3706   SetBreakPoint_15:
0000221C  4CDF 0C1C 3707          movem.l   (A7)+,D2/D3/D4/A2/A3
00002220  4E5E      3708          unlk      A6
00002222  4E75      3709          rts
                    3710   ; }
                    3711   ; }
                    3712   ; }
                    3713   ; void SetWatchPoint(void)
                    3714   ; {
                    3715   _SetWatchPoint:
00002224  4E56 FFF8 3716          link      A6,#-8
00002228  48E7 3030 3717          movem.l   D2/D3/A2/A3,-(A7)
0000222C  45F9 0000 3718          lea       _printf.L,A2
00002230  3532      
00002232  47F9 0B00 3719          lea       _WatchPointSetOrCleared.L,A3
00002236  01A2      
                    3720   ; int i ;
                    3721   ; int WPNumber;
                    3722   ; int WPAddress;
                    3723   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    3724   ; // see if any free break points
                    3725   ; for(i = 0; i < 8; i ++) {
00002238  4282      3726          clr.l     D2
                    3727   SetWatchPoint_1:
0000223A  0C82 0000 3728          cmp.l     #8,D2
0000223E  0008      
00002240  6C10      3729          bge.s     SetWatchPoint_3
                    3730   ; if( WatchPointSetOrCleared[i] == 0)
00002242  2002      3731          move.l    D2,D0
00002244  E588      3732          lsl.l     #2,D0
00002246  2033 0800 3733          move.l    0(A3,D0.L),D0
0000224A  6602      3734          bne.s     SetWatchPoint_4
                    3735   ; break ;         // if spare WP found allow user to set it
0000224C  6004      3736          bra.s     SetWatchPoint_3
                    3737   SetWatchPoint_4:
0000224E  5282      3738          addq.l    #1,D2
00002250  60E8      3739          bra       SetWatchPoint_1
                    3740   SetWatchPoint_3:
                    3741   ; }
                    3742   ; if(i == 8) {
00002252  0C82 0000 3743          cmp.l     #8,D2
00002256  0008      
00002258  660E      3744          bne.s     SetWatchPoint_6
                    3745   ; printf("\r\nNo FREE Watch Points.....") ;
0000225A  4879 0000 3746          pea       @m68kde~2_85.L
0000225E  472E      
00002260  4E92      3747          jsr       (A2)
00002262  584F      3748          addq.w    #4,A7
                    3749   ; return ;
00002264  6000 008C 3750          bra       SetWatchPoint_11
                    3751   SetWatchPoint_6:
                    3752   ; }
                    3753   ; printf("\r\nWatch Point Address: ") ;
00002268  4879 0000 3754          pea       @m68kde~2_86.L
0000226C  474A      
0000226E  4E92      3755          jsr       (A2)
00002270  584F      3756          addq.w    #4,A7
                    3757   ; WPAddress = Get8HexDigits(0) ;
00002272  42A7      3758          clr.l     -(A7)
00002274  4EB8 0CA4 3759          jsr       _Get8HexDigits
00002278  584F      3760          addq.w    #4,A7
0000227A  2600      3761          move.l    D0,D3
                    3762   ; // search for first free wp or existing same wp
                    3763   ; for(i = 0; i < 8; i++)  {
0000227C  4282      3764          clr.l     D2
                    3765   SetWatchPoint_9:
0000227E  0C82 0000 3766          cmp.l     #8,D2
00002282  0008      
00002284  6C00 006C 3767          bge       SetWatchPoint_11
                    3768   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
00002288  2002      3769          move.l    D2,D0
0000228A  E588      3770          lsl.l     #2,D0
0000228C  41F9 0B00 3771          lea       _WatchPointAddress.L,A0
00002290  0182      
00002292  B6B0 0800 3772          cmp.l     0(A0,D0.L),D3
00002296  6614      3773          bne.s     SetWatchPoint_12
00002298  4A83      3774          tst.l     D3
0000229A  6710      3775          beq.s     SetWatchPoint_12
                    3776   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
0000229C  2F03      3777          move.l    D3,-(A7)
0000229E  4879 0000 3778          pea       @m68kde~2_87.L
000022A2  4762      
000022A4  4E92      3779          jsr       (A2)
000022A6  504F      3780          addq.w    #8,A7
                    3781   ; return ;
000022A8  6000 0048 3782          bra       SetWatchPoint_11
                    3783   SetWatchPoint_12:
                    3784   ; }
                    3785   ; if(WatchPointSetOrCleared[i] == 0) {
000022AC  2002      3786          move.l    D2,D0
000022AE  E588      3787          lsl.l     #2,D0
000022B0  2033 0800 3788          move.l    0(A3,D0.L),D0
000022B4  6600 0038 3789          bne       SetWatchPoint_14
                    3790   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
000022B8  2002      3791          move.l    D2,D0
000022BA  E588      3792          lsl.l     #2,D0
000022BC  27BC 0000 3793          move.l    #1,0(A3,D0.L)
000022C0  0001 0800 
                    3794   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
000022C4  2F03      3795          move.l    D3,-(A7)
000022C6  4879 0000 3796          pea       @m68kde~2_88.L
000022CA  4798      
000022CC  4E92      3797          jsr       (A2)
000022CE  504F      3798          addq.w    #8,A7
                    3799   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
000022D0  2002      3800          move.l    D2,D0
000022D2  E588      3801          lsl.l     #2,D0
000022D4  41F9 0B00 3802          lea       _WatchPointAddress.L,A0
000022D8  0182      
000022DA  2183 0800 3803          move.l    D3,0(A0,D0.L)
                    3804   ; printf("\r\n") ;
000022DE  4879 0000 3805          pea       @m68kde~2_1.L
000022E2  3E44      
000022E4  4E92      3806          jsr       (A2)
000022E6  584F      3807          addq.w    #4,A7
                    3808   ; WatchPointDisplay() ;       // display the break points
000022E8  4EB8 1DA8 3809          jsr       _WatchPointDisplay
                    3810   ; return ;
000022EC  6004      3811          bra.s     SetWatchPoint_11
                    3812   SetWatchPoint_14:
000022EE  5282      3813          addq.l    #1,D2
000022F0  608C      3814          bra       SetWatchPoint_9
                    3815   SetWatchPoint_11:
000022F2  4CDF 0C0C 3816          movem.l   (A7)+,D2/D3/A2/A3
000022F6  4E5E      3817          unlk      A6
000022F8  4E75      3818          rts
                    3819   ; }
                    3820   ; }
                    3821   ; }
                    3822   ; void HandleBreakPoint(void)
                    3823   ; {
                    3824   _HandleBreakPoint:
000022FA  4E56 FFFC 3825          link      A6,#-4
000022FE  48E7 0038 3826          movem.l   A2/A3/A4,-(A7)
00002302  45F9 0B00 3827          lea       _i.L,A2
00002306  00C4      
00002308  47F9 0000 3828          lea       _printf.L,A3
0000230C  3532      
0000230E  49F9 0B00 3829          lea       _PC.L,A4
00002312  0120      
                    3830   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3831   ; // now we have to put the break point back to run the instruction
                    3832   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3833   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
00002314  5594      3834          subq.l    #2,(A4)
                    3835   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
00002316  4879 0000 3836          pea       @m68kde~2_89.L
0000231A  47BE      
0000231C  4E93      3837          jsr       (A3)
0000231E  584F      3838          addq.w    #4,A7
                    3839   ; printf("\r\nSingle Step : [ON]") ;
00002320  4879 0000 3840          pea       @m68kde~2_90.L
00002324  47D2      
00002326  4E93      3841          jsr       (A3)
00002328  584F      3842          addq.w    #4,A7
                    3843   ; printf("\r\nBreakPoints : [Enabled]") ;
0000232A  4879 0000 3844          pea       @m68kde~2_91.L
0000232E  47E8      
00002330  4E93      3845          jsr       (A3)
00002332  584F      3846          addq.w    #4,A7
                    3847   ; // now clear the break point (put original instruction back)
                    3848   ; ProgramBreakPointAddress = PC ;
00002334  2D54 FFFC 3849          move.l    (A4),-4(A6)
                    3850   ; for(i = 0; i < 8; i ++) {
00002338  4292      3851          clr.l     (A2)
                    3852   HandleBreakPoint_1:
0000233A  2012      3853          move.l    (A2),D0
0000233C  0C80 0000 3854          cmp.l     #8,D0
00002340  0008      
00002342  6400 0056 3855          bhs       HandleBreakPoint_3
                    3856   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
00002346  2012      3857          move.l    (A2),D0
00002348  E588      3858          lsl.l     #2,D0
0000234A  41F9 0B00 3859          lea       _BreakPointAddress.L,A0
0000234E  012E      
00002350  2230 0800 3860          move.l    0(A0,D0.L),D1
00002354  B294      3861          cmp.l     (A4),D1
00002356  6600 003E 3862          bne       HandleBreakPoint_4
                    3863   ; BreakPointAddress[i] = 0 ;
0000235A  2012      3864          move.l    (A2),D0
0000235C  E588      3865          lsl.l     #2,D0
0000235E  41F9 0B00 3866          lea       _BreakPointAddress.L,A0
00002362  012E      
00002364  42B0 0800 3867          clr.l     0(A0,D0.L)
                    3868   ; BreakPointSetOrCleared[i] = 0 ;
00002368  2012      3869          move.l    (A2),D0
0000236A  E588      3870          lsl.l     #2,D0
0000236C  41F9 0B00 3871          lea       _BreakPointSetOrCleared.L,A0
00002370  015E      
00002372  42B0 0800 3872          clr.l     0(A0,D0.L)
                    3873   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002376  2012      3874          move.l    (A2),D0
00002378  E388      3875          lsl.l     #1,D0
0000237A  41F9 0B00 3876          lea       _BreakPointInstruction.L,A0
0000237E  014E      
00002380  226E FFFC 3877          move.l    -4(A6),A1
00002384  32B0 0800 3878          move.w    0(A0,D0.L),(A1)
                    3879   ; BreakPointInstruction[i] = 0 ;
00002388  2012      3880          move.l    (A2),D0
0000238A  E388      3881          lsl.l     #1,D0
0000238C  41F9 0B00 3882          lea       _BreakPointInstruction.L,A0
00002390  014E      
00002392  4270 0800 3883          clr.w     0(A0,D0.L)
                    3884   HandleBreakPoint_4:
00002396  5292      3885          addq.l    #1,(A2)
00002398  60A0      3886          bra       HandleBreakPoint_1
                    3887   HandleBreakPoint_3:
                    3888   ; }
                    3889   ; }
                    3890   ; DumpRegisters() ;
0000239A  4EB8 1526 3891          jsr       _DumpRegisters
                    3892   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000239E  4879 0000 3893          pea       @m68kde~2_53.L
000023A2  4364      
000023A4  4E93      3894          jsr       (A3)
000023A6  584F      3895          addq.w    #4,A7
                    3896   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
000023A8  4879 0000 3897          pea       @m68kde~2_92.L
000023AC  4802      
000023AE  4E93      3898          jsr       (A3)
000023B0  584F      3899          addq.w    #4,A7
                    3900   ; menu() ;
000023B2  4EB9 0000 3901          jsr       _menu
000023B6  25BE      
000023B8  4CDF 1C00 3902          movem.l   (A7)+,A2/A3/A4
000023BC  4E5E      3903          unlk      A6
000023BE  4E75      3904          rts
                    3905   ; }
                    3906   ; void UnknownCommand()
                    3907   ; {
                    3908   _UnknownCommand:
                    3909   ; printf("\r\nUnknown Command.....\r\n") ;
000023C0  4879 0000 3910          pea       @m68kde~2_93.L
000023C4  482A      
000023C6  4EB9 0000 3911          jsr       _printf
000023CA  3532      
000023CC  584F      3912          addq.w    #4,A7
                    3913   ; Help() ;
000023CE  4EB9 0000 3914          jsr       _Help
000023D2  24E4      
000023D4  4E75      3915          rts
                    3916   ; }
                    3917   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3918   ; void CallDebugMonitor(void)
                    3919   ; {
                    3920   _CallDebugMonitor:
                    3921   ; printf("\r\nProgram Ended (TRAP #15)....") ;
000023D6  4879 0000 3922          pea       @m68kde~2_94.L
000023DA  4844      
000023DC  4EB9 0000 3923          jsr       _printf
000023E0  3532      
000023E2  584F      3924          addq.w    #4,A7
                    3925   ; menu();
000023E4  4EB9 0000 3926          jsr       _menu
000023E8  25BE      
000023EA  4E75      3927          rts
                    3928   ; }
                    3929   ; void Breakpoint(void)
                    3930   ; {
                    3931   _Breakpoint:
000023EC  2F02      3932          move.l    D2,-(A7)
                    3933   ; char c;
                    3934   ; c = toupper(_getch());
000023EE  2F00      3935          move.l    D0,-(A7)
000023F0  4EB8 0B68 3936          jsr       __getch
000023F4  2200      3937          move.l    D0,D1
000023F6  201F      3938          move.l    (A7)+,D0
000023F8  2F01      3939          move.l    D1,-(A7)
000023FA  4EB9 0000 3940          jsr       _toupper
000023FE  3516      
00002400  584F      3941          addq.w    #4,A7
00002402  1400      3942          move.b    D0,D2
                    3943   ; if( c == (char)('D'))                                      // BreakPoint Display
00002404  0C02 0044 3944          cmp.b     #68,D2
00002408  6608      3945          bne.s     Breakpoint_1
                    3946   ; BreakPointDisplay() ;
0000240A  4EB8 1CD4 3947          jsr       _BreakPointDisplay
0000240E  6000 0054 3948          bra       Breakpoint_10
                    3949   Breakpoint_1:
                    3950   ; else if(c == (char)('K')) {                                 // breakpoint Kill
00002412  0C02 004B 3951          cmp.b     #75,D2
00002416  6630      3952          bne.s     Breakpoint_3
                    3953   ; printf("\r\nKill All Break Points...(y/n)?") ;
00002418  4879 0000 3954          pea       @m68kde~2_95.L
0000241C  4864      
0000241E  4EB9 0000 3955          jsr       _printf
00002422  3532      
00002424  584F      3956          addq.w    #4,A7
                    3957   ; c = toupper(_getch());
00002426  2F00      3958          move.l    D0,-(A7)
00002428  4EB8 0B68 3959          jsr       __getch
0000242C  2200      3960          move.l    D0,D1
0000242E  201F      3961          move.l    (A7)+,D0
00002430  2F01      3962          move.l    D1,-(A7)
00002432  4EB9 0000 3963          jsr       _toupper
00002436  3516      
00002438  584F      3964          addq.w    #4,A7
0000243A  1400      3965          move.b    D0,D2
                    3966   ; if(c == (char)('Y'))
0000243C  0C02 0059 3967          cmp.b     #89,D2
00002440  6604      3968          bne.s     Breakpoint_5
                    3969   ; KillAllBreakPoints() ;
00002442  4EB8 206C 3970          jsr       _KillAllBreakPoints
                    3971   Breakpoint_5:
00002446  601C      3972          bra.s     Breakpoint_10
                    3973   Breakpoint_3:
                    3974   ; }
                    3975   ; else if(c == (char)('S')) {
00002448  0C02 0053 3976          cmp.b     #83,D2
0000244C  6606      3977          bne.s     Breakpoint_7
                    3978   ; SetBreakPoint() ;
0000244E  4EB8 2104 3979          jsr       _SetBreakPoint
00002452  6010      3980          bra.s     Breakpoint_10
                    3981   Breakpoint_7:
                    3982   ; }
                    3983   ; else if(c == (char)('C')) {
00002454  0C02 0043 3984          cmp.b     #67,D2
00002458  6606      3985          bne.s     Breakpoint_9
                    3986   ; BreakPointClear() ;
0000245A  4EB8 1E54 3987          jsr       _BreakPointClear
0000245E  6004      3988          bra.s     Breakpoint_10
                    3989   Breakpoint_9:
                    3990   ; }
                    3991   ; else
                    3992   ; UnknownCommand() ;
00002460  4EB8 23C0 3993          jsr       _UnknownCommand
                    3994   Breakpoint_10:
00002464  241F      3995          move.l    (A7)+,D2
00002466  4E75      3996          rts
                    3997   ; }
                    3998   ; void Watchpoint(void)
                    3999   ; {
                    4000   _Watchpoint:
00002468  2F02      4001          move.l    D2,-(A7)
                    4002   ; char c;
                    4003   ; c = toupper(_getch());
0000246A  2F00      4004          move.l    D0,-(A7)
0000246C  4EB8 0B68 4005          jsr       __getch
00002470  2200      4006          move.l    D0,D1
00002472  201F      4007          move.l    (A7)+,D0
00002474  2F01      4008          move.l    D1,-(A7)
00002476  4EB9 0000 4009          jsr       _toupper
0000247A  3516      
0000247C  584F      4010          addq.w    #4,A7
0000247E  1400      4011          move.b    D0,D2
                    4012   ; if( c == (char)('D'))                                      // WatchPoint Display
00002480  0C02 0044 4013          cmp.b     #68,D2
00002484  6608      4014          bne.s     Watchpoint_1
                    4015   ; WatchPointDisplay() ;
00002486  4EB8 1DA8 4016          jsr       _WatchPointDisplay
0000248A  6000 0054 4017          bra       Watchpoint_10
                    4018   Watchpoint_1:
                    4019   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
0000248E  0C02 004B 4020          cmp.b     #75,D2
00002492  6630      4021          bne.s     Watchpoint_3
                    4022   ; printf("\r\nKill All Watch Points...(y/n)?") ;
00002494  4879 0000 4023          pea       @m68kde~2_96.L
00002498  4886      
0000249A  4EB9 0000 4024          jsr       _printf
0000249E  3532      
000024A0  584F      4025          addq.w    #4,A7
                    4026   ; c = toupper(_getch());
000024A2  2F00      4027          move.l    D0,-(A7)
000024A4  4EB8 0B68 4028          jsr       __getch
000024A8  2200      4029          move.l    D0,D1
000024AA  201F      4030          move.l    (A7)+,D0
000024AC  2F01      4031          move.l    D1,-(A7)
000024AE  4EB9 0000 4032          jsr       _toupper
000024B2  3516      
000024B4  584F      4033          addq.w    #4,A7
000024B6  1400      4034          move.b    D0,D2
                    4035   ; if(c == (char)('Y'))
000024B8  0C02 0059 4036          cmp.b     #89,D2
000024BC  6604      4037          bne.s     Watchpoint_5
                    4038   ; KillAllWatchPoints() ;
000024BE  4EB8 20D4 4039          jsr       _KillAllWatchPoints
                    4040   Watchpoint_5:
000024C2  601C      4041          bra.s     Watchpoint_10
                    4042   Watchpoint_3:
                    4043   ; }
                    4044   ; else if(c == (char)('S')) {
000024C4  0C02 0053 4045          cmp.b     #83,D2
000024C8  6606      4046          bne.s     Watchpoint_7
                    4047   ; SetWatchPoint() ;
000024CA  4EB8 2224 4048          jsr       _SetWatchPoint
000024CE  6010      4049          bra.s     Watchpoint_10
                    4050   Watchpoint_7:
                    4051   ; }
                    4052   ; else if(c == (char)('C')) {
000024D0  0C02 0043 4053          cmp.b     #67,D2
000024D4  6606      4054          bne.s     Watchpoint_9
                    4055   ; WatchPointClear() ;
000024D6  4EB8 1F2E 4056          jsr       _WatchPointClear
000024DA  6004      4057          bra.s     Watchpoint_10
                    4058   Watchpoint_9:
                    4059   ; }
                    4060   ; else
                    4061   ; UnknownCommand() ;
000024DC  4EB8 23C0 4062          jsr       _UnknownCommand
                    4063   Watchpoint_10:
000024E0  241F      4064          move.l    (A7)+,D2
000024E2  4E75      4065          rts
                    4066   ; }
                    4067   ; void Help(void)
                    4068   ; {
                    4069   _Help:
000024E4  48E7 2020 4070          movem.l   D2/A2,-(A7)
000024E8  45F9 0000 4071          lea       _printf.L,A2
000024EC  3532      
                    4072   ; char *banner = "\r\n----------------------------------------------------------------" ;
000024EE  41F9 0000 4073          lea       @m68kde~2_97.L,A0
000024F2  48A8      
000024F4  2408      4074          move.l    A0,D2
                    4075   ; printf(banner) ;
000024F6  2F02      4076          move.l    D2,-(A7)
000024F8  4E92      4077          jsr       (A2)
000024FA  584F      4078          addq.w    #4,A7
                    4079   ; printf("\r\n  Debugger Command Summary") ;
000024FC  4879 0000 4080          pea       @m68kde~2_98.L
00002500  48EC      
00002502  4E92      4081          jsr       (A2)
00002504  584F      4082          addq.w    #4,A7
                    4083   ; printf(banner) ;
00002506  2F02      4084          move.l    D2,-(A7)
00002508  4E92      4085          jsr       (A2)
0000250A  584F      4086          addq.w    #4,A7
                    4087   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
0000250C  4879 0000 4088          pea       @m68kde~2_99.L
00002510  490A      
00002512  4E92      4089          jsr       (A2)
00002514  584F      4090          addq.w    #4,A7
                    4091   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
00002516  4879 0000 4092          pea       @m68kde~2_100.L
0000251A  494E      
0000251C  4E92      4093          jsr       (A2)
0000251E  584F      4094          addq.w    #4,A7
                    4095   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
00002520  4879 0000 4096          pea       @m68kde~2_101.L
00002524  4986      
00002526  4E92      4097          jsr       (A2)
00002528  584F      4098          addq.w    #4,A7
                    4099   ; printf("\r\n  D            - Dump Memory Contents to Screen") ;
0000252A  4879 0000 4100          pea       @m68kde~2_102.L
0000252E  49C0      
00002530  4E92      4101          jsr       (A2)
00002532  584F      4102          addq.w    #4,A7
                    4103   ; printf("\r\n  E            - Enter String into Memory") ;
00002534  4879 0000 4104          pea       @m68kde~2_103.L
00002538  49F2      
0000253A  4E92      4105          jsr       (A2)
0000253C  584F      4106          addq.w    #4,A7
                    4107   ; printf("\r\n  F            - Fill Memory with Data") ;
0000253E  4879 0000 4108          pea       @m68kde~2_104.L
00002542  4A1E      
00002544  4E92      4109          jsr       (A2)
00002546  584F      4110          addq.w    #4,A7
                    4111   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
00002548  2F39 0B00 4112          move.l    _PC.L,-(A7)
0000254C  0120      
0000254E  4879 0000 4113          pea       @m68kde~2_105.L
00002552  4A48      
00002554  4E92      4114          jsr       (A2)
00002556  504F      4115          addq.w    #8,A7
                    4116   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
00002558  4879 0000 4117          pea       @m68kde~2_106.L
0000255C  4A82      
0000255E  4E92      4118          jsr       (A2)
00002560  584F      4119          addq.w    #4,A7
                    4120   ; printf("\r\n  M            - Memory Examine and Change");
00002562  4879 0000 4121          pea       @m68kde~2_107.L
00002566  4ABA      
00002568  4E92      4122          jsr       (A2)
0000256A  584F      4123          addq.w    #4,A7
                    4124   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
0000256C  4879 0000 4125          pea       @m68kde~2_108.L
00002570  4AE8      
00002572  4E92      4126          jsr       (A2)
00002574  584F      4127          addq.w    #4,A7
                    4128   ; printf("\r\n  R            - Display 68000 Registers") ;
00002576  4879 0000 4129          pea       @m68kde~2_109.L
0000257A  4B22      
0000257C  4E92      4130          jsr       (A2)
0000257E  584F      4131          addq.w    #4,A7
                    4132   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
00002580  4879 0000 4133          pea       @m68kde~2_110.L
00002584  4B4E      
00002586  4E92      4134          jsr       (A2)
00002588  584F      4135          addq.w    #4,A7
                    4136   ; printf("\r\n  TM           - Test Memory") ;
0000258A  4879 0000 4137          pea       @m68kde~2_111.L
0000258E  4B80      
00002590  4E92      4138          jsr       (A2)
00002592  584F      4139          addq.w    #4,A7
                    4140   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
00002594  4879 0000 4141          pea       @m68kde~2_112.L
00002598  4BA0      
0000259A  4E92      4142          jsr       (A2)
0000259C  584F      4143          addq.w    #4,A7
                    4144   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
0000259E  4879 0000 4145          pea       @m68kde~2_113.L
000025A2  4BC8      
000025A4  4E92      4146          jsr       (A2)
000025A6  584F      4147          addq.w    #4,A7
                    4148   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
000025A8  4879 0000 4149          pea       @m68kde~2_114.L
000025AC  4BFE      
000025AE  4E92      4150          jsr       (A2)
000025B0  584F      4151          addq.w    #4,A7
                    4152   ; printf(banner) ;
000025B2  2F02      4153          move.l    D2,-(A7)
000025B4  4E92      4154          jsr       (A2)
000025B6  584F      4155          addq.w    #4,A7
000025B8  4CDF 0404 4156          movem.l   (A7)+,D2/A2
000025BC  4E75      4157          rts
                    4158   ; }
                    4159   ; void menu(void)
                    4160   ; {
                    4161   _menu:
000025BE  48E7 303C 4162          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000025C2  45F9 0000 4163          lea       _printf.L,A2
000025C6  3532      
000025C8  47F9 0B00 4164          lea       _Trace.L,A3
000025CC  00D8      
000025CE  49F9 0B00 4165          lea       _x.L,A4
000025D2  00C8      
000025D4  4BF9 0B00 4166          lea       _SR.L,A5
000025D8  012C      
                    4167   ; char c,c1 ;
                    4168   ; while(1)    {
                    4169   menu_1:
                    4170   ; FlushKeyboard() ;               // dump unread characters from keyboard
000025DA  4EB8 0BA6 4171          jsr       _FlushKeyboard
                    4172   ; printf("\r\n#") ;
000025DE  4879 0000 4173          pea       @m68kde~2_115.L
000025E2  4C36      
000025E4  4E92      4174          jsr       (A2)
000025E6  584F      4175          addq.w    #4,A7
                    4176   ; c = toupper(_getch());
000025E8  2F00      4177          move.l    D0,-(A7)
000025EA  4EB8 0B68 4178          jsr       __getch
000025EE  2200      4179          move.l    D0,D1
000025F0  201F      4180          move.l    (A7)+,D0
000025F2  2F01      4181          move.l    D1,-(A7)
000025F4  4EB9 0000 4182          jsr       _toupper
000025F8  3516      
000025FA  584F      4183          addq.w    #4,A7
000025FC  1400      4184          move.b    D0,D2
                    4185   ; if( c == (char)('L'))                  // load s record file
000025FE  0C02 004C 4186          cmp.b     #76,D2
00002602  6608      4187          bne.s     menu_4
                    4188   ; Load_SRecordFile() ;
00002604  4EB8 0E36 4189          jsr       _Load_SRecordFile
00002608  6000 021E 4190          bra       menu_46
                    4191   menu_4:
                    4192   ; else if( c == (char)('D'))             // dump memory
0000260C  0C02 0044 4193          cmp.b     #68,D2
00002610  6608      4194          bne.s     menu_6
                    4195   ; DumpMemory() ;
00002612  4EB8 0CCC 4196          jsr       _DumpMemory
00002616  6000 0210 4197          bra       menu_46
                    4198   menu_6:
                    4199   ; else if( c == (char)('E'))             // Enter String into memory
0000261A  0C02 0045 4200          cmp.b     #69,D2
0000261E  660A      4201          bne.s     menu_8
                    4202   ; EnterString() ;
00002620  4EB9 0000 4203          jsr       _EnterString
00002624  2970      
00002626  6000 0200 4204          bra       menu_46
                    4205   menu_8:
                    4206   ; else if( c == (char)('F'))             // fill memory
0000262A  0C02 0046 4207          cmp.b     #70,D2
0000262E  6608      4208          bne.s     menu_10
                    4209   ; FillMemory() ;
00002630  4EB8 0DBC 4210          jsr       _FillMemory
00002634  6000 01F2 4211          bra       menu_46
                    4212   menu_10:
                    4213   ; else if( c == (char)('G'))  {           // go user program
00002638  0C02 0047 4214          cmp.b     #71,D2
0000263C  6626      4215          bne.s     menu_12
                    4216   ; printf("\r\nProgram Running.....") ;
0000263E  4879 0000 4217          pea       @m68kde~2_116.L
00002642  4C3A      
00002644  4E92      4218          jsr       (A2)
00002646  584F      4219          addq.w    #4,A7
                    4220   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00002648  4879 0000 4221          pea       @m68kde~2_117.L
0000264C  4C52      
0000264E  4E92      4222          jsr       (A2)
00002650  584F      4223          addq.w    #4,A7
                    4224   ; GoFlag = 1 ;
00002652  23FC 0000 4225          move.l    #1,_GoFlag.L
00002656  0001 0B00 
0000265A  00DC      
                    4226   ; go() ;
0000265C  4EB8 08B8 4227          jsr       _go
00002660  6000 01C6 4228          bra       menu_46
                    4229   menu_12:
                    4230   ; }
                    4231   ; else if( c == (char)('M'))           // memory examine and modify
00002664  0C02 004D 4232          cmp.b     #77,D2
00002668  6608      4233          bne.s     menu_14
                    4234   ; MemoryChange() ;
0000266A  4EB8 0FC4 4235          jsr       _MemoryChange
0000266E  6000 01B8 4236          bra       menu_46
                    4237   menu_14:
                    4238   ; else if( c == (char)('P'))            // Program Flash Chip
00002672  0C02 0050 4239          cmp.b     #80,D2
00002676  6608      4240          bne.s     menu_16
                    4241   ; ProgramFlashChip() ;
00002678  4EB8 1446 4242          jsr       _ProgramFlashChip
0000267C  6000 01AA 4243          bra       menu_46
                    4244   menu_16:
                    4245   ; else if( c == (char)('C'))             // copy flash chip to ram and go
00002680  0C02 0043 4246          cmp.b     #67,D2
00002684  6608      4247          bne.s     menu_18
                    4248   ; LoadFromFlashChip();
00002686  4EB8 14DA 4249          jsr       _LoadFromFlashChip
0000268A  6000 019C 4250          bra       menu_46
                    4251   menu_18:
                    4252   ; else if( c == (char)('R'))             // dump registers
0000268E  0C02 0052 4253          cmp.b     #82,D2
00002692  6608      4254          bne.s     menu_20
                    4255   ; DumpRegisters() ;
00002694  4EB8 1526 4256          jsr       _DumpRegisters
00002698  6000 018E 4257          bra       menu_46
                    4258   menu_20:
                    4259   ; else if( c == (char)('.'))           // change registers
0000269C  0C02 002E 4260          cmp.b     #46,D2
000026A0  6608      4261          bne.s     menu_22
                    4262   ; ChangeRegisters() ;
000026A2  4EB8 1A18 4263          jsr       _ChangeRegisters
000026A6  6000 0180 4264          bra       menu_46
                    4265   menu_22:
                    4266   ; else if( c == (char)('B'))              // breakpoint command
000026AA  0C02 0042 4267          cmp.b     #66,D2
000026AE  6608      4268          bne.s     menu_24
                    4269   ; Breakpoint() ;
000026B0  4EB8 23EC 4270          jsr       _Breakpoint
000026B4  6000 0172 4271          bra       menu_46
                    4272   menu_24:
                    4273   ; else if( c == (char)('T'))  {          // Test command
000026B8  0C02 0054 4274          cmp.b     #84,D2
000026BC  6600 0046 4275          bne       menu_26
                    4276   ; c1 = toupper(_getch()) ;
000026C0  2F00      4277          move.l    D0,-(A7)
000026C2  4EB8 0B68 4278          jsr       __getch
000026C6  2200      4279          move.l    D0,D1
000026C8  201F      4280          move.l    (A7)+,D0
000026CA  2F01      4281          move.l    D1,-(A7)
000026CC  4EB9 0000 4282          jsr       _toupper
000026D0  3516      
000026D2  584F      4283          addq.w    #4,A7
000026D4  1600      4284          move.b    D0,D3
                    4285   ; if(c1 == (char)('M'))                    // memory test
000026D6  0C03 004D 4286          cmp.b     #77,D3
000026DA  6608      4287          bne.s     menu_28
                    4288   ; MemoryTest() ;
000026DC  4EB9 0000 4289          jsr       _MemoryTest
000026E0  29C0      
000026E2  601C      4290          bra.s     menu_33
                    4291   menu_28:
                    4292   ; else if( c1 == (char)('S'))              // Switch Test command
000026E4  0C03 0053 4293          cmp.b     #83,D3
000026E8  6606      4294          bne.s     menu_30
                    4295   ; SwitchTest() ;
000026EA  4EB8 0AA4 4296          jsr       _SwitchTest
000026EE  6010      4297          bra.s     menu_33
                    4298   menu_30:
                    4299   ; else if( c1 == (char)('D'))              // display Test command
000026F0  0C03 0044 4300          cmp.b     #68,D3
000026F4  6606      4301          bne.s     menu_32
                    4302   ; TestLEDS() ;
000026F6  4EB8 0A50 4303          jsr       _TestLEDS
000026FA  6004      4304          bra.s     menu_33
                    4305   menu_32:
                    4306   ; else
                    4307   ; UnknownCommand() ;
000026FC  4EB8 23C0 4308          jsr       _UnknownCommand
                    4309   menu_33:
00002700  6000 0126 4310          bra       menu_46
                    4311   menu_26:
                    4312   ; }
                    4313   ; else if( c == (char)(' ')) {             // Next instruction command
00002704  0C02 0020 4314          cmp.b     #32,D2
00002708  6636      4315          bne.s     menu_34
                    4316   ; DisableBreakPoints() ;
0000270A  4EB8 1FD0 4317          jsr       _DisableBreakPoints
                    4318   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
0000270E  2013      4319          move.l    (A3),D0
00002710  0C80 0000 4320          cmp.l     #1,D0
00002714  0001      
00002716  661A      4321          bne.s     menu_36
00002718  2039 0B00 4322          move.l    _GoFlag.L,D0
0000271C  00DC      
0000271E  0C80 0000 4323          cmp.l     #1,D0
00002722  0001      
00002724  660C      4324          bne.s     menu_36
                    4325   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
00002726  13FC 0001 4326          move.b    #1,4194314
0000272A  0040 000A 
                    4327   ; return ;
0000272E  6000 00FC 4328          bra       menu_38
                    4329   menu_36:
                    4330   ; }
                    4331   ; else
                    4332   ; printf("\r\nError: Press 'G' first to start program") ;
00002732  4879 0000 4333          pea       @m68kde~2_118.L
00002736  4C80      
00002738  4E92      4334          jsr       (A2)
0000273A  584F      4335          addq.w    #4,A7
0000273C  6000 00EA 4336          bra       menu_46
                    4337   menu_34:
                    4338   ; }
                    4339   ; else if( c == (char)('S')) {             // single step
00002740  0C02 0053 4340          cmp.b     #83,D2
00002744  6600 008C 4341          bne       menu_39
                    4342   ; if(Trace == 0) {
00002748  2013      4343          move.l    (A3),D0
0000274A  6600 0050 4344          bne       menu_41
                    4345   ; DisableBreakPoints() ;
0000274E  4EB8 1FD0 4346          jsr       _DisableBreakPoints
                    4347   ; printf("\r\nSingle Step  :[ON]") ;
00002752  4879 0000 4348          pea       @m68kde~2_119.L
00002756  4CAA      
00002758  4E92      4349          jsr       (A2)
0000275A  584F      4350          addq.w    #4,A7
                    4351   ; printf("\r\nBreak Points :[Disabled]") ;
0000275C  4879 0000 4352          pea       @m68kde~2_52.L
00002760  4348      
00002762  4E92      4353          jsr       (A2)
00002764  584F      4354          addq.w    #4,A7
                    4355   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
00002766  0055 8000 4356          or.w      #32768,(A5)
                    4357   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
0000276A  2F39 0B00 4358          move.l    _PC.L,-(A7)
0000276E  0120      
00002770  4879 0000 4359          pea       @m68kde~2_120.L
00002774  4CC0      
00002776  4E92      4360          jsr       (A2)
00002778  504F      4361          addq.w    #8,A7
                    4362   ; printf("\r\nPush <RESET Button> to Stop.....") ;
0000277A  4879 0000 4363          pea       @m68kde~2_121.L
0000277E  4CF4      
00002780  4E92      4364          jsr       (A2)
00002782  584F      4365          addq.w    #4,A7
                    4366   ; DumpRegisters() ;
00002784  4EB8 1526 4367          jsr       _DumpRegisters
                    4368   ; Trace = 1;
00002788  26BC 0000 4369          move.l    #1,(A3)
0000278C  0001      
                    4370   ; TraceException = 1;
0000278E  13FC 0001 4371          move.b    #1,4194314
00002792  0040 000A 
                    4372   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002796  28B8 0074 4373          move.l    116,(A4)
0000279A  6032      4374          bra.s     menu_42
                    4375   menu_41:
                    4376   ; }
                    4377   ; else {
                    4378   ; Trace = 0 ;
0000279C  4293      4379          clr.l     (A3)
                    4380   ; TraceException = 0 ;
0000279E  4239 0040 4381          clr.b     4194314
000027A2  000A      
                    4382   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000027A4  28B8 0074 4383          move.l    116,(A4)
                    4384   ; EnableBreakPoints() ;
000027A8  4EB8 2024 4385          jsr       _EnableBreakPoints
                    4386   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000027AC  0255 7FFF 4387          and.w     #32767,(A5)
                    4388   ; printf("\r\nSingle Step : [OFF]") ;
000027B0  4879 0000 4389          pea       @m68kde~2_122.L
000027B4  4D18      
000027B6  4E92      4390          jsr       (A2)
000027B8  584F      4391          addq.w    #4,A7
                    4392   ; printf("\r\nBreak Points :[Enabled]") ;
000027BA  4879 0000 4393          pea       @m68kde~2_123.L
000027BE  4D2E      
000027C0  4E92      4394          jsr       (A2)
000027C2  584F      4395          addq.w    #4,A7
                    4396   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
000027C4  4879 0000 4397          pea       @m68kde~2_124.L
000027C8  4D48      
000027CA  4E92      4398          jsr       (A2)
000027CC  584F      4399          addq.w    #4,A7
                    4400   menu_42:
000027CE  6000 0058 4401          bra       menu_46
                    4402   menu_39:
                    4403   ; }
                    4404   ; }
                    4405   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
000027D2  0C02 001B 4406          cmp.b     #27,D2
000027D6  6600 0040 4407          bne       menu_43
                    4408   ; Trace = 0;
000027DA  4293      4409          clr.l     (A3)
                    4410   ; TraceException = 0;
000027DC  4239 0040 4411          clr.b     4194314
000027E0  000A      
                    4412   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
000027E2  28B8 0074 4413          move.l    116,(A4)
                    4414   ; EnableBreakPoints() ;
000027E6  4EB8 2024 4415          jsr       _EnableBreakPoints
                    4416   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000027EA  0255 7FFF 4417          and.w     #32767,(A5)
                    4418   ; printf("\r\nSingle Step  :[OFF]") ;
000027EE  4879 0000 4419          pea       @m68kde~2_125.L
000027F2  4D72      
000027F4  4E92      4420          jsr       (A2)
000027F6  584F      4421          addq.w    #4,A7
                    4422   ; printf("\r\nBreak Points :[Enabled]");
000027F8  4879 0000 4423          pea       @m68kde~2_123.L
000027FC  4D2E      
000027FE  4E92      4424          jsr       (A2)
00002800  584F      4425          addq.w    #4,A7
                    4426   ; printf("\r\nProgram Running.....") ;
00002802  4879 0000 4427          pea       @m68kde~2_116.L
00002806  4C3A      
00002808  4E92      4428          jsr       (A2)
0000280A  584F      4429          addq.w    #4,A7
                    4430   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000280C  4879 0000 4431          pea       @m68kde~2_117.L
00002810  4C52      
00002812  4E92      4432          jsr       (A2)
00002814  584F      4433          addq.w    #4,A7
                    4434   ; return ;
00002816  6014      4435          bra.s     menu_38
                    4436   menu_43:
                    4437   ; }
                    4438   ; else if( c == (char)('W'))              // Watchpoint command
00002818  0C02 0057 4439          cmp.b     #87,D2
0000281C  6606      4440          bne.s     menu_45
                    4441   ; Watchpoint() ;
0000281E  4EB8 2468 4442          jsr       _Watchpoint
00002822  6004      4443          bra.s     menu_46
                    4444   menu_45:
                    4445   ; else
                    4446   ; UnknownCommand() ;
00002824  4EB8 23C0 4447          jsr       _UnknownCommand
                    4448   menu_46:
00002828  6000 FDB0 4449          bra       menu_1
                    4450   menu_38:
0000282C  4CDF 3C0C 4451          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00002830  4E75      4452          rts
                    4453   ; }
                    4454   ; }
                    4455   ; void PrintErrorMessageandAbort(char *string) {
                    4456   _PrintErrorMessageandAbort:
00002832  4E56 0000 4457          link      A6,#0
                    4458   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
00002836  4879 0000 4459          pea       @m68kde~2_126.L
0000283A  4D88      
0000283C  4EB9 0000 4460          jsr       _printf
00002840  3532      
00002842  584F      4461          addq.w    #4,A7
                    4462   ; printf("%s\r\n", string) ;
00002844  2F2E 0008 4463          move.l    8(A6),-(A7)
00002848  4879 0000 4464          pea       @m68kde~2_127.L
0000284C  4DA4      
0000284E  4EB9 0000 4465          jsr       _printf
00002852  3532      
00002854  504F      4466          addq.w    #8,A7
                    4467   ; menu() ;
00002856  4EB8 25BE 4468          jsr       _menu
0000285A  4E5E      4469          unlk      A6
0000285C  4E75      4470          rts
                    4471   ; }
                    4472   ; void IRQMessage(int level) {
                    4473   _IRQMessage:
0000285E  4E56 0000 4474          link      A6,#0
                    4475   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002862  4879 0000 4476          pea       @m68kde~2_128.L
00002866  4DAA      
00002868  4EB9 0000 4477          jsr       _printf
0000286C  3532      
0000286E  584F      4478          addq.w    #4,A7
                    4479   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
00002870  2F2E 0008 4480          move.l    8(A6),-(A7)
00002874  4879 0000 4481          pea       @m68kde~2_129.L
00002878  4DC2      
0000287A  4EB9 0000 4482          jsr       _printf
0000287E  3532      
00002880  504F      4483          addq.w    #8,A7
                    4484   ; menu() ;
00002882  4EB8 25BE 4485          jsr       _menu
00002886  4E5E      4486          unlk      A6
00002888  4E75      4487          rts
                    4488   ; }
                    4489   ; void UnhandledIRQ1(void) {
                    4490   _UnhandledIRQ1:
                    4491   ; IRQMessage(1);
0000288A  4878 0001 4492          pea       1
0000288E  4EB8 285E 4493          jsr       _IRQMessage
00002892  584F      4494          addq.w    #4,A7
00002894  4E75      4495          rts
                    4496   ; }
                    4497   ; void UnhandledIRQ2(void) {
                    4498   _UnhandledIRQ2:
                    4499   ; IRQMessage(2);
00002896  4878 0002 4500          pea       2
0000289A  4EB8 285E 4501          jsr       _IRQMessage
0000289E  584F      4502          addq.w    #4,A7
000028A0  4E75      4503          rts
                    4504   ; }
                    4505   ; void UnhandledIRQ3(void){
                    4506   _UnhandledIRQ3:
                    4507   ; IRQMessage(3);
000028A2  4878 0003 4508          pea       3
000028A6  4EB8 285E 4509          jsr       _IRQMessage
000028AA  584F      4510          addq.w    #4,A7
000028AC  4E75      4511          rts
                    4512   ; }
                    4513   ; void UnhandledIRQ4(void) {
                    4514   _UnhandledIRQ4:
                    4515   ; IRQMessage(4);
000028AE  4878 0004 4516          pea       4
000028B2  4EB8 285E 4517          jsr       _IRQMessage
000028B6  584F      4518          addq.w    #4,A7
000028B8  4E75      4519          rts
                    4520   ; }
                    4521   ; void UnhandledIRQ5(void) {
                    4522   _UnhandledIRQ5:
                    4523   ; IRQMessage(5);
000028BA  4878 0005 4524          pea       5
000028BE  4EB8 285E 4525          jsr       _IRQMessage
000028C2  584F      4526          addq.w    #4,A7
000028C4  4E75      4527          rts
                    4528   ; }
                    4529   ; void UnhandledIRQ6(void) {
                    4530   _UnhandledIRQ6:
                    4531   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
000028C6  4879 0000 4532          pea       @m68kde~2_130.L
000028CA  4DE6      
000028CC  4EB8 2832 4533          jsr       _PrintErrorMessageandAbort
000028D0  584F      4534          addq.w    #4,A7
                    4535   ; menu() ;
000028D2  4EB8 25BE 4536          jsr       _menu
000028D6  4E75      4537          rts
                    4538   ; }
                    4539   ; void UnhandledIRQ7(void) {
                    4540   _UnhandledIRQ7:
                    4541   ; IRQMessage(7);
000028D8  4878 0007 4542          pea       7
000028DC  4EB8 285E 4543          jsr       _IRQMessage
000028E0  584F      4544          addq.w    #4,A7
000028E2  4E75      4545          rts
                    4546   ; }
                    4547   ; void UnhandledTrap(void) {
                    4548   _UnhandledTrap:
                    4549   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
000028E4  4879 0000 4550          pea       @m68kde~2_131.L
000028E8  4E26      
000028EA  4EB8 2832 4551          jsr       _PrintErrorMessageandAbort
000028EE  584F      4552          addq.w    #4,A7
000028F0  4E75      4553          rts
                    4554   ; }
                    4555   ; void BusError() {
                    4556   _BusError:
                    4557   ; PrintErrorMessageandAbort("BUS Error!") ;
000028F2  4879 0000 4558          pea       @m68kde~2_132.L
000028F6  4E3C      
000028F8  4EB8 2832 4559          jsr       _PrintErrorMessageandAbort
000028FC  584F      4560          addq.w    #4,A7
000028FE  4E75      4561          rts
                    4562   ; }
                    4563   ; void AddressError() {
                    4564   _AddressError:
                    4565   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
00002900  4879 0000 4566          pea       @m68kde~2_133.L
00002904  4E48      
00002906  4EB8 2832 4567          jsr       _PrintErrorMessageandAbort
0000290A  584F      4568          addq.w    #4,A7
0000290C  4E75      4569          rts
                    4570   ; }
                    4571   ; void IllegalInstruction() {
                    4572   _IllegalInstruction:
                    4573   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
0000290E  4879 0000 4574          pea       @m68kde~2_134.L
00002912  4E58      
00002914  4EB8 2832 4575          jsr       _PrintErrorMessageandAbort
00002918  584F      4576          addq.w    #4,A7
0000291A  4E75      4577          rts
                    4578   ; }
                    4579   ; void Dividebyzero() {
                    4580   _Dividebyzero:
                    4581   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
0000291C  4879 0000 4582          pea       @m68kde~2_135.L
00002920  4E6C      
00002922  4EB8 2832 4583          jsr       _PrintErrorMessageandAbort
00002926  584F      4584          addq.w    #4,A7
00002928  4E75      4585          rts
                    4586   ; }
                    4587   ; void Check() {
                    4588   _Check:
                    4589   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
0000292A  4879 0000 4590          pea       @m68kde~2_136.L
0000292E  4E7C      
00002930  4EB8 2832 4591          jsr       _PrintErrorMessageandAbort
00002934  584F      4592          addq.w    #4,A7
00002936  4E75      4593          rts
                    4594   ; }
                    4595   ; void Trapv() {
                    4596   _Trapv:
                    4597   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
00002938  4879 0000 4598          pea       @m68kde~2_137.L
0000293C  4E8E      
0000293E  4EB8 2832 4599          jsr       _PrintErrorMessageandAbort
00002942  584F      4600          addq.w    #4,A7
00002944  4E75      4601          rts
                    4602   ; }
                    4603   ; void PrivError() {
                    4604   _PrivError:
                    4605   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
00002946  4879 0000 4606          pea       @m68kde~2_138.L
0000294A  4EA0      
0000294C  4EB8 2832 4607          jsr       _PrintErrorMessageandAbort
00002950  584F      4608          addq.w    #4,A7
00002952  4E75      4609          rts
                    4610   ; }
                    4611   ; void UnitIRQ() {
                    4612   _UnitIRQ:
                    4613   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
00002954  4879 0000 4614          pea       @m68kde~2_139.L
00002958  4EB4      
0000295A  4EB8 2832 4615          jsr       _PrintErrorMessageandAbort
0000295E  584F      4616          addq.w    #4,A7
00002960  4E75      4617          rts
                    4618   ; }
                    4619   ; void Spurious() {
                    4620   _Spurious:
                    4621   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
00002962  4879 0000 4622          pea       @m68kde~2_140.L
00002966  4EC6      
00002968  4EB8 2832 4623          jsr       _PrintErrorMessageandAbort
0000296C  584F      4624          addq.w    #4,A7
0000296E  4E75      4625          rts
                    4626   ; }
                    4627   ; void EnterString(void)
                    4628   ; {
                    4629   _EnterString:
00002970  4E56 FFFC 4630          link      A6,#-4
00002974  2F02      4631          move.l    D2,-(A7)
                    4632   ; unsigned char *Start;
                    4633   ; unsigned char c;
                    4634   ; printf("\r\nStart Address in Memory: ") ;
00002976  4879 0000 4635          pea       @m68kde~2_141.L
0000297A  4ED4      
0000297C  4EB9 0000 4636          jsr       _printf
00002980  3532      
00002982  584F      4637          addq.w    #4,A7
                    4638   ; Start = Get8HexDigits(0) ;
00002984  42A7      4639          clr.l     -(A7)
00002986  4EB8 0CA4 4640          jsr       _Get8HexDigits
0000298A  584F      4641          addq.w    #4,A7
0000298C  2400      4642          move.l    D0,D2
                    4643   ; printf("\r\nEnter String (ESC to end) :") ;
0000298E  4879 0000 4644          pea       @m68kde~2_142.L
00002992  4EF0      
00002994  4EB9 0000 4645          jsr       _printf
00002998  3532      
0000299A  584F      4646          addq.w    #4,A7
                    4647   ; while((c = getchar()) != 0x1b)
                    4648   EnterString_1:
0000299C  4EB9 0000 4649          jsr       _getch
000029A0  347A      
000029A2  1D40 FFFF 4650          move.b    D0,-1(A6)
000029A6  0C00 001B 4651          cmp.b     #27,D0
000029AA  670A      4652          beq.s     EnterString_3
                    4653   ; *Start++ = c ;
000029AC  2042      4654          move.l    D2,A0
000029AE  5282      4655          addq.l    #1,D2
000029B0  10AE FFFF 4656          move.b    -1(A6),(A0)
000029B4  60E6      4657          bra       EnterString_1
                    4658   EnterString_3:
                    4659   ; *Start = 0x00;  // terminate with a null
000029B6  2042      4660          move.l    D2,A0
000029B8  4210      4661          clr.b     (A0)
000029BA  241F      4662          move.l    (A7)+,D2
000029BC  4E5E      4663          unlk      A6
000029BE  4E75      4664          rts
                    4665   ; }
                    4666   ; void MemoryTest(void)
                    4667   ; {
                    4668   _MemoryTest:
000029C0  4E56 FFE8 4669          link      A6,#-24
000029C4  48E7 3F3C 4670          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000029C8  45F9 0000 4671          lea       _printf.L,A2
000029CC  3532      
000029CE  4BF9 0000 4672          lea       _getch.L,A5
000029D2  347A      
                    4673   ; unsigned char * RamWriter;
                    4674   ; unsigned char * start_address;
                    4675   ; unsigned char * end_address;
                    4676   ; unsigned int test_type;
                    4677   ; unsigned int user_data = 0;
000029D4  4283      4678          clr.l     D3
                    4679   ; unsigned char * current_address;
                    4680   ; unsigned char *  intermediate_address;
                    4681   ; int address_increment;
                    4682   ; unsigned int read_write_test;
                    4683   ; int mem_error_flag;
                    4684   ; int valid_start_address_flag = 0;
000029D6  42AE FFF0 4685          clr.l     -16(A6)
                    4686   ; int valid_end_address_flag = 0;
000029DA  42AE FFF4 4687          clr.l     -12(A6)
                    4688   ; int valid_user_data_flag = 0;
000029DE  42AE FFF8 4689          clr.l     -8(A6)
                    4690   ; int memory_type;
                    4691   ; //-----------------------Common Section-----------------------
                    4692   ; printf("\r\nWhich Memory do you want to test? Enter 0 for DRAM or 1 for SRAM");
000029E2  4879 0000 4693          pea       @m68kde~2_143.L
000029E6  4F0E      
000029E8  4E92      4694          jsr       (A2)
000029EA  584F      4695          addq.w    #4,A7
                    4696   ; memory_type = getchar() - '0';
000029EC  4E95      4697          jsr       (A5)
000029EE  0480 0000 4698          sub.l     #48,D0
000029F2  0030      
000029F4  2D40 FFFC 4699          move.l    D0,-4(A6)
                    4700   ; printf("\r\nWhich test do you want to perform? Enter '0' for Read or '1' for Write: "); //prompt user for read or write test
000029F8  4879 0000 4701          pea       @m68kde~2_144.L
000029FC  4F52      
000029FE  4E92      4702          jsr       (A2)
00002A00  584F      4703          addq.w    #4,A7
                    4704   ; read_write_test = getchar() - '0';
00002A02  4E95      4705          jsr       (A5)
00002A04  0480 0000 4706          sub.l     #48,D0
00002A08  0030      
00002A0A  2840      4707          move.l    D0,A4
                    4708   ; while(read_write_test < 0 | read_write_test > 1){
                    4709   MemoryTest_1:
00002A0C  200C      4710          move.l    A4,D0
00002A0E  0C80 0000 4711          cmp.l     #0,D0
00002A12  0000      
00002A14  6404      4712          bhs.s     MemoryTest_4
00002A16  7001      4713          moveq     #1,D0
00002A18  6002      4714          bra.s     MemoryTest_5
                    4715   MemoryTest_4:
00002A1A  4280      4716          clr.l     D0
                    4717   MemoryTest_5:
00002A1C  220C      4718          move.l    A4,D1
00002A1E  0C81 0000 4719          cmp.l     #1,D1
00002A22  0001      
00002A24  6304      4720          bls.s     MemoryTest_6
00002A26  7201      4721          moveq     #1,D1
00002A28  6002      4722          bra.s     MemoryTest_7
                    4723   MemoryTest_6:
00002A2A  4281      4724          clr.l     D1
                    4725   MemoryTest_7:
00002A2C  8081      4726          or.l      D1,D0
00002A2E  6720      4727          beq.s     MemoryTest_3
                    4728   ; printf("\r\nError: Invalid Input"); //prompt user for read or write test
00002A30  4879 0000 4729          pea       @m68kde~2_145.L
00002A34  4F9E      
00002A36  4E92      4730          jsr       (A2)
00002A38  584F      4731          addq.w    #4,A7
                    4732   ; printf("\r\nWhich test do you want to perform? Enter '0' for Read or '1' for Write: "); //prompt user for read or write test
00002A3A  4879 0000 4733          pea       @m68kde~2_144.L
00002A3E  4F52      
00002A40  4E92      4734          jsr       (A2)
00002A42  584F      4735          addq.w    #4,A7
                    4736   ; read_write_test = getchar() - '0';
00002A44  4E95      4737          jsr       (A5)
00002A46  0480 0000 4738          sub.l     #48,D0
00002A4A  0030      
00002A4C  2840      4739          move.l    D0,A4
00002A4E  60BC      4740          bra       MemoryTest_1
                    4741   MemoryTest_3:
                    4742   ; }
                    4743   ; printf("\r\nSpecify the memory test type. Input '0' for Bytes, '1' for Word, and '2' for Long Word: "); //prompt user for test type
00002A50  4879 0000 4744          pea       @m68kde~2_146.L
00002A54  4FB6      
00002A56  4E92      4745          jsr       (A2)
00002A58  584F      4746          addq.w    #4,A7
                    4747   ; test_type = getchar() - '0';
00002A5A  4E95      4748          jsr       (A5)
00002A5C  0480 0000 4749          sub.l     #48,D0
00002A60  0030      
00002A62  2800      4750          move.l    D0,D4
                    4751   ; while (test_type < 0 | test_type > 2) // check for valid input
                    4752   MemoryTest_8:
00002A64  0C84 0000 4753          cmp.l     #0,D4
00002A68  0000      
00002A6A  6404      4754          bhs.s     MemoryTest_11
00002A6C  7001      4755          moveq     #1,D0
00002A6E  6002      4756          bra.s     MemoryTest_12
                    4757   MemoryTest_11:
00002A70  4280      4758          clr.l     D0
                    4759   MemoryTest_12:
00002A72  0C84 0000 4760          cmp.l     #2,D4
00002A76  0002      
00002A78  6304      4761          bls.s     MemoryTest_13
00002A7A  7201      4762          moveq     #1,D1
00002A7C  6002      4763          bra.s     MemoryTest_14
                    4764   MemoryTest_13:
00002A7E  4281      4765          clr.l     D1
                    4766   MemoryTest_14:
00002A80  8081      4767          or.l      D1,D0
00002A82  6720      4768          beq.s     MemoryTest_10
                    4769   ; {
                    4770   ; printf("\r\nError: Invalid Input!");
00002A84  4879 0000 4771          pea       @m68kde~2_147.L
00002A88  5012      
00002A8A  4E92      4772          jsr       (A2)
00002A8C  584F      4773          addq.w    #4,A7
                    4774   ; printf("\r\nSpecify the memory test type. Input '0' for Bytes, '1' for Word, and '2' for Long Word: ");
00002A8E  4879 0000 4775          pea       @m68kde~2_146.L
00002A92  4FB6      
00002A94  4E92      4776          jsr       (A2)
00002A96  584F      4777          addq.w    #4,A7
                    4778   ; test_type = getchar() - '0';
00002A98  4E95      4779          jsr       (A5)
00002A9A  0480 0000 4780          sub.l     #48,D0
00002A9E  0030      
00002AA0  2800      4781          move.l    D0,D4
00002AA2  60C0      4782          bra       MemoryTest_8
                    4783   MemoryTest_10:
                    4784   ; }
                    4785   ; //***************Get Addresses***************
                    4786   ; while(!valid_start_address_flag){
                    4787   MemoryTest_15:
00002AA4  4AAE FFF0 4788          tst.l     -16(A6)
00002AA8  6600 00A0 4789          bne       MemoryTest_17
                    4790   ; printf("\r\nProvide a start address for your data: "); //SRAM
00002AAC  4879 0000 4791          pea       @m68kde~2_148.L
00002AB0  502A      
00002AB2  4E92      4792          jsr       (A2)
00002AB4  584F      4793          addq.w    #4,A7
                    4794   ; start_address = Get8HexDigits(0);
00002AB6  42A7      4795          clr.l     -(A7)
00002AB8  4EB8 0CA4 4796          jsr       _Get8HexDigits
00002ABC  584F      4797          addq.w    #4,A7
00002ABE  2A00      4798          move.l    D0,D5
                    4799   ; if(start_address < 0xF0000000 || start_address > 0xF003FFFF) //protect data leak into other memories
00002AC0  0C85 F000 4800          cmp.l     #-268435456,D5
00002AC4  0000      
00002AC6  6508      4801          blo.s     MemoryTest_20
00002AC8  0C85 F003 4802          cmp.l     #-268173313,D5
00002ACC  FFFF      
00002ACE  631A      4803          bls.s     MemoryTest_21
                    4804   MemoryTest_20:
                    4805   ; {
                    4806   ; if(memory_type == 1){
00002AD0  202E FFFC 4807          move.l    -4(A6),D0
00002AD4  0C80 0000 4808          cmp.l     #1,D0
00002AD8  0001      
00002ADA  660E      4809          bne.s     MemoryTest_21
                    4810   ; printf("\r\nError: Invalid address! Start address for SRAM cannot be less than F0000000 or greater than 0xF003FFFF");
00002ADC  4879 0000 4811          pea       @m68kde~2_149.L
00002AE0  5054      
00002AE2  4E92      4812          jsr       (A2)
00002AE4  584F      4813          addq.w    #4,A7
                    4814   ; continue;
00002AE6  6000 005E 4815          bra       MemoryTest_29
                    4816   MemoryTest_21:
                    4817   ; }
                    4818   ; }
                    4819   ; if(start_address < 0x09000000 || start_address > 0x097FFFFF) //DRAM
00002AEA  0C85 0900 4820          cmp.l     #150994944,D5
00002AEE  0000      
00002AF0  6508      4821          blo.s     MemoryTest_25
00002AF2  0C85 097F 4822          cmp.l     #159383551,D5
00002AF6  FFFF      
00002AF8  6314      4823          bls.s     MemoryTest_26
                    4824   MemoryTest_25:
                    4825   ; {
                    4826   ; if(memory_type == 0){
00002AFA  202E FFFC 4827          move.l    -4(A6),D0
00002AFE  660E      4828          bne.s     MemoryTest_26
                    4829   ; printf("\r\nError: Invalid address! Start address for DRAM cannot be less than 09000000 or greater than 097FFFFF");
00002B00  4879 0000 4830          pea       @m68kde~2_150.L
00002B04  50BE      
00002B06  4E92      4831          jsr       (A2)
00002B08  584F      4832          addq.w    #4,A7
                    4833   ; continue;
00002B0A  6000 003A 4834          bra       MemoryTest_29
                    4835   MemoryTest_26:
                    4836   ; }
                    4837   ; }
                    4838   ; if (test_type != 0) // check that we're aligned properly for start address for word and long word
00002B0E  4A84      4839          tst.l     D4
00002B10  672C      4840          beq.s     MemoryTest_28
                    4841   ; {
                    4842   ; if ((unsigned int)start_address % 2) // odd number address
00002B12  2F05      4843          move.l    D5,-(A7)
00002B14  4878 0002 4844          pea       2
00002B18  4EB9 0000 4845          jsr       ULDIV
00002B1C  3370      
00002B1E  202F 0004 4846          move.l    4(A7),D0
00002B22  504F      4847          addq.w    #8,A7
00002B24  4A80      4848          tst.l     D0
00002B26  670C      4849          beq.s     MemoryTest_30
                    4850   ; {
                    4851   ; printf("\r\nOdd address is not allowed for word or long word!");
00002B28  4879 0000 4852          pea       @m68kde~2_151.L
00002B2C  5126      
00002B2E  4E92      4853          jsr       (A2)
00002B30  584F      4854          addq.w    #4,A7
                    4855   ; continue;
00002B32  6012      4856          bra.s     MemoryTest_29
                    4857   MemoryTest_30:
                    4858   ; }
                    4859   ; else{
                    4860   ; valid_start_address_flag = 1;
00002B34  2D7C 0000 4861          move.l    #1,-16(A6)
00002B38  0001 FFF0 
00002B3C  6008      4862          bra.s     MemoryTest_29
                    4863   MemoryTest_28:
                    4864   ; }
                    4865   ; }
                    4866   ; else{
                    4867   ; valid_start_address_flag = 1;
00002B3E  2D7C 0000 4868          move.l    #1,-16(A6)
00002B42  0001 FFF0 
                    4869   MemoryTest_29:
00002B46  6000 FF5C 4870          bra       MemoryTest_15
                    4871   MemoryTest_17:
                    4872   ; }
                    4873   ; }
                    4874   ; printf("\r\nYou have entered %x for the start address", start_address);
00002B4A  2F05      4875          move.l    D5,-(A7)
00002B4C  4879 0000 4876          pea       @m68kde~2_152.L
00002B50  515A      
00002B52  4E92      4877          jsr       (A2)
00002B54  504F      4878          addq.w    #8,A7
                    4879   ; while(!valid_end_address_flag){
                    4880   MemoryTest_32:
00002B56  4AAE FFF4 4881          tst.l     -12(A6)
00002B5A  6600 00F0 4882          bne       MemoryTest_34
                    4883   ; printf("\r\nProvide an end address for your data: "); //protect data leak into other memories
00002B5E  4879 0000 4884          pea       @m68kde~2_153.L
00002B62  5186      
00002B64  4E92      4885          jsr       (A2)
00002B66  584F      4886          addq.w    #4,A7
                    4887   ; end_address = Get8HexDigits(0); //protect data leak into other memories
00002B68  42A7      4888          clr.l     -(A7)
00002B6A  4EB8 0CA4 4889          jsr       _Get8HexDigits
00002B6E  584F      4890          addq.w    #4,A7
00002B70  2C00      4891          move.l    D0,D6
                    4892   ; if(end_address <= start_address || end_address > 0xF0040000)
00002B72  BC85      4893          cmp.l     D5,D6
00002B74  6308      4894          bls.s     MemoryTest_37
00002B76  0C86 F004 4895          cmp.l     #-268173312,D6
00002B7A  0000      
00002B7C  631A      4896          bls.s     MemoryTest_38
                    4897   MemoryTest_37:
                    4898   ; {
                    4899   ; if(memory_type == 1)
00002B7E  202E FFFC 4900          move.l    -4(A6),D0
00002B82  0C80 0000 4901          cmp.l     #1,D0
00002B86  0001      
00002B88  660E      4902          bne.s     MemoryTest_38
                    4903   ; {
                    4904   ; printf("\r\nError: Invalid address! End address for SRAM should not be less than or equal to start address or greater than F003FFFF");
00002B8A  4879 0000 4905          pea       @m68kde~2_154.L
00002B8E  51B0      
00002B90  4E92      4906          jsr       (A2)
00002B92  584F      4907          addq.w    #4,A7
                    4908   ; continue;
00002B94  6000 00B2 4909          bra       MemoryTest_52
                    4910   MemoryTest_38:
                    4911   ; }
                    4912   ; }
                    4913   ; if(end_address <= start_address || end_address > 0x09800000)
00002B98  BC85      4914          cmp.l     D5,D6
00002B9A  6308      4915          bls.s     MemoryTest_42
00002B9C  0C86 0980 4916          cmp.l     #159383552,D6
00002BA0  0000      
00002BA2  6314      4917          bls.s     MemoryTest_43
                    4918   MemoryTest_42:
                    4919   ; {
                    4920   ; if(memory_type == 0)
00002BA4  202E FFFC 4921          move.l    -4(A6),D0
00002BA8  660E      4922          bne.s     MemoryTest_43
                    4923   ; {
                    4924   ; printf("\r\nError: Invalid address! End address for DRAM should not be less than or equal to start address or greater than 097FFFFF");
00002BAA  4879 0000 4925          pea       @m68kde~2_155.L
00002BAE  522A      
00002BB0  4E92      4926          jsr       (A2)
00002BB2  584F      4927          addq.w    #4,A7
                    4928   ; continue;
00002BB4  6000 0092 4929          bra       MemoryTest_52
                    4930   MemoryTest_43:
                    4931   ; }
                    4932   ; }
                    4933   ; if(test_type == 0){
00002BB8  4A84      4934          tst.l     D4
00002BBA  660C      4935          bne.s     MemoryTest_45
                    4936   ; valid_end_address_flag = 1;
00002BBC  2D7C 0000 4937          move.l    #1,-12(A6)
00002BC0  0001 FFF4 
00002BC4  6000 0082 4938          bra       MemoryTest_52
                    4939   MemoryTest_45:
                    4940   ; }
                    4941   ; else{
                    4942   ; if((unsigned int)end_address % 2) // check for odd number address
00002BC8  2F06      4943          move.l    D6,-(A7)
00002BCA  4878 0002 4944          pea       2
00002BCE  4EB9 0000 4945          jsr       ULDIV
00002BD2  3370      
00002BD4  202F 0004 4946          move.l    4(A7),D0
00002BD8  504F      4947          addq.w    #8,A7
00002BDA  4A80      4948          tst.l     D0
00002BDC  670E      4949          beq.s     MemoryTest_47
                    4950   ; {
                    4951   ; printf("\r\nOdd address is not allowed for word or long word!");
00002BDE  4879 0000 4952          pea       @m68kde~2_151.L
00002BE2  5126      
00002BE4  4E92      4953          jsr       (A2)
00002BE6  584F      4954          addq.w    #4,A7
                    4955   ; continue;
00002BE8  6000 005E 4956          bra       MemoryTest_52
                    4957   MemoryTest_47:
                    4958   ; }
                    4959   ; if(!((end_address - start_address) < 2) && test_type == 1){ //check if selections can fit data
00002BEC  2006      4960          move.l    D6,D0
00002BEE  9085      4961          sub.l     D5,D0
00002BF0  0C80 0000 4962          cmp.l     #2,D0
00002BF4  0002      
00002BF6  6D14      4963          blt.s     MemoryTest_49
00002BF8  0C84 0000 4964          cmp.l     #1,D4
00002BFC  0001      
00002BFE  660C      4965          bne.s     MemoryTest_49
                    4966   ; valid_end_address_flag = 1;
00002C00  2D7C 0000 4967          move.l    #1,-12(A6)
00002C04  0001 FFF4 
00002C08  6000 003E 4968          bra       MemoryTest_52
                    4969   MemoryTest_49:
                    4970   ; }
                    4971   ; else if(!((end_address - start_address) < 4) && test_type == 2){ //check if selections can fit data
00002C0C  2006      4972          move.l    D6,D0
00002C0E  9085      4973          sub.l     D5,D0
00002C10  0C80 0000 4974          cmp.l     #4,D0
00002C14  0004      
00002C16  6D12      4975          blt.s     MemoryTest_51
00002C18  0C84 0000 4976          cmp.l     #2,D4
00002C1C  0002      
00002C1E  660A      4977          bne.s     MemoryTest_51
                    4978   ; valid_end_address_flag = 1;
00002C20  2D7C 0000 4979          move.l    #1,-12(A6)
00002C24  0001 FFF4 
00002C28  601E      4980          bra.s     MemoryTest_52
                    4981   MemoryTest_51:
                    4982   ; }
                    4983   ; else{
                    4984   ; if(read_write_test){ //check if write operation can be performed
00002C2A  200C      4985          move.l    A4,D0
00002C2C  670C      4986          beq.s     MemoryTest_53
                    4987   ; printf("\r\nError: Data cannot be fitted in given address range");
00002C2E  4879 0000 4988          pea       @m68kde~2_156.L
00002C32  52A4      
00002C34  4E92      4989          jsr       (A2)
00002C36  584F      4990          addq.w    #4,A7
00002C38  600A      4991          bra.s     MemoryTest_54
                    4992   MemoryTest_53:
                    4993   ; }
                    4994   ; else{ //check if read operation can be performed
                    4995   ; printf("\r\nError: Not enough address range to read the data");
00002C3A  4879 0000 4996          pea       @m68kde~2_157.L
00002C3E  52DA      
00002C40  4E92      4997          jsr       (A2)
00002C42  584F      4998          addq.w    #4,A7
                    4999   MemoryTest_54:
                    5000   ; }
                    5001   ; continue;
00002C44  6000 0002 5002          bra       MemoryTest_52
                    5003   MemoryTest_52:
00002C48  6000 FF0C 5004          bra       MemoryTest_32
                    5005   MemoryTest_34:
                    5006   ; }
                    5007   ; }
                    5008   ; }
                    5009   ; switch (test_type) { // check if byte, word, or long word
00002C4C  0C84 0000 5010          cmp.l     #1,D4
00002C50  0001      
00002C52  6718      5011          beq.s     MemoryTest_58
00002C54  6206      5012          bhi.s     MemoryTest_61
00002C56  4A84      5013          tst.l     D4
00002C58  670C      5014          beq.s     MemoryTest_57
00002C5A  601C      5015          bra.s     MemoryTest_55
                    5016   MemoryTest_61:
00002C5C  0C84 0000 5017          cmp.l     #2,D4
00002C60  0002      
00002C62  670E      5018          beq.s     MemoryTest_59
00002C64  6012      5019          bra.s     MemoryTest_55
                    5020   MemoryTest_57:
                    5021   ; case 0:
                    5022   ; address_increment = 1; // byte
00002C66  367C 0001 5023          move.w    #1,A3
                    5024   ; break;
00002C6A  601A      5025          bra.s     MemoryTest_56
                    5026   MemoryTest_58:
                    5027   ; case 1:
                    5028   ; address_increment = 2; // word
00002C6C  367C 0002 5029          move.w    #2,A3
                    5030   ; break;
00002C70  6014      5031          bra.s     MemoryTest_56
                    5032   MemoryTest_59:
                    5033   ; case 2:
                    5034   ; address_increment = 4; // long word
00002C72  367C 0004 5035          move.w    #4,A3
                    5036   ; break;
00002C76  600E      5037          bra.s     MemoryTest_56
                    5038   MemoryTest_55:
                    5039   ; default:
                    5040   ; printf("\r\nWe are not supposed to get here! Default is increment by 1 byte.");
00002C78  4879 0000 5041          pea       @m68kde~2_158.L
00002C7C  530E      
00002C7E  4E92      5042          jsr       (A2)
00002C80  584F      5043          addq.w    #4,A7
                    5044   ; address_increment = 1; // should never get here: fall-through case: byte
00002C82  367C 0001 5045          move.w    #1,A3
                    5046   MemoryTest_56:
                    5047   ; }
                    5048   ; //-----------------------Read Section-----------------------
                    5049   ; if(!read_write_test){
00002C86  200C      5050          move.l    A4,D0
00002C88  6600 00C8 5051          bne       MemoryTest_62
                    5052   ; for(current_address = start_address; current_address < end_address; current_address += address_increment){
00002C8C  2405      5053          move.l    D5,D2
                    5054   MemoryTest_64:
00002C8E  B486      5055          cmp.l     D6,D2
00002C90  6400 00B2 5056          bhs       MemoryTest_66
                    5057   ; if(test_type == 0){ //read a byte
00002C94  4A84      5058          tst.l     D4
00002C96  661E      5059          bne.s     MemoryTest_67
                    5060   ; printf("\r\nData at location %x: %02x", current_address, *current_address);
00002C98  2042      5061          move.l    D2,A0
00002C9A  1210      5062          move.b    (A0),D1
00002C9C  C2BC 0000 5063          and.l     #255,D1
00002CA0  00FF      
00002CA2  2F01      5064          move.l    D1,-(A7)
00002CA4  2F02      5065          move.l    D2,-(A7)
00002CA6  4879 0000 5066          pea       @m68kde~2_159.L
00002CAA  5352      
00002CAC  4E92      5067          jsr       (A2)
00002CAE  DEFC 000C 5068          add.w     #12,A7
00002CB2  6000 008A 5069          bra       MemoryTest_70
                    5070   MemoryTest_67:
                    5071   ; }
                    5072   ; else if(test_type == 1){//read a word
00002CB6  0C84 0000 5073          cmp.l     #1,D4
00002CBA  0001      
00002CBC  662C      5074          bne.s     MemoryTest_69
                    5075   ; printf("\r\nWord at location %x: %02x%02x", current_address, *current_address, *(current_address+1));
00002CBE  2042      5076          move.l    D2,A0
00002CC0  1228 0001 5077          move.b    1(A0),D1
00002CC4  C2BC 0000 5078          and.l     #255,D1
00002CC8  00FF      
00002CCA  2F01      5079          move.l    D1,-(A7)
00002CCC  2042      5080          move.l    D2,A0
00002CCE  1210      5081          move.b    (A0),D1
00002CD0  C2BC 0000 5082          and.l     #255,D1
00002CD4  00FF      
00002CD6  2F01      5083          move.l    D1,-(A7)
00002CD8  2F02      5084          move.l    D2,-(A7)
00002CDA  4879 0000 5085          pea       @m68kde~2_160.L
00002CDE  536E      
00002CE0  4E92      5086          jsr       (A2)
00002CE2  DEFC 0010 5087          add.w     #16,A7
00002CE6  6000 0056 5088          bra       MemoryTest_70
                    5089   MemoryTest_69:
                    5090   ; }
                    5091   ; else{//read a long word
                    5092   ; if( (end_address - current_address) < 3){
00002CEA  2006      5093          move.l    D6,D0
00002CEC  9082      5094          sub.l     D2,D0
00002CEE  0C80 0000 5095          cmp.l     #3,D0
00002CF2  0003      
00002CF4  6C04      5096          bge.s     MemoryTest_71
                    5097   ; break;
00002CF6  6000 004C 5098          bra       MemoryTest_66
                    5099   MemoryTest_71:
                    5100   ; }
                    5101   ; printf("\r\nLong word at location %x: %02x%02x%02x%02x", current_address, *current_address, *(current_address+1), *(current_address+2), *(current_address+3));
00002CFA  2042      5102          move.l    D2,A0
00002CFC  1228 0003 5103          move.b    3(A0),D1
00002D00  C2BC 0000 5104          and.l     #255,D1
00002D04  00FF      
00002D06  2F01      5105          move.l    D1,-(A7)
00002D08  2042      5106          move.l    D2,A0
00002D0A  1228 0002 5107          move.b    2(A0),D1
00002D0E  C2BC 0000 5108          and.l     #255,D1
00002D12  00FF      
00002D14  2F01      5109          move.l    D1,-(A7)
00002D16  2042      5110          move.l    D2,A0
00002D18  1228 0001 5111          move.b    1(A0),D1
00002D1C  C2BC 0000 5112          and.l     #255,D1
00002D20  00FF      
00002D22  2F01      5113          move.l    D1,-(A7)
00002D24  2042      5114          move.l    D2,A0
00002D26  1210      5115          move.b    (A0),D1
00002D28  C2BC 0000 5116          and.l     #255,D1
00002D2C  00FF      
00002D2E  2F01      5117          move.l    D1,-(A7)
00002D30  2F02      5118          move.l    D2,-(A7)
00002D32  4879 0000 5119          pea       @m68kde~2_161.L
00002D36  538E      
00002D38  4E92      5120          jsr       (A2)
00002D3A  DEFC 0018 5121          add.w     #24,A7
                    5122   MemoryTest_70:
00002D3E  D48B      5123          add.l     A3,D2
00002D40  6000 FF4C 5124          bra       MemoryTest_64
                    5125   MemoryTest_66:
                    5126   ; }
                    5127   ; }
                    5128   ; printf("\r\nFinished reading");
00002D44  4879 0000 5129          pea       @m68kde~2_162.L
00002D48  53BC      
00002D4A  4E92      5130          jsr       (A2)
00002D4C  584F      5131          addq.w    #4,A7
00002D4E  6000 034A 5132          bra       MemoryTest_107
                    5133   MemoryTest_62:
                    5134   ; }
                    5135   ; //-----------------------Write Section-----------------------
                    5136   ; else{
                    5137   ; // 1 Byte
                    5138   ; while(!valid_user_data_flag){
                    5139   MemoryTest_73:
00002D52  4AAE FFF8 5140          tst.l     -8(A6)
00002D56  6600 006A 5141          bne       MemoryTest_75
                    5142   ; if(test_type == 0){ // acquire byte user data
00002D5A  4A84      5143          tst.l     D4
00002D5C  6620      5144          bne.s     MemoryTest_76
                    5145   ; printf("\r\nEnter the data in format XX: ");
00002D5E  4879 0000 5146          pea       @m68kde~2_163.L
00002D62  53D0      
00002D64  4E92      5147          jsr       (A2)
00002D66  584F      5148          addq.w    #4,A7
                    5149   ; user_data = Get2HexDigits(0);
00002D68  42A7      5150          clr.l     -(A7)
00002D6A  4EB8 0C04 5151          jsr       _Get2HexDigits
00002D6E  584F      5152          addq.w    #4,A7
00002D70  2600      5153          move.l    D0,D3
                    5154   ; valid_user_data_flag = 1;
00002D72  2D7C 0000 5155          move.l    #1,-8(A6)
00002D76  0001 FFF8 
00002D7A  6000 0044 5156          bra       MemoryTest_79
                    5157   MemoryTest_76:
                    5158   ; }
                    5159   ; else if(test_type == 1){ // acquire word user data
00002D7E  0C84 0000 5160          cmp.l     #1,D4
00002D82  0001      
00002D84  661E      5161          bne.s     MemoryTest_78
                    5162   ; printf("\r\nEnter the data in format XXXX: ");
00002D86  4879 0000 5163          pea       @m68kde~2_164.L
00002D8A  53F0      
00002D8C  4E92      5164          jsr       (A2)
00002D8E  584F      5165          addq.w    #4,A7
                    5166   ; user_data = Get4HexDigits(0);
00002D90  42A7      5167          clr.l     -(A7)
00002D92  4EB8 0C58 5168          jsr       _Get4HexDigits
00002D96  584F      5169          addq.w    #4,A7
00002D98  2600      5170          move.l    D0,D3
                    5171   ; valid_user_data_flag = 1;
00002D9A  2D7C 0000 5172          move.l    #1,-8(A6)
00002D9E  0001 FFF8 
00002DA2  601C      5173          bra.s     MemoryTest_79
                    5174   MemoryTest_78:
                    5175   ; }
                    5176   ; else{ // acquire long word user data
                    5177   ; printf("\r\nEnter the data in format XXXXXXXX: ");
00002DA4  4879 0000 5178          pea       @m68kde~2_165.L
00002DA8  5412      
00002DAA  4E92      5179          jsr       (A2)
00002DAC  584F      5180          addq.w    #4,A7
                    5181   ; user_data = Get8HexDigits(0);
00002DAE  42A7      5182          clr.l     -(A7)
00002DB0  4EB8 0CA4 5183          jsr       _Get8HexDigits
00002DB4  584F      5184          addq.w    #4,A7
00002DB6  2600      5185          move.l    D0,D3
                    5186   ; valid_user_data_flag = 1;
00002DB8  2D7C 0000 5187          move.l    #1,-8(A6)
00002DBC  0001 FFF8 
                    5188   MemoryTest_79:
00002DC0  6090      5189          bra       MemoryTest_73
                    5190   MemoryTest_75:
                    5191   ; }
                    5192   ; }
                    5193   ; // word XX_XX --> upper 8 bits ((0xFFFF & input) >> 8), shift address by 1, then lower 8 bits (0x00FF & input)
                    5194   ; // long word --> upper 8, shift by 1, next 8, shift by 1, next 8, shift by 1, write least significant 8, then done.
                    5195   ; mem_error_flag = 0;
00002DC2  7E00      5196          moveq     #0,D7
                    5197   ; for(current_address = start_address; current_address < end_address; current_address += address_increment){
00002DC4  2405      5198          move.l    D5,D2
                    5199   MemoryTest_80:
00002DC6  B486      5200          cmp.l     D6,D2
00002DC8  6400 02C0 5201          bhs       MemoryTest_82
                    5202   ; if((current_address - start_address)%10000 == 0){
00002DCC  2002      5203          move.l    D2,D0
00002DCE  9085      5204          sub.l     D5,D0
00002DD0  2F00      5205          move.l    D0,-(A7)
00002DD2  4878 2710 5206          pea       10000
00002DD6  4EB9 0000 5207          jsr       LDIV
00002DDA  3382      
00002DDC  202F 0004 5208          move.l    4(A7),D0
00002DE0  504F      5209          addq.w    #8,A7
00002DE2  4A80      5210          tst.l     D0
00002DE4  6610      5211          bne.s     MemoryTest_83
                    5212   ; printf("\r\nWriting %x at location %x", user_data, current_address); // Reports the progress every 10k (0x2800) locations
00002DE6  2F02      5213          move.l    D2,-(A7)
00002DE8  2F03      5214          move.l    D3,-(A7)
00002DEA  4879 0000 5215          pea       @m68kde~2_166.L
00002DEE  5438      
00002DF0  4E92      5216          jsr       (A2)
00002DF2  DEFC 000C 5217          add.w     #12,A7
                    5218   MemoryTest_83:
                    5219   ; }
                    5220   ; if(test_type == 0){
00002DF6  4A84      5221          tst.l     D4
00002DF8  662C      5222          bne.s     MemoryTest_85
                    5223   ; *(current_address) = user_data;
00002DFA  2042      5224          move.l    D2,A0
00002DFC  1083      5225          move.b    D3,(A0)
                    5226   ; if (*(current_address) != user_data) //read the data and confirm if it is written correctly
00002DFE  2042      5227          move.l    D2,A0
00002E00  1010      5228          move.b    (A0),D0
00002E02  C0BC 0000 5229          and.l     #255,D0
00002E06  00FF      
00002E08  B083      5230          cmp.l     D3,D0
00002E0A  6716      5231          beq.s     MemoryTest_87
                    5232   ; {
                    5233   ; printf("\r\nError writing %x to address %x", user_data, current_address);
00002E0C  2F02      5234          move.l    D2,-(A7)
00002E0E  2F03      5235          move.l    D3,-(A7)
00002E10  4879 0000 5236          pea       @m68kde~2_167.L
00002E14  5454      
00002E16  4E92      5237          jsr       (A2)
00002E18  DEFC 000C 5238          add.w     #12,A7
                    5239   ; mem_error_flag = 1;
00002E1C  7E01      5240          moveq     #1,D7
                    5241   ; break;
00002E1E  6000 026A 5242          bra       MemoryTest_82
                    5243   MemoryTest_87:
00002E22  6000 0260 5244          bra       MemoryTest_105
                    5245   MemoryTest_85:
                    5246   ; }
                    5247   ; }
                    5248   ; else if(test_type == 1){
00002E26  0C84 0000 5249          cmp.l     #1,D4
00002E2A  0001      
00002E2C  6600 00A0 5250          bne       MemoryTest_89
                    5251   ; *(current_address) = (0xFF00 & user_data) >> 8;
00002E30  303C FF00 5252          move.w    #65280,D0
00002E34  C0BC 0000 5253          and.l     #65535,D0
00002E38  FFFF      
00002E3A  C083      5254          and.l     D3,D0
00002E3C  E088      5255          lsr.l     #8,D0
00002E3E  2042      5256          move.l    D2,A0
00002E40  1080      5257          move.b    D0,(A0)
                    5258   ; if (*(current_address) != ((0xFF00 & user_data) >> 8)) //read the data and confirm if it is written correctly
00002E42  2042      5259          move.l    D2,A0
00002E44  1010      5260          move.b    (A0),D0
00002E46  C0BC 0000 5261          and.l     #255,D0
00002E4A  00FF      
00002E4C  323C FF00 5262          move.w    #65280,D1
00002E50  C2BC 0000 5263          and.l     #65535,D1
00002E54  FFFF      
00002E56  C283      5264          and.l     D3,D1
00002E58  E089      5265          lsr.l     #8,D1
00002E5A  B081      5266          cmp.l     D1,D0
00002E5C  6724      5267          beq.s     MemoryTest_91
                    5268   ; {
                    5269   ; printf("\r\nError writing %x to address %x", (0xFF00 & user_data) >> 8, current_address);
00002E5E  2F02      5270          move.l    D2,-(A7)
00002E60  323C FF00 5271          move.w    #65280,D1
00002E64  C2BC 0000 5272          and.l     #65535,D1
00002E68  FFFF      
00002E6A  C283      5273          and.l     D3,D1
00002E6C  E089      5274          lsr.l     #8,D1
00002E6E  2F01      5275          move.l    D1,-(A7)
00002E70  4879 0000 5276          pea       @m68kde~2_167.L
00002E74  5454      
00002E76  4E92      5277          jsr       (A2)
00002E78  DEFC 000C 5278          add.w     #12,A7
                    5279   ; mem_error_flag = 1;
00002E7C  7E01      5280          moveq     #1,D7
                    5281   ; break;
00002E7E  6000 020A 5282          bra       MemoryTest_82
                    5283   MemoryTest_91:
                    5284   ; }
                    5285   ; *(current_address + 1) = (0x00FF & user_data);
00002E82  303C 00FF 5286          move.w    #255,D0
00002E86  48C0      5287          ext.l     D0
00002E88  C083      5288          and.l     D3,D0
00002E8A  2042      5289          move.l    D2,A0
00002E8C  1140 0001 5290          move.b    D0,1(A0)
                    5291   ; if (*(current_address + 1) != (0x00FF & user_data)) //read the data and confirm if it is written correctly
00002E90  2042      5292          move.l    D2,A0
00002E92  1028 0001 5293          move.b    1(A0),D0
00002E96  C0BC 0000 5294          and.l     #255,D0
00002E9A  00FF      
00002E9C  323C 00FF 5295          move.w    #255,D1
00002EA0  48C1      5296          ext.l     D1
00002EA2  C283      5297          and.l     D3,D1
00002EA4  B081      5298          cmp.l     D1,D0
00002EA6  6722      5299          beq.s     MemoryTest_93
                    5300   ; {
                    5301   ; printf("\r\nError writing %x to address %x", (0x00FF & user_data), (current_address+1));
00002EA8  2202      5302          move.l    D2,D1
00002EAA  5281      5303          addq.l    #1,D1
00002EAC  2F01      5304          move.l    D1,-(A7)
00002EAE  323C 00FF 5305          move.w    #255,D1
00002EB2  48C1      5306          ext.l     D1
00002EB4  C283      5307          and.l     D3,D1
00002EB6  2F01      5308          move.l    D1,-(A7)
00002EB8  4879 0000 5309          pea       @m68kde~2_167.L
00002EBC  5454      
00002EBE  4E92      5310          jsr       (A2)
00002EC0  DEFC 000C 5311          add.w     #12,A7
                    5312   ; mem_error_flag = 1;
00002EC4  7E01      5313          moveq     #1,D7
                    5314   ; break;
00002EC6  6000 01C2 5315          bra       MemoryTest_82
                    5316   MemoryTest_93:
00002ECA  6000 01B8 5317          bra       MemoryTest_105
                    5318   MemoryTest_89:
                    5319   ; }
                    5320   ; }
                    5321   ; else if(test_type == 2)
00002ECE  0C84 0000 5322          cmp.l     #2,D4
00002ED2  0002      
00002ED4  6600 01AE 5323          bne       MemoryTest_105
                    5324   ; {
                    5325   ; if( (end_address - current_address) < 3){ //  to ensure we do not go past end address
00002ED8  2006      5326          move.l    D6,D0
00002EDA  9082      5327          sub.l     D2,D0
00002EDC  0C80 0000 5328          cmp.l     #3,D0
00002EE0  0003      
00002EE2  6C00 005A 5329          bge       MemoryTest_97
                    5330   ; *(current_address) = (0xFF000000 & user_data) >> 24;
00002EE6  203C FF00 5331          move.l    #-16777216,D0
00002EEA  0000      
00002EEC  C083      5332          and.l     D3,D0
00002EEE  E088      5333          lsr.l     #8,D0
00002EF0  E088      5334          lsr.l     #8,D0
00002EF2  E088      5335          lsr.l     #8,D0
00002EF4  2042      5336          move.l    D2,A0
00002EF6  1080      5337          move.b    D0,(A0)
                    5338   ; *(current_address + 1) = (0x00FF0000 & user_data) >> 16;
00002EF8  203C 00FF 5339          move.l    #16711680,D0
00002EFC  0000      
00002EFE  C083      5340          and.l     D3,D0
00002F00  E088      5341          lsr.l     #8,D0
00002F02  E088      5342          lsr.l     #8,D0
00002F04  2042      5343          move.l    D2,A0
00002F06  1140 0001 5344          move.b    D0,1(A0)
                    5345   ; printf("\r\nError: End address limit reached");
00002F0A  4879 0000 5346          pea       @m68kde~2_168.L
00002F0E  5476      
00002F10  4E92      5347          jsr       (A2)
00002F12  584F      5348          addq.w    #4,A7
                    5349   ; printf("\r\nCannot write %x and %x",(0x0000FF00 & user_data) >> 8, (0x000000FF) & user_data);
00002F14  323C 00FF 5350          move.w    #255,D1
00002F18  48C1      5351          ext.l     D1
00002F1A  C283      5352          and.l     D3,D1
00002F1C  2F01      5353          move.l    D1,-(A7)
00002F1E  323C FF00 5354          move.w    #65280,D1
00002F22  C2BC 0000 5355          and.l     #65535,D1
00002F26  FFFF      
00002F28  C283      5356          and.l     D3,D1
00002F2A  E089      5357          lsr.l     #8,D1
00002F2C  2F01      5358          move.l    D1,-(A7)
00002F2E  4879 0000 5359          pea       @m68kde~2_169.L
00002F32  549A      
00002F34  4E92      5360          jsr       (A2)
00002F36  DEFC 000C 5361          add.w     #12,A7
                    5362   ; break;
00002F3A  6000 014E 5363          bra       MemoryTest_82
                    5364   MemoryTest_97:
                    5365   ; }
                    5366   ; *(current_address) = (0xFF000000 & user_data) >> 24;
00002F3E  203C FF00 5367          move.l    #-16777216,D0
00002F42  0000      
00002F44  C083      5368          and.l     D3,D0
00002F46  E088      5369          lsr.l     #8,D0
00002F48  E088      5370          lsr.l     #8,D0
00002F4A  E088      5371          lsr.l     #8,D0
00002F4C  2042      5372          move.l    D2,A0
00002F4E  1080      5373          move.b    D0,(A0)
                    5374   ; if (*(current_address) != ((0xFF000000 & user_data) >> 24)) //read the data and confirm if it is written correctly
00002F50  2042      5375          move.l    D2,A0
00002F52  1010      5376          move.b    (A0),D0
00002F54  C0BC 0000 5377          and.l     #255,D0
00002F58  00FF      
00002F5A  223C FF00 5378          move.l    #-16777216,D1
00002F5E  0000      
00002F60  C283      5379          and.l     D3,D1
00002F62  E089      5380          lsr.l     #8,D1
00002F64  E089      5381          lsr.l     #8,D1
00002F66  E089      5382          lsr.l     #8,D1
00002F68  B081      5383          cmp.l     D1,D0
00002F6A  6724      5384          beq.s     MemoryTest_99
                    5385   ; {
                    5386   ; printf("\r\nError writing %x to address %x", (0xFF000000 & user_data) >> 24, current_address);
00002F6C  2F02      5387          move.l    D2,-(A7)
00002F6E  223C FF00 5388          move.l    #-16777216,D1
00002F72  0000      
00002F74  C283      5389          and.l     D3,D1
00002F76  E089      5390          lsr.l     #8,D1
00002F78  E089      5391          lsr.l     #8,D1
00002F7A  E089      5392          lsr.l     #8,D1
00002F7C  2F01      5393          move.l    D1,-(A7)
00002F7E  4879 0000 5394          pea       @m68kde~2_167.L
00002F82  5454      
00002F84  4E92      5395          jsr       (A2)
00002F86  DEFC 000C 5396          add.w     #12,A7
                    5397   ; mem_error_flag = 1;
00002F8A  7E01      5398          moveq     #1,D7
                    5399   ; break;
00002F8C  6000 00FC 5400          bra       MemoryTest_82
                    5401   MemoryTest_99:
                    5402   ; }
                    5403   ; *(current_address + 1) = (0x00FF0000 & user_data) >> 16;
00002F90  203C 00FF 5404          move.l    #16711680,D0
00002F94  0000      
00002F96  C083      5405          and.l     D3,D0
00002F98  E088      5406          lsr.l     #8,D0
00002F9A  E088      5407          lsr.l     #8,D0
00002F9C  2042      5408          move.l    D2,A0
00002F9E  1140 0001 5409          move.b    D0,1(A0)
                    5410   ; if (*(current_address + 1) != ((0x00FF0000 & user_data) >> 16)) //read the data and confirm if it is written correctly
00002FA2  2042      5411          move.l    D2,A0
00002FA4  1028 0001 5412          move.b    1(A0),D0
00002FA8  C0BC 0000 5413          and.l     #255,D0
00002FAC  00FF      
00002FAE  223C 00FF 5414          move.l    #16711680,D1
00002FB2  0000      
00002FB4  C283      5415          and.l     D3,D1
00002FB6  E089      5416          lsr.l     #8,D1
00002FB8  E089      5417          lsr.l     #8,D1
00002FBA  B081      5418          cmp.l     D1,D0
00002FBC  6726      5419          beq.s     MemoryTest_101
                    5420   ; {
                    5421   ; printf("\r\nError writing %x to address %x", (0x00FF0000 & user_data) >> 16, (current_address+1));
00002FBE  2202      5422          move.l    D2,D1
00002FC0  5281      5423          addq.l    #1,D1
00002FC2  2F01      5424          move.l    D1,-(A7)
00002FC4  223C 00FF 5425          move.l    #16711680,D1
00002FC8  0000      
00002FCA  C283      5426          and.l     D3,D1
00002FCC  E089      5427          lsr.l     #8,D1
00002FCE  E089      5428          lsr.l     #8,D1
00002FD0  2F01      5429          move.l    D1,-(A7)
00002FD2  4879 0000 5430          pea       @m68kde~2_167.L
00002FD6  5454      
00002FD8  4E92      5431          jsr       (A2)
00002FDA  DEFC 000C 5432          add.w     #12,A7
                    5433   ; mem_error_flag = 1;
00002FDE  7E01      5434          moveq     #1,D7
                    5435   ; break;
00002FE0  6000 00A8 5436          bra       MemoryTest_82
                    5437   MemoryTest_101:
                    5438   ; }
                    5439   ; *(current_address + 2) = (0x0000FF00 & user_data) >> 8;
00002FE4  303C FF00 5440          move.w    #65280,D0
00002FE8  C0BC 0000 5441          and.l     #65535,D0
00002FEC  FFFF      
00002FEE  C083      5442          and.l     D3,D0
00002FF0  E088      5443          lsr.l     #8,D0
00002FF2  2042      5444          move.l    D2,A0
00002FF4  1140 0002 5445          move.b    D0,2(A0)
                    5446   ; if (*(current_address + 2) != ((0x0000FF00 & user_data) >> 8)) //read the data and confirm if it is written correctly
00002FF8  2042      5447          move.l    D2,A0
00002FFA  1028 0002 5448          move.b    2(A0),D0
00002FFE  C0BC 0000 5449          and.l     #255,D0
00003002  00FF      
00003004  323C FF00 5450          move.w    #65280,D1
00003008  C2BC 0000 5451          and.l     #65535,D1
0000300C  FFFF      
0000300E  C283      5452          and.l     D3,D1
00003010  E089      5453          lsr.l     #8,D1
00003012  B081      5454          cmp.l     D1,D0
00003014  6728      5455          beq.s     MemoryTest_103
                    5456   ; {
                    5457   ; printf("\r\nError writing %x to address %x", (0x0000FF00 & user_data) >> 8, (current_address+2));
00003016  2202      5458          move.l    D2,D1
00003018  5481      5459          addq.l    #2,D1
0000301A  2F01      5460          move.l    D1,-(A7)
0000301C  323C FF00 5461          move.w    #65280,D1
00003020  C2BC 0000 5462          and.l     #65535,D1
00003024  FFFF      
00003026  C283      5463          and.l     D3,D1
00003028  E089      5464          lsr.l     #8,D1
0000302A  2F01      5465          move.l    D1,-(A7)
0000302C  4879 0000 5466          pea       @m68kde~2_167.L
00003030  5454      
00003032  4E92      5467          jsr       (A2)
00003034  DEFC 000C 5468          add.w     #12,A7
                    5469   ; mem_error_flag = 1;
00003038  7E01      5470          moveq     #1,D7
                    5471   ; break;
0000303A  6000 004E 5472          bra       MemoryTest_82
                    5473   MemoryTest_103:
                    5474   ; }
                    5475   ; *(current_address + 3) = (0x000000FF) & user_data;
0000303E  303C 00FF 5476          move.w    #255,D0
00003042  48C0      5477          ext.l     D0
00003044  C083      5478          and.l     D3,D0
00003046  2042      5479          move.l    D2,A0
00003048  1140 0003 5480          move.b    D0,3(A0)
                    5481   ; if (*(current_address + 3) != ((0x000000FF) & user_data)) //read the data and confirm if it is written correctly
0000304C  2042      5482          move.l    D2,A0
0000304E  1028 0003 5483          move.b    3(A0),D0
00003052  C0BC 0000 5484          and.l     #255,D0
00003056  00FF      
00003058  323C 00FF 5485          move.w    #255,D1
0000305C  48C1      5486          ext.l     D1
0000305E  C283      5487          and.l     D3,D1
00003060  B081      5488          cmp.l     D1,D0
00003062  6720      5489          beq.s     MemoryTest_105
                    5490   ; {
                    5491   ; printf("\r\nError writing %x to address %x", (0x000000FF) & user_data, (current_address+3));
00003064  2202      5492          move.l    D2,D1
00003066  5681      5493          addq.l    #3,D1
00003068  2F01      5494          move.l    D1,-(A7)
0000306A  323C 00FF 5495          move.w    #255,D1
0000306E  48C1      5496          ext.l     D1
00003070  C283      5497          and.l     D3,D1
00003072  2F01      5498          move.l    D1,-(A7)
00003074  4879 0000 5499          pea       @m68kde~2_167.L
00003078  5454      
0000307A  4E92      5500          jsr       (A2)
0000307C  DEFC 000C 5501          add.w     #12,A7
                    5502   ; mem_error_flag = 1;
00003080  7E01      5503          moveq     #1,D7
                    5504   ; break;
00003082  6006      5505          bra.s     MemoryTest_82
                    5506   MemoryTest_105:
00003084  D48B      5507          add.l     A3,D2
00003086  6000 FD3E 5508          bra       MemoryTest_80
                    5509   MemoryTest_82:
                    5510   ; }
                    5511   ; }
                    5512   ; }
                    5513   ; if(mem_error_flag == 0){
0000308A  4A87      5514          tst.l     D7
0000308C  660C      5515          bne.s     MemoryTest_107
                    5516   ; printf("\r\nWriting finished at %08x", end_address);
0000308E  2F06      5517          move.l    D6,-(A7)
00003090  4879 0000 5518          pea       @m68kde~2_170.L
00003094  54B4      
00003096  4E92      5519          jsr       (A2)
00003098  504F      5520          addq.w    #8,A7
                    5521   MemoryTest_107:
0000309A  4CDF 3CFC 5522          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000309E  4E5E      5523          unlk      A6
000030A0  4E75      5524          rts
                    5525   ; }
                    5526   ; }
                    5527   ; }
                    5528   ; void main(void)
                    5529   ; {
                    5530   _main:
000030A2  4E56 FFF4 5531          link      A6,#-12
000030A6  48E7 3030 5532          movem.l   D2/D3/A2/A3,-(A7)
000030AA  45F8 0A30 5533          lea       _InstallExceptionHandler.L,A2
000030AE  47F9 0000 5534          lea       _printf.L,A3
000030B2  3532      
                    5535   ; char c ;
                    5536   ; int i, j ;
                    5537   ; char *BugMessage = "Student's Names: Jinil Patel and Saif Abdelazim";
000030B4  41F9 0000 5538          lea       @m68kde~2_171.L,A0
000030B8  54D0      
000030BA  2608      5539          move.l    A0,D3
                    5540   ; char *CopyrightMessage = "Student #: 38240727 and  62639422";
000030BC  41F9 0000 5541          lea       @m68kde~2_172.L,A0
000030C0  5500      
000030C2  2D48 FFFC 5542          move.l    A0,-4(A6)
                    5543   ; KillAllBreakPoints() ;
000030C6  4EB8 206C 5544          jsr       _KillAllBreakPoints
                    5545   ; i = x = y = z = PortA_Count = 0;
000030CA  42B9 0B00 5546          clr.l     _PortA_Count.L
000030CE  00D4      
000030D0  42B9 0B00 5547          clr.l     _z.L
000030D4  00D0      
000030D6  42B9 0B00 5548          clr.l     _y.L
000030DA  00CC      
000030DC  42B9 0B00 5549          clr.l     _x.L
000030E0  00C8      
000030E2  4282      5550          clr.l     D2
                    5551   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
000030E4  42B9 0B00 5552          clr.l     _GoFlag.L
000030E8  00DC      
000030EA  42B9 0B00 5553          clr.l     _Trace.L
000030EE  00D8      
                    5554   ; Echo = 1 ;
000030F0  23FC 0000 5555          move.l    #1,_Echo.L
000030F4  0001 0B00 
000030F8  00E0      
                    5556   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
000030FA  42B9 0B00 5557          clr.l     _d7.L
000030FE  0100      
00003100  42B9 0B00 5558          clr.l     _d6.L
00003104  00FC      
00003106  42B9 0B00 5559          clr.l     _d5.L
0000310A  00F8      
0000310C  42B9 0B00 5560          clr.l     _d4.L
00003110  00F4      
00003112  42B9 0B00 5561          clr.l     _d3.L
00003116  00F0      
00003118  42B9 0B00 5562          clr.l     _d2.L
0000311C  00EC      
0000311E  42B9 0B00 5563          clr.l     _d1.L
00003122  00E8      
00003124  42B9 0B00 5564          clr.l     _d0.L
00003128  00E4      
                    5565   ; a0=a1=a2=a3=a4=a5=a6=0 ;
0000312A  42B9 0B00 5566          clr.l     _a6.L
0000312E  011C      
00003130  42B9 0B00 5567          clr.l     _a5.L
00003134  0118      
00003136  42B9 0B00 5568          clr.l     _a4.L
0000313A  0114      
0000313C  42B9 0B00 5569          clr.l     _a3.L
00003140  0110      
00003142  42B9 0B00 5570          clr.l     _a2.L
00003146  010C      
00003148  42B9 0B00 5571          clr.l     _a1.L
0000314C  0108      
0000314E  42B9 0B00 5572          clr.l     _a0.L
00003152  0104      
                    5573   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
00003154  23FC 0800 5574          move.l    #134217728,_PC.L
00003158  0000 0B00 
0000315C  0120      
0000315E  23FC 0C00 5575          move.l    #201326592,_SSP.L
00003162  0000 0B00 
00003166  0124      
00003168  23FC 0C00 5576          move.l    #201326592,_USP.L
0000316C  0000 0B00 
00003170  0128      
                    5577   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00003172  33FC 2000 5578          move.w    #8192,_SR.L
00003176  0B00 012C 
                    5579   ; // Initialise Breakpoint variables
                    5580   ; for(i = 0; i < 8; i++)  {
0000317A  4282      5581          clr.l     D2
                    5582   main_1:
0000317C  0C82 0000 5583          cmp.l     #8,D2
00003180  0008      
00003182  6C00 004C 5584          bge       main_3
                    5585   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00003186  2002      5586          move.l    D2,D0
00003188  E588      5587          lsl.l     #2,D0
0000318A  41F9 0B00 5588          lea       _BreakPointAddress.L,A0
0000318E  012E      
00003190  42B0 0800 5589          clr.l     0(A0,D0.L)
                    5590   ; WatchPointAddress[i] = 0 ;
00003194  2002      5591          move.l    D2,D0
00003196  E588      5592          lsl.l     #2,D0
00003198  41F9 0B00 5593          lea       _WatchPointAddress.L,A0
0000319C  0182      
0000319E  42B0 0800 5594          clr.l     0(A0,D0.L)
                    5595   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
000031A2  2002      5596          move.l    D2,D0
000031A4  E388      5597          lsl.l     #1,D0
000031A6  41F9 0B00 5598          lea       _BreakPointInstruction.L,A0
000031AA  014E      
000031AC  4270 0800 5599          clr.w     0(A0,D0.L)
                    5600   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
000031B0  2002      5601          move.l    D2,D0
000031B2  E588      5602          lsl.l     #2,D0
000031B4  41F9 0B00 5603          lea       _BreakPointSetOrCleared.L,A0
000031B8  015E      
000031BA  42B0 0800 5604          clr.l     0(A0,D0.L)
                    5605   ; WatchPointSetOrCleared[i] = 0;
000031BE  2002      5606          move.l    D2,D0
000031C0  E588      5607          lsl.l     #2,D0
000031C2  41F9 0B00 5608          lea       _WatchPointSetOrCleared.L,A0
000031C6  01A2      
000031C8  42B0 0800 5609          clr.l     0(A0,D0.L)
000031CC  5282      5610          addq.l    #1,D2
000031CE  60AC      5611          bra       main_1
                    5612   main_3:
                    5613   ; }
                    5614   ; Init_RS232() ;     // initialise the RS232 port
000031D0  4EB8 0B12 5615          jsr       _Init_RS232
                    5616   ; Init_LCD() ;
000031D4  4EB8 095E 5617          jsr       _Init_LCD
                    5618   ; SPI_Init();
000031D8  4EB8 10E4 5619          jsr       _SPI_Init
                    5620   ; printf("\r\nSPI has been initialized successfully.");
000031DC  4879 0000 5621          pea       @m68kde~2_173.L
000031E0  5522      
000031E2  4E93      5622          jsr       (A3)
000031E4  584F      5623          addq.w    #4,A7
                    5624   ; for( i = 32; i < 48; i++)
000031E6  7420      5625          moveq     #32,D2
                    5626   main_4:
000031E8  0C82 0000 5627          cmp.l     #48,D2
000031EC  0030      
000031EE  6C0E      5628          bge.s     main_6
                    5629   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
000031F0  2F02      5630          move.l    D2,-(A7)
000031F2  4878 28E4 5631          pea       _UnhandledTrap.L
000031F6  4E92      5632          jsr       (A2)
000031F8  504F      5633          addq.w    #8,A7
000031FA  5282      5634          addq.l    #1,D2
000031FC  60EA      5635          bra       main_4
                    5636   main_6:
                    5637   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
000031FE  4878 002F 5638          pea       47
00003202  4878 25BE 5639          pea       _menu.L
00003206  4E92      5640          jsr       (A2)
00003208  504F      5641          addq.w    #8,A7
                    5642   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
0000320A  4878 0019 5643          pea       25
0000320E  4878 288A 5644          pea       _UnhandledIRQ1.L
00003212  4E92      5645          jsr       (A2)
00003214  504F      5646          addq.w    #8,A7
                    5647   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
00003216  4878 001A 5648          pea       26
0000321A  4878 2896 5649          pea       _UnhandledIRQ2.L
0000321E  4E92      5650          jsr       (A2)
00003220  504F      5651          addq.w    #8,A7
                    5652   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
00003222  4878 001B 5653          pea       27
00003226  4878 28A2 5654          pea       _UnhandledIRQ3.L
0000322A  4E92      5655          jsr       (A2)
0000322C  504F      5656          addq.w    #8,A7
                    5657   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
0000322E  4878 001C 5658          pea       28
00003232  4878 28AE 5659          pea       _UnhandledIRQ4.L
00003236  4E92      5660          jsr       (A2)
00003238  504F      5661          addq.w    #8,A7
                    5662   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
0000323A  4878 001D 5663          pea       29
0000323E  4878 28BA 5664          pea       _UnhandledIRQ5.L
00003242  4E92      5665          jsr       (A2)
00003244  504F      5666          addq.w    #8,A7
                    5667   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
00003246  4878 001E 5668          pea       30
0000324A  4878 28C6 5669          pea       _UnhandledIRQ6.L
0000324E  4E92      5670          jsr       (A2)
00003250  504F      5671          addq.w    #8,A7
                    5672   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00003252  4878 001F 5673          pea       31
00003256  4878 28D8 5674          pea       _UnhandledIRQ7.L
0000325A  4E92      5675          jsr       (A2)
0000325C  504F      5676          addq.w    #8,A7
                    5677   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
0000325E  4878 002E 5678          pea       46
00003262  4878 22FA 5679          pea       _HandleBreakPoint.L
00003266  4E92      5680          jsr       (A2)
00003268  504F      5681          addq.w    #8,A7
                    5682   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
0000326A  4878 001D 5683          pea       29
0000326E  4878 19DA 5684          pea       _DumpRegistersandPause.L
00003272  4E92      5685          jsr       (A2)
00003274  504F      5686          addq.w    #8,A7
                    5687   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
00003276  4878 0002 5688          pea       2
0000327A  4878 28F2 5689          pea       _BusError.L
0000327E  4E92      5690          jsr       (A2)
00003280  504F      5691          addq.w    #8,A7
                    5692   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00003282  4878 0003 5693          pea       3
00003286  4878 2900 5694          pea       _AddressError.L
0000328A  4E92      5695          jsr       (A2)
0000328C  504F      5696          addq.w    #8,A7
                    5697   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
0000328E  4878 0004 5698          pea       4
00003292  4878 290E 5699          pea       _IllegalInstruction.L
00003296  4E92      5700          jsr       (A2)
00003298  504F      5701          addq.w    #8,A7
                    5702   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
0000329A  4878 0005 5703          pea       5
0000329E  4878 291C 5704          pea       _Dividebyzero.L
000032A2  4E92      5705          jsr       (A2)
000032A4  504F      5706          addq.w    #8,A7
                    5707   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
000032A6  4878 0006 5708          pea       6
000032AA  4878 292A 5709          pea       _Check.L
000032AE  4E92      5710          jsr       (A2)
000032B0  504F      5711          addq.w    #8,A7
                    5712   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
000032B2  4878 0007 5713          pea       7
000032B6  4878 2938 5714          pea       _Trapv.L
000032BA  4E92      5715          jsr       (A2)
000032BC  504F      5716          addq.w    #8,A7
                    5717   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
000032BE  4878 0008 5718          pea       8
000032C2  4878 2946 5719          pea       _PrivError.L
000032C6  4E92      5720          jsr       (A2)
000032C8  504F      5721          addq.w    #8,A7
                    5722   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
000032CA  4878 000F 5723          pea       15
000032CE  4878 2954 5724          pea       _UnitIRQ.L
000032D2  4E92      5725          jsr       (A2)
000032D4  504F      5726          addq.w    #8,A7
                    5727   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
000032D6  4878 0018 5728          pea       24
000032DA  4878 292A 5729          pea       _Check.L
000032DE  4E92      5730          jsr       (A2)
000032E0  504F      5731          addq.w    #8,A7
                    5732   ; FlushKeyboard() ;                        // dump unread characters from keyboard
000032E2  4EB8 0BA6 5733          jsr       _FlushKeyboard
                    5734   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
000032E6  4239 0040 5735          clr.b     4194314
000032EA  000A      
                    5736   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5737   ; while(((char)(PortB & 0x02)) == (char)(0x02))    {
                    5738   main_7:
000032EC  1039 0040 5739          move.b    4194306,D0
000032F0  0002      
000032F2  C03C 0002 5740          and.b     #2,D0
000032F6  0C00 0002 5741          cmp.b     #2,D0
000032FA  662A      5742          bne.s     main_9
                    5743   ; LoadFromFlashChip();
000032FC  4EB8 14DA 5744          jsr       _LoadFromFlashChip
                    5745   ; printf("\r\nRunning.....") ;
00003300  4879 0000 5746          pea       @m68kde~2_174.L
00003304  554C      
00003306  4E93      5747          jsr       (A3)
00003308  584F      5748          addq.w    #4,A7
                    5749   ; Oline1("Running.....") ;
0000330A  4879 0000 5750          pea       @m68kde~2_175.L
0000330E  555C      
00003310  4EB8 0A02 5751          jsr       _Oline1
00003314  584F      5752          addq.w    #4,A7
                    5753   ; GoFlag = 1;
00003316  23FC 0000 5754          move.l    #1,_GoFlag.L
0000331A  0001 0B00 
0000331E  00DC      
                    5755   ; go() ;
00003320  4EB8 08B8 5756          jsr       _go
00003324  60C6      5757          bra       main_7
                    5758   main_9:
                    5759   ; }
                    5760   ; // otherwise start the debug monitor
                    5761   ; Oline0(BugMessage) ;
00003326  2F03      5762          move.l    D3,-(A7)
00003328  4EB8 09D4 5763          jsr       _Oline0
0000332C  584F      5764          addq.w    #4,A7
                    5765   ; Oline1("By: PJ Davies") ;
0000332E  4879 0000 5766          pea       @m68kde~2_176.L
00003332  556A      
00003334  4EB8 0A02 5767          jsr       _Oline1
00003338  584F      5768          addq.w    #4,A7
                    5769   ; printf("\r\n%s", BugMessage) ;
0000333A  2F03      5770          move.l    D3,-(A7)
0000333C  4879 0000 5771          pea       @m68kde~2_177.L
00003340  5578      
00003342  4E93      5772          jsr       (A3)
00003344  504F      5773          addq.w    #8,A7
                    5774   ; printf("\r\n%s", CopyrightMessage) ;
00003346  2F2E FFFC 5775          move.l    -4(A6),-(A7)
0000334A  4879 0000 5776          pea       @m68kde~2_177.L
0000334E  5578      
00003350  4E93      5777          jsr       (A3)
00003352  504F      5778          addq.w    #8,A7
                    5779   ; menu();
00003354  4EB8 25BE 5780          jsr       _menu
00003358  4CDF 0C0C 5781          movem.l   (A7)+,D2/D3/A2/A3
0000335C  4E5E      5782          unlk      A6
0000335E  4E75      5783          rts
                    5784   ; }
                    5785   _strcpy:
00003360  206F 0004 5786          move.l    (4,A7),A0
00003364  226F 0008 5787          move.l    (8,A7),A1
00003368  2008      5788          move.l    A0,D0
                    5789   strcpy_1:
0000336A  10D9      5790          move.b    (A1)+,(A0)+
0000336C  66FC      5791          bne.s     strcpy_1
0000336E  4E75      5792          rts
                    5793   ULDIV:
00003370  4E56 0000 5794          link    A6,#0
00003374  48E7 C000 5795          movem.l D0/D1,-(A7)
00003378  222E 0008 5796          move.l  8(A6),D1
0000337C  202E 000C 5797          move.l  12(A6),D0
00003380  6036      5798          bra.s   ldiv_3
                    5799   LDIV:
00003382  4E56 0000 5800          link    A6,#0
00003386  48E7 C000 5801          movem.l D0/D1,-(A7)
0000338A  222E 0008 5802          move.l  8(A6),D1
0000338E  202E 000C 5803          move.l  12(A6),D0
00003392  4A80      5804          tst.l   D0
00003394  6A0E      5805          bpl.s   ldiv_1
00003396  4480      5806          neg.l   D0
00003398  4A81      5807          tst.l   D1
0000339A  6A14      5808          bpl.s   ldiv_2
0000339C  4481      5809          neg.l   D1
0000339E  612A      5810          bsr.s   dodiv
000033A0  4481      5811          neg.l   D1
000033A2  6016      5812          bra.s   ldiv_4
                    5813   ldiv_1:
000033A4  4A81      5814          tst.l   D1
000033A6  6A10      5815          bpl.s   ldiv_3
000033A8  4481      5816          neg.l   D1
000033AA  611E      5817          bsr.s   dodiv
000033AC  4480      5818          neg.l   D0
000033AE  600A      5819          bra.s   ldiv_4
                    5820   ldiv_2:
000033B0  6118      5821          bsr.s   dodiv
000033B2  4480      5822          neg.l   D0
000033B4  4481      5823          neg.l   D1
000033B6  6002      5824          bra.s   ldiv_4
                    5825   ldiv_3:
000033B8  6110      5826          bsr.s   dodiv
                    5827   ldiv_4:
000033BA  2D40 0008 5828          move.l  D0,8(A6)
000033BE  2D41 000C 5829          move.l  D1,12(A6)
000033C2  4CDF 0003 5830          movem.l (A7)+,D0/D1
000033C6  4E5E      5831          unlk    A6
000033C8  4E75      5832          rts
                    5833   dodiv:
000033CA  0C81 0000 5834          cmpi.l  #$FFFF,D1
000033CE  FFFF      
000033D0  6236      5835          bhi.s   dodiv_2
000033D2  0C80 0000 5836          cmpi.l  #$FFFF,D0
000033D6  FFFF      
000033D8  6210      5837          bhi.s   dodiv_1
000033DA  80C1      5838          divu    D1,D0
000033DC  2200      5839          move.l  D0,D1
000033DE  4241      5840          clr.w   D1
000033E0  4841      5841          swap    D1
000033E2  0280 0000 5842          andi.l  #$FFFF,D0
000033E6  FFFF      
000033E8  4E75      5843          rts
                    5844   dodiv_1:
000033EA  48A7 A000 5845          movem.w D0/D2,-(A7)
000033EE  4240      5846          clr.w   D0
000033F0  4840      5847          swap    D0
000033F2  80C1      5848          divu    D1,D0
000033F4  3400      5849          move.w  D0,D2
000033F6  301F      5850          move.w  (A7)+,D0
000033F8  80C1      5851          divu    D1,D0
000033FA  4840      5852          swap    D0
000033FC  4281      5853          clr.l   D1
000033FE  3200      5854          move.w  D0,D1
00003400  3002      5855          move.w  D2,D0
00003402  4840      5856          swap    D0
00003404  341F      5857          move.w  (A7)+,D2
00003406  4E75      5858          rts
                    5859   dodiv_2:
00003408  48E7 3800 5860          movem.l D2/D3/D4,-(A7)
0000340C  2401      5861          move.l  D1,D2
0000340E  4242      5862          clr.w   D2
00003410  4842      5863          swap    D2
00003412  5282      5864          addq.l  #1,D2
00003414  2600      5865          move.l  D0,D3
00003416  2801      5866          move.l  D1,D4
00003418  2202      5867          move.l  D2,D1
0000341A  61CE      5868          bsr.s   dodiv_1
0000341C  2204      5869          move.l  D4,D1
0000341E  82C2      5870          divu    D2,D1
00003420  80C1      5871          divu    D1,D0
00003422  0280 0000 5872          andi.l  #$FFFF,D0
00003426  FFFF      
                    5873   dodiv_3:
00003428  2204      5874          move.l  D4,D1
0000342A  2404      5875          move.l  D4,D2
0000342C  4842      5876          swap    D2
0000342E  C2C0      5877          mulu    D0,D1
00003430  C4C0      5878          mulu    D0,D2
00003432  4842      5879          swap    D2
00003434  D282      5880          add.l   D2,D1
00003436  9283      5881          sub.l   D3,D1
00003438  620A      5882          bhi.s   dodiv_4
0000343A  4481      5883          neg.l   D1
0000343C  B881      5884          cmp.l   D1,D4
0000343E  6208      5885          bhi.s   dodiv_5
00003440  5280      5886          addq.l  #1,D0
00003442  60E4      5887          bra.s   dodiv_3
                    5888   dodiv_4:
00003444  5380      5889          subq.l  #1,D0
00003446  60E0      5890          bra.s   dodiv_3
                    5891   dodiv_5:
00003448  4CDF 001C 5892          movem.l (A7)+,D2/D3/D4
0000344C  4E75      5893          rts
                    5894   _putch:
0000344E  4E56 0000 5895          link      A6,#0
00003452  2F02      5896          move.l    D2,-(A7)
00003454  242E 0008 5897          move.l    8(A6),D2
00003458  0C82 0000 5898          cmp.l     #10,D2
0000345C  000A      
0000345E  660A      5899          bne.s     putch_1
00003460  4878 000D 5900          pea       13
00003464  4EB8 0B3C 5901          jsr       __putch
00003468  584F      5902          addq.w    #4,A7
                    5903   putch_1:
0000346A  2F02      5904          move.l    D2,-(A7)
0000346C  4EB8 0B3C 5905          jsr       __putch
00003470  584F      5906          addq.w    #4,A7
00003472  2002      5907          move.l    D2,D0
00003474  241F      5908          move.l    (A7)+,D2
00003476  4E5E      5909          unlk      A6
00003478  4E75      5910          rts
                    5911   _getch:
0000347A  2F02      5912          move.l    D2,-(A7)
0000347C  2439 0B00 5913          move.l    __ungetbuf.L,D2
00003480  00C0      
00003482  2039 0B00 5914          move.l    __ungetbuf.L,D0
00003486  00C0      
00003488  0C80 FFFF 5915          cmp.l     #-1,D0
0000348C  FFFF      
0000348E  670C      5916          beq.s     getch_1
00003490  23FC FFFF 5917          move.l    #-1,__ungetbuf.L
00003494  FFFF 0B00 
00003498  00C0      
0000349A  6010      5918          bra.s     getch_3
                    5919   getch_1:
0000349C  4EB8 0B68 5920          jsr       __getch
000034A0  2400      5921          move.l    D0,D2
000034A2  0C80 0000 5922          cmp.l     #13,D0
000034A6  000D      
000034A8  6602      5923          bne.s     getch_3
000034AA  740A      5924          moveq     #10,D2
                    5925   getch_3:
000034AC  2002      5926          move.l    D2,D0
000034AE  241F      5927          move.l    (A7)+,D2
000034B0  4E75      5928          rts
                    5929   _tolower:
000034B2  202F 0004 5930          move.l    4(A7),D0
000034B6  0C80 0000 5931          cmp.l     #'A',D0
000034BA  0041      
000034BC  6D0E      5932          blt.s     tolower_1
000034BE  0C80 0000 5933          cmp.l     #'Z',D0
000034C2  005A      
000034C4  6E06      5934          bgt.s     tolower_1
000034C6  0680 0000 5935          add.l     #$20,D0
000034CA  0020      
                    5936   tolower_1:
000034CC  4E75      5937          rts
                    5938   _sprintf:
000034CE  4E56 FFFC 5939          link      A6,#-4
000034D2  2F02      5940          move.l    D2,-(A7)
000034D4  41EE 000C 5941          lea       12(A6),A0
000034D8  5848      5942          addq.w    #4,A0
000034DA  2408      5943          move.l    A0,D2
000034DC  2F02      5944          move.l    D2,-(A7)
000034DE  2F2E 000C 5945          move.l    12(A6),-(A7)
000034E2  2F2E 0008 5946          move.l    8(A6),-(A7)
000034E6  4EB9 0000 5947          jsr       _doprint
000034EA  3608      
000034EC  DEFC 000C 5948          add.w     #12,A7
000034F0  2D40 FFFC 5949          move.l    D0,-4(A6)
000034F4  4282      5950          clr.l     D2
000034F6  202E FFFC 5951          move.l    -4(A6),D0
000034FA  241F      5952          move.l    (A7)+,D2
000034FC  4E5E      5953          unlk      A6
000034FE  4E75      5954          rts
                    5955   _strcat:
00003500  206F 0004 5956          move.l    (4,A7),A0
00003504  226F 0008 5957          move.l    (8,A7),A1
00003508  2008      5958          move.l    A0,D0
                    5959   strcat_1:
0000350A  4A18      5960          tst.b     (A0)+
0000350C  66FC      5961          bne.s     strcat_1
0000350E  5388      5962          subq.l    #1,A0
                    5963   strcat_2:
00003510  10D9      5964          move.b    (A1)+,(A0)+
00003512  66FC      5965          bne.s     strcat_2
00003514  4E75      5966          rts
                    5967   _toupper:
00003516  202F 0004 5968          move.l    4(A7),D0
0000351A  0C80 0000 5969          cmp.l     #'a',D0
0000351E  0061      
00003520  6D0E      5970          blt.s     toupper_1
00003522  0C80 0000 5971          cmp.l     #'z',D0
00003526  007A      
00003528  6E06      5972          bgt.s     toupper_1
0000352A  0480 0000 5973          sub.l     #$20,D0
0000352E  0020      
                    5974   toupper_1:
00003530  4E75      5975          rts
                    5976   _printf:
00003532  4E56 FFFC 5977          link      A6,#-4
00003536  2F02      5978          move.l    D2,-(A7)
00003538  41EE 0008 5979          lea       8(A6),A0
0000353C  5848      5980          addq.w    #4,A0
0000353E  2408      5981          move.l    A0,D2
00003540  2F02      5982          move.l    D2,-(A7)
00003542  2F2E 0008 5983          move.l    8(A6),-(A7)
00003546  42A7      5984          clr.l     -(A7)
00003548  4EB9 0000 5985          jsr       _doprint
0000354C  3608      
0000354E  DEFC 000C 5986          add.w     #12,A7
00003552  2D40 FFFC 5987          move.l    D0,-4(A6)
00003556  4282      5988          clr.l     D2
00003558  202E FFFC 5989          move.l    -4(A6),D0
0000355C  241F      5990          move.l    (A7)+,D2
0000355E  4E5E      5991          unlk      A6
00003560  4E75      5992          rts
                    5993   @doprint_copy:
00003562  4E56 0000 5994          link      A6,#0
00003566  206E 0008 5995          move.l    8(A6),A0
0000356A  4A90      5996          tst.l     (A0)
0000356C  6710      5997          beq.s     @doprint_copy_1
0000356E  202E 000C 5998          move.l    12(A6),D0
00003572  206E 0008 5999          move.l    8(A6),A0
00003576  2250      6000          move.l    (A0),A1
00003578  5290      6001          addq.l    #1,(A0)
0000357A  1280      6002          move.b    D0,(A1)
0000357C  600A      6003          bra.s     @doprint_copy_2
                    6004   @doprint_copy_1:
0000357E  2F2E 000C 6005          move.l    12(A6),-(A7)
00003582  4EB8 344E 6006          jsr       _putch
00003586  584F      6007          addq.w    #4,A7
                    6008   @doprint_copy_2:
00003588  4E5E      6009          unlk      A6
0000358A  4E75      6010          rts
                    6011   @doprint_getval:
0000358C  4E56 0000 6012          link      A6,#0
00003590  48E7 3000 6013          movem.l   D2/D3,-(A7)
00003594  262E 0008 6014          move.l    8(A6),D3
00003598  4282      6015          clr.l     D2
0000359A  2043      6016          move.l    D3,A0
0000359C  2050      6017          move.l    (A0),A0
0000359E  1010      6018          move.b    (A0),D0
000035A0  0C00 002A 6019          cmp.b     #42,D0
000035A4  6612      6020          bne.s     @doprint_getval_1
000035A6  206E 000C 6021          move.l    12(A6),A0
000035AA  2250      6022          move.l    (A0),A1
000035AC  5890      6023          addq.l    #4,(A0)
000035AE  2411      6024          move.l    (A1),D2
000035B0  2043      6025          move.l    D3,A0
000035B2  5290      6026          addq.l    #1,(A0)
000035B4  6000 0048 6027          bra       @doprint_getval_5
                    6028   @doprint_getval_1:
000035B8  7001      6029          moveq     #1,D0
000035BA  2043      6030          move.l    D3,A0
000035BC  2050      6031          move.l    (A0),A0
000035BE  1210      6032          move.b    (A0),D1
000035C0  4881      6033          ext.w     D1
000035C2  48C1      6034          ext.l     D1
000035C4  D081      6035          add.l     D1,D0
000035C6  41F9 0000 6036          lea       __ctype.L,A0
000035CA  558A      
000035CC  1030 0800 6037          move.b    0(A0,D0.L),D0
000035D0  C03C 0004 6038          and.b     #4,D0
000035D4  6728      6039          beq.s     @doprint_getval_5
000035D6  2F02      6040          move.l    D2,-(A7)
000035D8  4878 000A 6041          pea       10
000035DC  4EB9 0000 6042          jsr       LMUL
000035E0  3DA4      
000035E2  2017      6043          move.l    (A7),D0
000035E4  504F      6044          addq.w    #8,A7
000035E6  2043      6045          move.l    D3,A0
000035E8  2250      6046          move.l    (A0),A1
000035EA  5290      6047          addq.l    #1,(A0)
000035EC  1211      6048          move.b    (A1),D1
000035EE  4881      6049          ext.w     D1
000035F0  48C1      6050          ext.l     D1
000035F2  D081      6051          add.l     D1,D0
000035F4  0480 0000 6052          sub.l     #48,D0
000035F8  0030      
000035FA  2400      6053          move.l    D0,D2
000035FC  60BA      6054          bra       @doprint_getval_1
                    6055   @doprint_getval_5:
000035FE  2002      6056          move.l    D2,D0
00003600  4CDF 000C 6057          movem.l   (A7)+,D2/D3
00003604  4E5E      6058          unlk      A6
00003606  4E75      6059          rts
                    6060   _doprint:
00003608  4E56 FFCC 6061          link      A6,#-52
0000360C  48E7 3F3C 6062          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003610  45EE 0008 6063          lea       8(A6),A2
00003614  47F8 3562 6064          lea       @doprint_copy.L,A3
00003618  49F9 0000 6065          lea       _ultoa.L,A4
0000361C  3D30      
0000361E  4286      6066          clr.l     D6
                    6067   doprint_1:
00003620  206E 000C 6068          move.l    12(A6),A0
00003624  4A10      6069          tst.b     (A0)
00003626  6700 05EA 6070          beq       doprint_3
0000362A  206E 000C 6071          move.l    12(A6),A0
0000362E  1010      6072          move.b    (A0),D0
00003630  0C00 0025 6073          cmp.b     #37,D0
00003634  671C      6074          beq.s     doprint_4
00003636  206E 000C 6075          move.l    12(A6),A0
0000363A  52AE 000C 6076          addq.l    #1,12(A6)
0000363E  1210      6077          move.b    (A0),D1
00003640  4881      6078          ext.w     D1
00003642  48C1      6079          ext.l     D1
00003644  2F01      6080          move.l    D1,-(A7)
00003646  2F0A      6081          move.l    A2,-(A7)
00003648  4E93      6082          jsr       (A3)
0000364A  504F      6083          addq.w    #8,A7
0000364C  5286      6084          addq.l    #1,D6
0000364E  6000 05BE 6085          bra       doprint_2
                    6086   doprint_4:
00003652  52AE 000C 6087          addq.l    #1,12(A6)
00003656  422E FFD3 6088          clr.b     -45(A6)
0000365A  422E FFD2 6089          clr.b     -46(A6)
0000365E  422E FFD0 6090          clr.b     -48(A6)
00003662  422E FFCF 6091          clr.b     -49(A6)
00003666  422E FFCE 6092          clr.b     -50(A6)
0000366A  422E FFCD 6093          clr.b     -51(A6)
0000366E  42AE FFFC 6094          clr.l     -4(A6)
00003672  7AFF      6095          moveq     #-1,D5
00003674  41EE FFDC 6096          lea       -36(A6),A0
00003678  2608      6097          move.l    A0,D3
0000367A  2408      6098          move.l    A0,D2
                    6099   doprint_6:
0000367C  206E 000C 6100          move.l    12(A6),A0
00003680  1010      6101          move.b    (A0),D0
00003682  4880      6102          ext.w     D0
00003684  48C0      6103          ext.l     D0
00003686  0C80 0000 6104          cmp.l     #43,D0
0000368A  002B      
0000368C  6730      6105          beq.s     doprint_12
0000368E  6E18      6106          bgt.s     doprint_15
00003690  0C80 0000 6107          cmp.l     #35,D0
00003694  0023      
00003696  6700 003E 6108          beq       doprint_14
0000369A  6E00 0046 6109          bgt       doprint_9
0000369E  0C80 0000 6110          cmp.l     #32,D0
000036A2  0020      
000036A4  6724      6111          beq.s     doprint_13
000036A6  603A      6112          bra.s     doprint_9
                    6113   doprint_15:
000036A8  0C80 0000 6114          cmp.l     #45,D0
000036AC  002D      
000036AE  6702      6115          beq.s     doprint_11
000036B0  6030      6116          bra.s     doprint_9
                    6117   doprint_11:
000036B2  1D7C 0001 6118          move.b    #1,-51(A6)
000036B6  FFCD      
000036B8  52AE 000C 6119          addq.l    #1,12(A6)
000036BC  6026      6120          bra.s     doprint_7
                    6121   doprint_12:
000036BE  1D7C 0001 6122          move.b    #1,-50(A6)
000036C2  FFCE      
000036C4  52AE 000C 6123          addq.l    #1,12(A6)
000036C8  601A      6124          bra.s     doprint_7
                    6125   doprint_13:
000036CA  1D7C 0001 6126          move.b    #1,-49(A6)
000036CE  FFCF      
000036D0  52AE 000C 6127          addq.l    #1,12(A6)
000036D4  600E      6128          bra.s     doprint_7
                    6129   doprint_14:
000036D6  1D7C 0001 6130          move.b    #1,-48(A6)
000036DA  FFD0      
000036DC  52AE 000C 6131          addq.l    #1,12(A6)
000036E0  6002      6132          bra.s     doprint_7
                    6133   doprint_9:
000036E2  6002      6134          bra.s     doprint_8
                    6135   doprint_7:
000036E4  6096      6136          bra       doprint_6
                    6137   doprint_8:
000036E6  206E 000C 6138          move.l    12(A6),A0
000036EA  1010      6139          move.b    (A0),D0
000036EC  0C00 0030 6140          cmp.b     #48,D0
000036F0  660A      6141          bne.s     doprint_16
000036F2  52AE 000C 6142          addq.l    #1,12(A6)
000036F6  1D7C 0001 6143          move.b    #1,-46(A6)
000036FA  FFD2      
                    6144   doprint_16:
000036FC  486E 0010 6145          pea       16(A6)
00003700  486E 000C 6146          pea       12(A6)
00003704  4EB8 358C 6147          jsr       @doprint_getval
00003708  504F      6148          addq.w    #8,A7
0000370A  2A40      6149          move.l    D0,A5
0000370C  206E 000C 6150          move.l    12(A6),A0
00003710  1010      6151          move.b    (A0),D0
00003712  0C00 002E 6152          cmp.b     #46,D0
00003716  6614      6153          bne.s     doprint_18
00003718  52AE 000C 6154          addq.l    #1,12(A6)
0000371C  486E 0010 6155          pea       16(A6)
00003720  486E 000C 6156          pea       12(A6)
00003724  4EB8 358C 6157          jsr       @doprint_getval
00003728  504F      6158          addq.w    #8,A7
0000372A  2A00      6159          move.l    D0,D5
                    6160   doprint_18:
0000372C  206E 000C 6161          move.l    12(A6),A0
00003730  1010      6162          move.b    (A0),D0
00003732  0C00 006C 6163          cmp.b     #108,D0
00003736  660A      6164          bne.s     doprint_20
00003738  52AE 000C 6165          addq.l    #1,12(A6)
0000373C  1D7C 0001 6166          move.b    #1,-45(A6)
00003740  FFD3      
                    6167   doprint_20:
00003742  206E 000C 6168          move.l    12(A6),A0
00003746  1010      6169          move.b    (A0),D0
00003748  4880      6170          ext.w     D0
0000374A  48C0      6171          ext.l     D0
0000374C  0C80 0000 6172          cmp.l     #111,D0
00003750  006F      
00003752  6700 00D8 6173          beq       doprint_27
00003756  6E34      6174          bgt.s     doprint_33
00003758  0C80 0000 6175          cmp.l     #100,D0
0000375C  0064      
0000375E  6700 0054 6176          beq       doprint_24
00003762  6E1C      6177          bgt.s     doprint_34
00003764  0C80 0000 6178          cmp.l     #99,D0
00003768  0063      
0000376A  6700 0130 6179          beq       doprint_30
0000376E  6E00 0174 6180          bgt       doprint_22
00003772  0C80 0000 6181          cmp.l     #88,D0
00003776  0058      
00003778  6700 00EA 6182          beq       doprint_28
0000377C  6000 0166 6183          bra       doprint_22
                    6184   doprint_34:
00003780  0C80 0000 6185          cmp.l     #105,D0
00003784  0069      
00003786  672C      6186          beq.s     doprint_24
00003788  6000 015A 6187          bra       doprint_22
                    6188   doprint_33:
0000378C  0C80 0000 6189          cmp.l     #117,D0
00003790  0075      
00003792  6700 0060 6190          beq       doprint_26
00003796  6E0E      6191          bgt.s     doprint_35
00003798  0C80 0000 6192          cmp.l     #115,D0
0000379C  0073      
0000379E  6700 0124 6193          beq       doprint_31
000037A2  6000 0140 6194          bra       doprint_22
                    6195   doprint_35:
000037A6  0C80 0000 6196          cmp.l     #120,D0
000037AA  0078      
000037AC  6700 00B6 6197          beq       doprint_28
000037B0  6000 0132 6198          bra       doprint_22
                    6199   doprint_24:
000037B4  4A2E FFD3 6200          tst.b     -45(A6)
000037B8  671C      6201          beq.s     doprint_36
000037BA  4878 000A 6202          pea       10
000037BE  2F03      6203          move.l    D3,-(A7)
000037C0  206E 0010 6204          move.l    16(A6),A0
000037C4  58AE 0010 6205          addq.l    #4,16(A6)
000037C8  2F10      6206          move.l    (A0),-(A7)
000037CA  4EB9 0000 6207          jsr       _ltoa
000037CE  3CAC      
000037D0  DEFC 000C 6208          add.w     #12,A7
000037D4  601A      6209          bra.s     doprint_37
                    6210   doprint_36:
000037D6  4878 000A 6211          pea       10
000037DA  2F03      6212          move.l    D3,-(A7)
000037DC  206E 0010 6213          move.l    16(A6),A0
000037E0  58AE 0010 6214          addq.l    #4,16(A6)
000037E4  2F10      6215          move.l    (A0),-(A7)
000037E6  4EB9 0000 6216          jsr       _ltoa
000037EA  3CAC      
000037EC  DEFC 000C 6217          add.w     #12,A7
                    6218   doprint_37:
000037F0  6000 0100 6219          bra       doprint_23
                    6220   doprint_26:
000037F4  4A2E FFD3 6221          tst.b     -45(A6)
000037F8  6718      6222          beq.s     doprint_38
000037FA  4878 000A 6223          pea       10
000037FE  2F03      6224          move.l    D3,-(A7)
00003800  206E 0010 6225          move.l    16(A6),A0
00003804  58AE 0010 6226          addq.l    #4,16(A6)
00003808  2F10      6227          move.l    (A0),-(A7)
0000380A  4E94      6228          jsr       (A4)
0000380C  DEFC 000C 6229          add.w     #12,A7
00003810  6016      6230          bra.s     doprint_39
                    6231   doprint_38:
00003812  4878 000A 6232          pea       10
00003816  2F03      6233          move.l    D3,-(A7)
00003818  206E 0010 6234          move.l    16(A6),A0
0000381C  58AE 0010 6235          addq.l    #4,16(A6)
00003820  2F10      6236          move.l    (A0),-(A7)
00003822  4E94      6237          jsr       (A4)
00003824  DEFC 000C 6238          add.w     #12,A7
                    6239   doprint_39:
00003828  6000 00C8 6240          bra       doprint_23
                    6241   doprint_27:
0000382C  4A2E FFD3 6242          tst.b     -45(A6)
00003830  6718      6243          beq.s     doprint_40
00003832  4878 0008 6244          pea       8
00003836  2F03      6245          move.l    D3,-(A7)
00003838  206E 0010 6246          move.l    16(A6),A0
0000383C  58AE 0010 6247          addq.l    #4,16(A6)
00003840  2F10      6248          move.l    (A0),-(A7)
00003842  4E94      6249          jsr       (A4)
00003844  DEFC 000C 6250          add.w     #12,A7
00003848  6016      6251          bra.s     doprint_41
                    6252   doprint_40:
0000384A  4878 0008 6253          pea       8
0000384E  2F03      6254          move.l    D3,-(A7)
00003850  206E 0010 6255          move.l    16(A6),A0
00003854  58AE 0010 6256          addq.l    #4,16(A6)
00003858  2F10      6257          move.l    (A0),-(A7)
0000385A  4E94      6258          jsr       (A4)
0000385C  DEFC 000C 6259          add.w     #12,A7
                    6260   doprint_41:
00003860  6000 0090 6261          bra       doprint_23
                    6262   doprint_28:
00003864  4A2E FFD3 6263          tst.b     -45(A6)
00003868  6718      6264          beq.s     doprint_42
0000386A  4878 0010 6265          pea       16
0000386E  2F03      6266          move.l    D3,-(A7)
00003870  206E 0010 6267          move.l    16(A6),A0
00003874  58AE 0010 6268          addq.l    #4,16(A6)
00003878  2F10      6269          move.l    (A0),-(A7)
0000387A  4E94      6270          jsr       (A4)
0000387C  DEFC 000C 6271          add.w     #12,A7
00003880  6016      6272          bra.s     doprint_43
                    6273   doprint_42:
00003882  4878 0010 6274          pea       16
00003886  2F03      6275          move.l    D3,-(A7)
00003888  206E 0010 6276          move.l    16(A6),A0
0000388C  58AE 0010 6277          addq.l    #4,16(A6)
00003890  2F10      6278          move.l    (A0),-(A7)
00003892  4E94      6279          jsr       (A4)
00003894  DEFC 000C 6280          add.w     #12,A7
                    6281   doprint_43:
00003898  6000 0058 6282          bra       doprint_23
                    6283   doprint_30:
0000389C  206E 0010 6284          move.l    16(A6),A0
000038A0  58AE 0010 6285          addq.l    #4,16(A6)
000038A4  2010      6286          move.l    (A0),D0
000038A6  2042      6287          move.l    D2,A0
000038A8  5282      6288          addq.l    #1,D2
000038AA  1080      6289          move.b    D0,(A0)
000038AC  2042      6290          move.l    D2,A0
000038AE  4210      6291          clr.b     (A0)
000038B0  200D      6292          move.l    A5,D0
000038B2  6704      6293          beq.s     doprint_44
000038B4  200D      6294          move.l    A5,D0
000038B6  6006      6295          bra.s     doprint_45
                    6296   doprint_44:
000038B8  7001      6297          moveq     #1,D0
000038BA  4880      6298          ext.w     D0
000038BC  48C0      6299          ext.l     D0
                    6300   doprint_45:
000038BE  2A00      6301          move.l    D0,D5
000038C0  6000 0030 6302          bra       doprint_23
                    6303   doprint_31:
000038C4  206E 0010 6304          move.l    16(A6),A0
000038C8  58AE 0010 6305          addq.l    #4,16(A6)
000038CC  2610      6306          move.l    (A0),D3
000038CE  0C85 FFFF 6307          cmp.l     #-1,D5
000038D2  FFFF      
000038D4  660C      6308          bne.s     doprint_46
000038D6  2F03      6309          move.l    D3,-(A7)
000038D8  4EB9 0000 6310          jsr       _strlen
000038DC  3E32      
000038DE  584F      6311          addq.w    #4,A7
000038E0  2A00      6312          move.l    D0,D5
                    6313   doprint_46:
000038E2  600E      6314          bra.s     doprint_23
                    6315   doprint_22:
000038E4  206E 000C 6316          move.l    12(A6),A0
000038E8  2242      6317          move.l    D2,A1
000038EA  5282      6318          addq.l    #1,D2
000038EC  1290      6319          move.b    (A0),(A1)
000038EE  2042      6320          move.l    D2,A0
000038F0  4210      6321          clr.b     (A0)
                    6322   doprint_23:
000038F2  2F03      6323          move.l    D3,-(A7)
000038F4  4EB9 0000 6324          jsr       _strlen
000038F8  3E32      
000038FA  584F      6325          addq.w    #4,A7
000038FC  1800      6326          move.b    D0,D4
000038FE  206E 000C 6327          move.l    12(A6),A0
00003902  1010      6328          move.b    (A0),D0
00003904  0C00 0073 6329          cmp.b     #115,D0
00003908  661C      6330          bne.s     doprint_48
0000390A  0C85 0000 6331          cmp.l     #0,D5
0000390E  0000      
00003910  6D14      6332          blt.s     doprint_48
00003912  4884      6333          ext.w     D4
00003914  48C4      6334          ext.l     D4
00003916  B885      6335          cmp.l     D5,D4
00003918  6F04      6336          ble.s     doprint_50
0000391A  2005      6337          move.l    D5,D0
0000391C  6006      6338          bra.s     doprint_51
                    6339   doprint_50:
0000391E  1004      6340          move.b    D4,D0
00003920  4880      6341          ext.w     D0
00003922  48C0      6342          ext.l     D0
                    6343   doprint_51:
00003924  1800      6344          move.b    D0,D4
                    6345   doprint_48:
00003926  206E 000C 6346          move.l    12(A6),A0
0000392A  1010      6347          move.b    (A0),D0
0000392C  0C00 0058 6348          cmp.b     #88,D0
00003930  6600 0026 6349          bne       doprint_56
00003934  41EE FFDC 6350          lea       -36(A6),A0
00003938  2408      6351          move.l    A0,D2
                    6352   doprint_54:
0000393A  2042      6353          move.l    D2,A0
0000393C  4A10      6354          tst.b     (A0)
0000393E  6718      6355          beq.s     doprint_56
00003940  2042      6356          move.l    D2,A0
00003942  1210      6357          move.b    (A0),D1
00003944  4881      6358          ext.w     D1
00003946  48C1      6359          ext.l     D1
00003948  2F01      6360          move.l    D1,-(A7)
0000394A  4EB8 3516 6361          jsr       _toupper
0000394E  584F      6362          addq.w    #4,A7
00003950  2042      6363          move.l    D2,A0
00003952  1080      6364          move.b    D0,(A0)
00003954  5282      6365          addq.l    #1,D2
00003956  60E2      6366          bra       doprint_54
                    6367   doprint_56:
00003958  7E00      6368          moveq     #0,D7
0000395A  41EE FFD4 6369          lea       -44(A6),A0
0000395E  2408      6370          move.l    A0,D2
00003960  206E 000C 6371          move.l    12(A6),A0
00003964  1010      6372          move.b    (A0),D0
00003966  0C00 0064 6373          cmp.b     #100,D0
0000396A  670E      6374          beq.s     doprint_59
0000396C  206E 000C 6375          move.l    12(A6),A0
00003970  1010      6376          move.b    (A0),D0
00003972  0C00 0069 6377          cmp.b     #105,D0
00003976  6600 0068 6378          bne       doprint_65
                    6379   doprint_59:
0000397A  102E FFCE 6380          move.b    -50(A6),D0
0000397E  4880      6381          ext.w     D0
00003980  48C0      6382          ext.l     D0
00003982  4A80      6383          tst.l     D0
00003984  660C      6384          bne.s     doprint_62
00003986  2043      6385          move.l    D3,A0
00003988  1010      6386          move.b    (A0),D0
0000398A  0C00 002D 6387          cmp.b     #45,D0
0000398E  6600 0028 6388          bne       doprint_60
                    6389   doprint_62:
00003992  2043      6390          move.l    D3,A0
00003994  1010      6391          move.b    (A0),D0
00003996  0C00 002D 6392          cmp.b     #45,D0
0000399A  660E      6393          bne.s     doprint_63
0000399C  2043      6394          move.l    D3,A0
0000399E  5283      6395          addq.l    #1,D3
000039A0  2242      6396          move.l    D2,A1
000039A2  5282      6397          addq.l    #1,D2
000039A4  1290      6398          move.b    (A0),(A1)
000039A6  5304      6399          subq.b    #1,D4
000039A8  6008      6400          bra.s     doprint_64
                    6401   doprint_63:
000039AA  2042      6402          move.l    D2,A0
000039AC  5282      6403          addq.l    #1,D2
000039AE  10BC 002B 6404          move.b    #43,(A0)
                    6405   doprint_64:
000039B2  5287      6406          addq.l    #1,D7
000039B4  6000 002A 6407          bra       doprint_65
                    6408   doprint_60:
000039B8  4A2E FFCF 6409          tst.b     -49(A6)
000039BC  6722      6410          beq.s     doprint_65
000039BE  2043      6411          move.l    D3,A0
000039C0  1010      6412          move.b    (A0),D0
000039C2  0C00 002D 6413          cmp.b     #45,D0
000039C6  660E      6414          bne.s     doprint_67
000039C8  2043      6415          move.l    D3,A0
000039CA  5283      6416          addq.l    #1,D3
000039CC  2242      6417          move.l    D2,A1
000039CE  5282      6418          addq.l    #1,D2
000039D0  1290      6419          move.b    (A0),(A1)
000039D2  5304      6420          subq.b    #1,D4
000039D4  6008      6421          bra.s     doprint_68
                    6422   doprint_67:
000039D6  2042      6423          move.l    D2,A0
000039D8  5282      6424          addq.l    #1,D2
000039DA  10BC 0020 6425          move.b    #32,(A0)
                    6426   doprint_68:
000039DE  5287      6427          addq.l    #1,D7
                    6428   doprint_65:
000039E0  4A2E FFD0 6429          tst.b     -48(A6)
000039E4  6700 005A 6430          beq       doprint_77
000039E8  206E 000C 6431          move.l    12(A6),A0
000039EC  1010      6432          move.b    (A0),D0
000039EE  4880      6433          ext.w     D0
000039F0  48C0      6434          ext.l     D0
000039F2  0C80 0000 6435          cmp.l     #111,D0
000039F6  006F      
000039F8  671A      6436          beq.s     doprint_73
000039FA  6E0C      6437          bgt.s     doprint_76
000039FC  0C80 0000 6438          cmp.l     #88,D0
00003A00  0058      
00003A02  6710      6439          beq.s     doprint_73
00003A04  6000 003A 6440          bra       doprint_77
                    6441   doprint_76:
00003A08  0C80 0000 6442          cmp.l     #120,D0
00003A0C  0078      
00003A0E  6704      6443          beq.s     doprint_73
00003A10  6000 002E 6444          bra       doprint_77
                    6445   doprint_73:
00003A14  2042      6446          move.l    D2,A0
00003A16  5282      6447          addq.l    #1,D2
00003A18  10BC 0030 6448          move.b    #48,(A0)
00003A1C  5287      6449          addq.l    #1,D7
00003A1E  206E 000C 6450          move.l    12(A6),A0
00003A22  1010      6451          move.b    (A0),D0
00003A24  0C00 0078 6452          cmp.b     #120,D0
00003A28  670C      6453          beq.s     doprint_79
00003A2A  206E 000C 6454          move.l    12(A6),A0
00003A2E  1010      6455          move.b    (A0),D0
00003A30  0C00 0058 6456          cmp.b     #88,D0
00003A34  660A      6457          bne.s     doprint_77
                    6458   doprint_79:
00003A36  2042      6459          move.l    D2,A0
00003A38  5282      6460          addq.l    #1,D2
00003A3A  10BC 0078 6461          move.b    #120,(A0)
00003A3E  5287      6462          addq.l    #1,D7
                    6463   doprint_77:
00003A40  2042      6464          move.l    D2,A0
00003A42  4210      6465          clr.b     (A0)
00003A44  206E 000C 6466          move.l    12(A6),A0
00003A48  1010      6467          move.b    (A0),D0
00003A4A  4880      6468          ext.w     D0
00003A4C  48C0      6469          ext.l     D0
00003A4E  0C80 0000 6470          cmp.l     #105,D0
00003A52  0069      
00003A54  6700 0076 6471          beq       doprint_82
00003A58  6E42      6472          bgt.s     doprint_93
00003A5A  0C80 0000 6473          cmp.l     #99,D0
00003A5E  0063      
00003A60  6700 0084 6474          beq       doprint_96
00003A64  6E1C      6475          bgt.s     doprint_94
00003A66  0C80 0000 6476          cmp.l     #88,D0
00003A6A  0058      
00003A6C  6700 005E 6477          beq       doprint_82
00003A70  6E00 0184 6478          bgt       doprint_80
00003A74  0C80 0000 6479          cmp.l     #69,D0
00003A78  0045      
00003A7A  6700 0050 6480          beq       doprint_82
00003A7E  6000 0176 6481          bra       doprint_80
                    6482   doprint_94:
00003A82  0C80 0000 6483          cmp.l     #101,D0
00003A86  0065      
00003A88  6700 0042 6484          beq       doprint_82
00003A8C  6E00 0168 6485          bgt       doprint_80
00003A90  0C80 0000 6486          cmp.l     #100,D0
00003A94  0064      
00003A96  6734      6487          beq.s     doprint_82
00003A98  6000 015C 6488          bra       doprint_80
                    6489   doprint_93:
00003A9C  0C80 0000 6490          cmp.l     #117,D0
00003AA0  0075      
00003AA2  6728      6491          beq.s     doprint_82
00003AA4  6E1A      6492          bgt.s     doprint_95
00003AA6  0C80 0000 6493          cmp.l     #115,D0
00003AAA  0073      
00003AAC  6700 0038 6494          beq       doprint_96
00003AB0  6E00 0144 6495          bgt       doprint_80
00003AB4  0C80 0000 6496          cmp.l     #111,D0
00003AB8  006F      
00003ABA  6710      6497          beq.s     doprint_82
00003ABC  6000 0138 6498          bra       doprint_80
                    6499   doprint_95:
00003AC0  0C80 0000 6500          cmp.l     #120,D0
00003AC4  0078      
00003AC6  6704      6501          beq.s     doprint_82
00003AC8  6000 012C 6502          bra       doprint_80
                    6503   doprint_82:
00003ACC  4A2E FFD2 6504          tst.b     -46(A6)
00003AD0  6714      6505          beq.s     doprint_96
00003AD2  4A2E FFCD 6506          tst.b     -51(A6)
00003AD6  660E      6507          bne.s     doprint_96
00003AD8  200D      6508          move.l    A5,D0
00003ADA  9087      6509          sub.l     D7,D0
00003ADC  4884      6510          ext.w     D4
00003ADE  48C4      6511          ext.l     D4
00003AE0  9084      6512          sub.l     D4,D0
00003AE2  2D40 FFFC 6513          move.l    D0,-4(A6)
                    6514   doprint_96:
00003AE6  202E FFFC 6515          move.l    -4(A6),D0
00003AEA  0C80 0000 6516          cmp.l     #0,D0
00003AEE  0000      
00003AF0  6C04      6517          bge.s     doprint_98
00003AF2  42AE FFFC 6518          clr.l     -4(A6)
                    6519   doprint_98:
00003AF6  4A2E FFCD 6520          tst.b     -51(A6)
00003AFA  6600 0030 6521          bne       doprint_104
00003AFE  1004      6522          move.b    D4,D0
00003B00  4880      6523          ext.w     D0
00003B02  48C0      6524          ext.l     D0
00003B04  D0AE FFFC 6525          add.l     -4(A6),D0
00003B08  D087      6526          add.l     D7,D0
00003B0A  1D40 FFD1 6527          move.b    D0,-47(A6)
                    6528   doprint_102:
00003B0E  102E FFD1 6529          move.b    -47(A6),D0
00003B12  4880      6530          ext.w     D0
00003B14  48C0      6531          ext.l     D0
00003B16  220D      6532          move.l    A5,D1
00003B18  534D      6533          subq.w    #1,A5
00003B1A  B081      6534          cmp.l     D1,D0
00003B1C  6C0E      6535          bge.s     doprint_104
00003B1E  4878 0020 6536          pea       32
00003B22  2F0A      6537          move.l    A2,-(A7)
00003B24  4E93      6538          jsr       (A3)
00003B26  504F      6539          addq.w    #8,A7
00003B28  5286      6540          addq.l    #1,D6
00003B2A  60E2      6541          bra       doprint_102
                    6542   doprint_104:
00003B2C  41EE FFD4 6543          lea       -44(A6),A0
00003B30  2408      6544          move.l    A0,D2
                    6545   doprint_105:
00003B32  2042      6546          move.l    D2,A0
00003B34  4A10      6547          tst.b     (A0)
00003B36  6716      6548          beq.s     doprint_107
00003B38  2042      6549          move.l    D2,A0
00003B3A  5282      6550          addq.l    #1,D2
00003B3C  1210      6551          move.b    (A0),D1
00003B3E  4881      6552          ext.w     D1
00003B40  48C1      6553          ext.l     D1
00003B42  2F01      6554          move.l    D1,-(A7)
00003B44  2F0A      6555          move.l    A2,-(A7)
00003B46  4E93      6556          jsr       (A3)
00003B48  504F      6557          addq.w    #8,A7
00003B4A  5286      6558          addq.l    #1,D6
00003B4C  60E4      6559          bra       doprint_105
                    6560   doprint_107:
00003B4E  202E FFFC 6561          move.l    -4(A6),D0
00003B52  1D40 FFD1 6562          move.b    D0,-47(A6)
                    6563   doprint_108:
00003B56  102E FFD1 6564          move.b    -47(A6),D0
00003B5A  532E FFD1 6565          subq.b    #1,-47(A6)
00003B5E  4A00      6566          tst.b     D0
00003B60  670E      6567          beq.s     doprint_110
00003B62  4878 0030 6568          pea       48
00003B66  2F0A      6569          move.l    A2,-(A7)
00003B68  4E93      6570          jsr       (A3)
00003B6A  504F      6571          addq.w    #8,A7
00003B6C  5286      6572          addq.l    #1,D6
00003B6E  60E6      6573          bra       doprint_108
                    6574   doprint_110:
00003B70  2043      6575          move.l    D3,A0
00003B72  4A10      6576          tst.b     (A0)
00003B74  6700 0048 6577          beq       doprint_113
00003B78  206E 000C 6578          move.l    12(A6),A0
00003B7C  1010      6579          move.b    (A0),D0
00003B7E  4880      6580          ext.w     D0
00003B80  48C0      6581          ext.l     D0
00003B82  0C80 0000 6582          cmp.l     #115,D0
00003B86  0073      
00003B88  670C      6583          beq.s     doprint_116
00003B8A  6E18      6584          bgt.s     doprint_119
00003B8C  0C80 0000 6585          cmp.l     #99,D0
00003B90  0063      
00003B92  6702      6586          beq.s     doprint_116
00003B94  600E      6587          bra.s     doprint_119
                    6588   doprint_116:
00003B96  2005      6589          move.l    D5,D0
00003B98  5385      6590          subq.l    #1,D5
00003B9A  0C80 0000 6591          cmp.l     #0,D0
00003B9E  0000      
00003BA0  6E02      6592          bgt.s     doprint_119
00003BA2  6016      6593          bra.s     doprint_115
                    6594   doprint_119:
00003BA4  2043      6595          move.l    D3,A0
00003BA6  5283      6596          addq.l    #1,D3
00003BA8  1210      6597          move.b    (A0),D1
00003BAA  4881      6598          ext.w     D1
00003BAC  48C1      6599          ext.l     D1
00003BAE  2F01      6600          move.l    D1,-(A7)
00003BB0  2F0A      6601          move.l    A2,-(A7)
00003BB2  4E93      6602          jsr       (A3)
00003BB4  504F      6603          addq.w    #8,A7
00003BB6  5286      6604          addq.l    #1,D6
00003BB8  6002      6605          bra.s     doprint_112
                    6606   doprint_115:
00003BBA  6002      6607          bra.s     doprint_113
                    6608   doprint_112:
00003BBC  60B2      6609          bra       doprint_110
                    6610   doprint_113:
00003BBE  4A2E FFCD 6611          tst.b     -51(A6)
00003BC2  6700 0030 6612          beq       doprint_125
00003BC6  1004      6613          move.b    D4,D0
00003BC8  4880      6614          ext.w     D0
00003BCA  48C0      6615          ext.l     D0
00003BCC  D0AE FFFC 6616          add.l     -4(A6),D0
00003BD0  D087      6617          add.l     D7,D0
00003BD2  1D40 FFD1 6618          move.b    D0,-47(A6)
                    6619   doprint_123:
00003BD6  102E FFD1 6620          move.b    -47(A6),D0
00003BDA  4880      6621          ext.w     D0
00003BDC  48C0      6622          ext.l     D0
00003BDE  220D      6623          move.l    A5,D1
00003BE0  534D      6624          subq.w    #1,A5
00003BE2  B081      6625          cmp.l     D1,D0
00003BE4  6C0E      6626          bge.s     doprint_125
00003BE6  4878 0020 6627          pea       32
00003BEA  2F0A      6628          move.l    A2,-(A7)
00003BEC  4E93      6629          jsr       (A3)
00003BEE  504F      6630          addq.w    #8,A7
00003BF0  5386      6631          subq.l    #1,D6
00003BF2  60E2      6632          bra       doprint_123
                    6633   doprint_125:
00003BF4  6014      6634          bra.s     doprint_81
                    6635   doprint_80:
00003BF6  206E 000C 6636          move.l    12(A6),A0
00003BFA  1210      6637          move.b    (A0),D1
00003BFC  4881      6638          ext.w     D1
00003BFE  48C1      6639          ext.l     D1
00003C00  2F01      6640          move.l    D1,-(A7)
00003C02  2F0A      6641          move.l    A2,-(A7)
00003C04  4E93      6642          jsr       (A3)
00003C06  504F      6643          addq.w    #8,A7
00003C08  5286      6644          addq.l    #1,D6
                    6645   doprint_81:
00003C0A  52AE 000C 6646          addq.l    #1,12(A6)
                    6647   doprint_2:
00003C0E  6000 FA10 6648          bra       doprint_1
                    6649   doprint_3:
00003C12  4A92      6650          tst.l     (A2)
00003C14  6710      6651          beq.s     doprint_126
00003C16  4201      6652          clr.b     D1
00003C18  C2BC 0000 6653          and.l     #255,D1
00003C1C  00FF      
00003C1E  2F01      6654          move.l    D1,-(A7)
00003C20  2F0A      6655          move.l    A2,-(A7)
00003C22  4E93      6656          jsr       (A3)
00003C24  504F      6657          addq.w    #8,A7
                    6658   doprint_126:
00003C26  2006      6659          move.l    D6,D0
00003C28  4CDF 3CFC 6660          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003C2C  4E5E      6661          unlk      A6
00003C2E  4E75      6662          rts
                    6663   @itoa_convert:
00003C30  4E56 0000 6664          link      A6,#0
00003C34  48E7 3C00 6665          movem.l   D2/D3/D4/D5,-(A7)
00003C38  242E 0008 6666          move.l    8(A6),D2
00003C3C  262E 0010 6667          move.l    16(A6),D3
00003C40  2A2E 000C 6668          move.l    12(A6),D5
00003C44  2F05      6669          move.l    D5,-(A7)
00003C46  2F03      6670          move.l    D3,-(A7)
00003C48  4EB8 3370 6671          jsr       ULDIV
00003C4C  202F 0004 6672          move.l    4(A7),D0
00003C50  504F      6673          addq.w    #8,A7
00003C52  2800      6674          move.l    D0,D4
00003C54  BA83      6675          cmp.l     D3,D5
00003C56  651C      6676          blo.s     @itoa_convert_1
00003C58  2F03      6677          move.l    D3,-(A7)
00003C5A  2F05      6678          move.l    D5,-(A7)
00003C5C  2F03      6679          move.l    D3,-(A7)
00003C5E  4EB8 3370 6680          jsr       ULDIV
00003C62  2217      6681          move.l    (A7),D1
00003C64  504F      6682          addq.w    #8,A7
00003C66  2F01      6683          move.l    D1,-(A7)
00003C68  2F02      6684          move.l    D2,-(A7)
00003C6A  4EB8 3C30 6685          jsr       @itoa_convert
00003C6E  DEFC 000C 6686          add.w     #12,A7
00003C72  2400      6687          move.l    D0,D2
                    6688   @itoa_convert_1:
00003C74  0C84 0000 6689          cmp.l     #9,D4
00003C78  0009      
00003C7A  6E0E      6690          bgt.s     @itoa_convert_3
00003C7C  2004      6691          move.l    D4,D0
00003C7E  7230      6692          moveq     #48,D1
00003C80  C2BC 0000 6693          and.l     #255,D1
00003C84  00FF      
00003C86  D081      6694          add.l     D1,D0
00003C88  6012      6695          bra.s     @itoa_convert_4
                    6696   @itoa_convert_3:
00003C8A  2004      6697          move.l    D4,D0
00003C8C  7261      6698          moveq     #97,D1
00003C8E  C2BC 0000 6699          and.l     #255,D1
00003C92  00FF      
00003C94  D081      6700          add.l     D1,D0
00003C96  0480 0000 6701          sub.l     #10,D0
00003C9A  000A      
                    6702   @itoa_convert_4:
00003C9C  2042      6703          move.l    D2,A0
00003C9E  1080      6704          move.b    D0,(A0)
00003CA0  2002      6705          move.l    D2,D0
00003CA2  5280      6706          addq.l    #1,D0
00003CA4  4CDF 003C 6707          movem.l   (A7)+,D2/D3/D4/D5
00003CA8  4E5E      6708          unlk      A6
00003CAA  4E75      6709          rts
                    6710   _ltoa:
00003CAC  4E56 0000 6711          link      A6,#0
00003CB0  48E7 3C00 6712          movem.l   D2/D3/D4/D5,-(A7)
00003CB4  242E 0008 6713          move.l    8(A6),D2
00003CB8  262E 000C 6714          move.l    12(A6),D3
00003CBC  2A2E 0010 6715          move.l    16(A6),D5
00003CC0  2803      6716          move.l    D3,D4
00003CC2  0C85 0000 6717          cmp.l     #2,D5
00003CC6  0002      
00003CC8  6D08      6718          blt.s     ltoa_3
00003CCA  0C85 0000 6719          cmp.l     #36,D5
00003CCE  0024      
00003CD0  6F06      6720          ble.s     ltoa_1
                    6721   ltoa_3:
00003CD2  2003      6722          move.l    D3,D0
00003CD4  6000 0052 6723          bra       ltoa_4
                    6724   ltoa_1:
00003CD8  0C85 0000 6725          cmp.l     #10,D5
00003CDC  000A      
00003CDE  6600 0032 6726          bne       ltoa_5
00003CE2  0C82 0000 6727          cmp.l     #0,D2
00003CE6  0000      
00003CE8  6C28      6728          bge.s     ltoa_5
00003CEA  2002      6729          move.l    D2,D0
00003CEC  4480      6730          neg.l     D0
00003CEE  2400      6731          move.l    D0,D2
00003CF0  0C82 0000 6732          cmp.l     #0,D2
00003CF4  0000      
00003CF6  6C12      6733          bge.s     ltoa_7
00003CF8  4879 0000 6734          pea       @itoa_1.L
00003CFC  557E      
00003CFE  2F03      6735          move.l    D3,-(A7)
00003D00  4EB8 3360 6736          jsr       _strcpy
00003D04  504F      6737          addq.w    #8,A7
00003D06  2003      6738          move.l    D3,D0
00003D08  601E      6739          bra.s     ltoa_4
                    6740   ltoa_7:
00003D0A  2044      6741          move.l    D4,A0
00003D0C  5284      6742          addq.l    #1,D4
00003D0E  10BC 002D 6743          move.b    #45,(A0)
                    6744   ltoa_5:
00003D12  2F05      6745          move.l    D5,-(A7)
00003D14  2F02      6746          move.l    D2,-(A7)
00003D16  2F04      6747          move.l    D4,-(A7)
00003D18  4EB8 3C30 6748          jsr       @itoa_convert
00003D1C  DEFC 000C 6749          add.w     #12,A7
00003D20  2800      6750          move.l    D0,D4
00003D22  2044      6751          move.l    D4,A0
00003D24  4210      6752          clr.b     (A0)
00003D26  2003      6753          move.l    D3,D0
                    6754   ltoa_4:
00003D28  4CDF 003C 6755          movem.l   (A7)+,D2/D3/D4/D5
00003D2C  4E5E      6756          unlk      A6
00003D2E  4E75      6757          rts
                    6758   _ultoa:
00003D30  4E56 0000 6759          link      A6,#0
00003D34  48E7 3800 6760          movem.l   D2/D3/D4,-(A7)
00003D38  262E 0010 6761          move.l    16(A6),D3
00003D3C  282E 000C 6762          move.l    12(A6),D4
00003D40  2404      6763          move.l    D4,D2
00003D42  0C83 0000 6764          cmp.l     #2,D3
00003D46  0002      
00003D48  6D08      6765          blt.s     ultoa_3
00003D4A  0C83 0000 6766          cmp.l     #36,D3
00003D4E  0024      
00003D50  6F04      6767          ble.s     ultoa_1
                    6768   ultoa_3:
00003D52  2004      6769          move.l    D4,D0
00003D54  6018      6770          bra.s     ultoa_4
                    6771   ultoa_1:
00003D56  2F03      6772          move.l    D3,-(A7)
00003D58  2F2E 0008 6773          move.l    8(A6),-(A7)
00003D5C  2F02      6774          move.l    D2,-(A7)
00003D5E  4EB8 3C30 6775          jsr       @itoa_convert
00003D62  DEFC 000C 6776          add.w     #12,A7
00003D66  2400      6777          move.l    D0,D2
00003D68  2042      6778          move.l    D2,A0
00003D6A  4210      6779          clr.b     (A0)
00003D6C  2004      6780          move.l    D4,D0
                    6781   ultoa_4:
00003D6E  4CDF 001C 6782          movem.l   (A7)+,D2/D3/D4
00003D72  4E5E      6783          unlk      A6
00003D74  4E75      6784          rts
                    6785   _itoa:
00003D76  4E56 0000 6786          link      A6,#0
00003D7A  2F2E 0010 6787          move.l    16(A6),-(A7)
00003D7E  2F2E 000C 6788          move.l    12(A6),-(A7)
00003D82  2F2E 0008 6789          move.l    8(A6),-(A7)
00003D86  4EB8 3CAC 6790          jsr       _ltoa
00003D8A  DEFC 000C 6791          add.w     #12,A7
00003D8E  4E5E      6792          unlk      A6
00003D90  4E75      6793          rts
                    6794   ULMUL:
00003D92  4E56 0000 6795          link    A6,#0
00003D96  48E7 C000 6796          movem.l D0/D1,-(A7)
00003D9A  222E 0008 6797          move.l  8(A6),D1
00003D9E  202E 000C 6798          move.l  12(A6),D0
00003DA2  602C      6799          bra.s   lmul_3
                    6800   LMUL:
00003DA4  4E56 0000 6801          link    A6,#0
00003DA8  48E7 C000 6802          movem.l D0/D1,-(A7)
00003DAC  222E 0008 6803          move.l  8(A6),D1
00003DB0  202E 000C 6804          move.l  12(A6),D0
00003DB4  4A80      6805          tst.l   D0
00003DB6  6A0A      6806          bpl.s   lmul_1
00003DB8  4480      6807          neg.l   D0
00003DBA  4A81      6808          tst.l   D1
00003DBC  6A0A      6809          bpl.s   lmul_2
00003DBE  4481      6810          neg.l   D1
00003DC0  600E      6811          bra.s   lmul_3
                    6812   lmul_1:
00003DC2  4A81      6813          tst.l   D1
00003DC4  6A0A      6814          bpl.s   lmul_3
00003DC6  4481      6815          neg.l   D1
                    6816   lmul_2:
00003DC8  6114      6817          bsr.s   domul
00003DCA  4481      6818          neg.l   D1
00003DCC  4080      6819          negx.l  D0
00003DCE  6002      6820          bra.s   lmul_4
                    6821   lmul_3:
00003DD0  610C      6822          bsr.s   domul
                    6823   lmul_4:
00003DD2  2D41 0008 6824          move.l  D1,8(A6)
00003DD6  4CDF 0003 6825          movem.l (A7)+,D0/D1
00003DDA  4E5E      6826          unlk    A6
00003DDC  4E75      6827          rts
                    6828   domul:
00003DDE  0C81 0000 6829          cmpi.l  #$FFFF,D1
00003DE2  FFFF      
00003DE4  620C      6830          bhi.s   domul_1
00003DE6  0C80 0000 6831          cmpi.l  #$FFFF,D0
00003DEA  FFFF      
00003DEC  620E      6832          bhi.s   domul_2
00003DEE  C2C0      6833          mulu    D0,D1
00003DF0  4E75      6834          rts
                    6835   domul_1:
00003DF2  0C80 0000 6836          cmpi.l  #$FFFF,D0
00003DF6  FFFF      
00003DF8  6218      6837          bhi.s   domul_4
00003DFA  6002      6838          bra.s   domul_3
                    6839   domul_2
00003DFC  C141      6840          exg     D0,D1
                    6841   domul_3:
00003DFE  2F02      6842          move.l  D2,-(A7)
00003E00  2401      6843          move.l  D1,D2
00003E02  4842      6844          swap    D2
00003E04  C2C0      6845          mulu    D0,D1
00003E06  C4C0      6846          mulu    D0,D2
00003E08  4842      6847          swap    D2
00003E0A  4242      6848          clr.w   D2
00003E0C  D282      6849          add.l   D2,D1
00003E0E  241F      6850          move.l  (A7)+,D2
00003E10  4E75      6851          rts
                    6852   domul_4:
00003E12  48E7 3000 6853          movem.l D2/D3,-(A7)
00003E16  2401      6854          move.l  D1,D2
00003E18  2601      6855          move.l  D1,D3
00003E1A  C2C0      6856          mulu    D0,D1
00003E1C  4842      6857          swap    D2
00003E1E  C4C0      6858          mulu    D0,D2
00003E20  4840      6859          swap    D0
00003E22  C6C0      6860          mulu    D0,D3
00003E24  D483      6861          add.l   D3,D2
00003E26  4842      6862          swap    D2
00003E28  4242      6863          clr.w   D2
00003E2A  D282      6864          add.l   D2,D1
00003E2C  4CDF 000C 6865          movem.l (A7)+,D2/D3
00003E30  4E75      6866          rts
                    6867   _strlen:
00003E32  206F 0004 6868          move.l    (4,A7),A0
00003E36  2248      6869          move.l    A0,A1
                    6870   strlen_1:
00003E38  4A19      6871          tst.b     (A1)+
00003E3A  66FC      6872          bne       strlen_1
00003E3C  2009      6873          move.l    A1,D0
00003E3E  9088      6874          sub.l     A0,D0
00003E40  5380      6875          subq.l    #1,D0
00003E42  4E75      6876          rts
                    6877          section   const
                    6878   
                    6879   @m68kde~2_1:
00003E44  0D0A 00   6880          dc.b      13,10,0
                    6881   @m68kde~2_2:
00003E48  0D53 7769 6882          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00003E4C  7463 6865 
00003E50  7320 5357 
00003E54  5B        
00003E55  372D 305D 6883          dc.b      55,45,48,93,32,61,32,0
00003E59  203D 2000 
                    6884   @m68kde~2_3:
00003E5E  3000      6885          dc.b      48,0
                    6886   @m68kde~2_4:
00003E60  3100      6887          dc.b      49,0
                    6888   @m68kde~2_5:
00003E62  0D0A 4475 6889          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00003E66  6D70 204D 
00003E6A  656D 6F72 
00003E6E  79        
00003E6F  2042 6C6F 6890          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00003E73  636B 3A20 
00003E77  3C45 5343 
00003E7B  3E20      
00003E7D  746F 2041 6891          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00003E81  626F 7274 
00003E85  2C20 3C53 
00003E89  50        
00003E8A  4143 453E 6892          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00003E8E  2074 6F20 
00003E92  436F 6E74 
00003E96  69        
00003E97  6E75 6500 6893          dc.b      110,117,101,0
                    6894   @m68kde~2_6:
00003E9C  0D0A 456E 6895          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00003EA0  7465 7220 
00003EA4  5374 6172 
00003EA8  74        
00003EA9  2041 6464 6896          dc.b      32,65,100,100,114,101,115,115,58,32,0
00003EAD  7265 7373 
00003EB1  3A20 00   
                    6897   @m68kde~2_7:
00003EB4  0D0A 2530 6898          dc.b      13,10,37,48,56,120,32,0
00003EB8  3878 2000 
                    6899   @m68kde~2_8:
00003EBC  2530 3258 6900          dc.b      37,48,50,88,0
00003EC0  00        
                    6901   @m68kde~2_9:
00003EC2  2020 00   6902          dc.b      32,32,0
                    6903   @m68kde~2_10:
00003EC6  0D0A 4669 6904          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00003ECA  6C6C 204D 
00003ECE  656D 6F72 
00003ED2  79        
00003ED3  2042 6C6F 6905          dc.b      32,66,108,111,99,107,0
00003ED7  636B 00   
                    6906   @m68kde~2_11:
00003EDA  0D0A 456E 6907          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00003EDE  7465 7220 
00003EE2  456E 6420 
00003EE6  41        
00003EE7  6464 7265 6908          dc.b      100,100,114,101,115,115,58,32,0
00003EEB  7373 3A20 
00003EEF  00        
                    6909   @m68kde~2_12:
00003EF0  0D0A 456E 6910          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00003EF4  7465 7220 
00003EF8  4669 6C6C 
00003EFC  20        
00003EFD  4461 7461 6911          dc.b      68,97,116,97,58,32,0
00003F01  3A20 00   
                    6912   @m68kde~2_13:
00003F04  0D0A 4669 6913          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00003F08  6C6C 696E 
00003F0C  6720 4164 
00003F10  64        
00003F11  7265 7373 6914          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00003F15  6573 205B 
00003F19  2425 3038 
00003F1D  58        
00003F1E  202D 2024 6915          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00003F22  2530 3858 
00003F26  5D20 7769 
00003F2A  7468      
00003F2C  2024 2530 6916          dc.b      32,36,37,48,50,88,0
00003F30  3258 00   
                    6917   @m68kde~2_14:
00003F34  0D0A 5573 6918          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00003F38  6520 4879 
00003F3C  7065 7254 
00003F40  65        
00003F41  726D 696E 6919          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00003F45  616C 2074 
00003F49  6F20 5365 
00003F4D  6E64 2054 6920          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00003F51  6578 7420 
00003F55  4669 6C65 
00003F59  2028 2E68 6921          dc.b      32,40,46,104,101,120,41,13,10,0
00003F5D  6578 290D 
00003F61  0A00      
                    6922   @m68kde~2_15:
00003F64  0D0A 4C6F 6923          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00003F68  6164 2046 
00003F6C  6169 6C65 
00003F70  64        
00003F71  2061 7420 6924          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00003F75  4164 6472 
00003F79  6573 7320 
00003F7D  3D        
00003F7E  205B 2425 6925          dc.b      32,91,36,37,48,56,88,93,13,10,0
00003F82  3038 585D 
00003F86  0D0A 00   
                    6926   @m68kde~2_16:
00003F8A  0D0A 5375 6927          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00003F8E  6363 6573 
00003F92  733A 2044 
00003F96  6F        
00003F97  776E 6C6F 6928          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00003F9B  6164 6564 
00003F9F  2025 6420 
00003FA3  6279 7465 6929          dc.b      98,121,116,101,115,13,10,0
00003FA7  730D 0A00 
                    6930   @m68kde~2_17:
00003FAC  0D0A 4578 6931          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00003FB0  616D 696E 
00003FB4  6520 616E 
00003FB8  64        
00003FB9  2043 6861 6932          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00003FBD  6E67 6520 
00003FC1  4D65 6D6F 
00003FC5  72        
00003FC6  7900      6933          dc.b      121,0
                    6934   @m68kde~2_18:
00003FC8  0D0A 3C45 6935          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00003FCC  5343 3E20 
00003FD0  746F 2053 
00003FD4  746F      
00003FD6  702C 203C 6936          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00003FDA  5350 4143 
00003FDE  453E 2074 
00003FE2  6F20      
00003FE4  4164 7661 6937          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00003FE8  6E63 652C 
00003FEC  2027 2D27 
00003FF0  2074      
00003FF2  6F20 476F 6938          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00003FF6  2042 6163 
00003FFA  6B2C 203C 
00003FFE  4441      
00004000  5441 3E20 6939          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00004004  746F 2063 
00004008  6861 6E67 
0000400C  65        
0000400D  00        6940          dc.b      0
                    6941   @m68kde~2_19:
0000400E  0D0A 456E 6942          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00004012  7465 7220 
00004016  4164 6472 
0000401A  65        
0000401B  7373 3A20 6943          dc.b      115,115,58,32,0
0000401F  00        
                    6944   @m68kde~2_20:
00004020  0D0A 5B25 6945          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00004024  3038 785D 
00004028  203A 2025 
0000402C  3032 78   
0000402F  2020 00   6946          dc.b      32,32,0
                    6947   @m68kde~2_21:
00004032  0D0A 5761 6948          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00004036  726E 696E 
0000403A  6720 4368 
0000403E  61        
0000403F  6E67 6520 6949          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00004043  4661 696C 
00004047  6564 3A20 
0000404B  57        
0000404C  726F 7465 6950          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00004050  205B 2530 
00004054  3278 5D2C 
00004058  20        
00004059  5265 6164 6951          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
0000405D  205B 2530 
00004061  3278 5D00 
                    6952   @m68kde~2_22:
00004066  0D0A 4572 6953          dc.b      13,10,69,114,97,115,105,110,103,32,70,108,97
0000406A  6173 696E 
0000406E  6720 466C 
00004072  61        
00004073  7368 2063 6954          dc.b      115,104,32,99,104,105,112,46,46,46,46,0
00004077  6869 702E 
0000407B  2E2E 2E00 
                    6955   @m68kde~2_23:
00004080  0D0A 2A2A 6956          dc.b      13,10,42,42,42,42,42,42,42,42,70,105,110,105
00004084  2A2A 2A2A 
00004088  2A2A 4669 
0000408C  6E69      
0000408E  7368 6564 6957          dc.b      115,104,101,100,32,101,114,97,115,105,110,103
00004092  2065 7261 
00004096  7369 6E67 
0000409A  2A2A 2A2A 6958          dc.b      42,42,42,42,42,42,42,42,0
0000409E  2A2A 2A2A 
000040A2  00        
                    6959   @m68kde~2_24:
000040A4  0D0A 5772 6960          dc.b      13,10,87,114,105,116,105,110,103,32,80,114,111
000040A8  6974 696E 
000040AC  6720 5072 
000040B0  6F        
000040B1  6772 616D 6961          dc.b      103,114,97,109,32,116,111,32,102,108,97,115
000040B5  2074 6F20 
000040B9  666C 6173 
000040BD  682E 2E2E 6962          dc.b      104,46,46,46,46,0
000040C1  2E00      
                    6963   @m68kde~2_25:
000040C4  0D0A 2A2A 6964          dc.b      13,10,42,42,42,42,42,42,42,42,70,108,97,115
000040C8  2A2A 2A2A 
000040CC  2A2A 466C 
000040D0  6173      
000040D2  6820 5072 6965          dc.b      104,32,80,114,111,103,114,97,109,109,101,100
000040D6  6F67 7261 
000040DA  6D6D 6564 
000040DE  2A2A 2A2A 6966          dc.b      42,42,42,42,42,42,42,42,0
000040E2  2A2A 2A2A 
000040E6  00        
                    6967   @m68kde~2_26:
000040E8  0D0A 5665 6968          dc.b      13,10,86,101,114,105,102,121,105,110,103,32
000040EC  7269 6679 
000040F0  696E 6720 
000040F4  7468 6520 6969          dc.b      116,104,101,32,114,101,97,100,46,46,46,46,0
000040F8  7265 6164 
000040FC  2E2E 2E2E 
00004100  00        
                    6970   @m68kde~2_27:
00004102  0D0A 4572 6971          dc.b      13,10,69,114,114,111,114,58,32,68,97,116,97
00004106  726F 723A 
0000410A  2044 6174 
0000410E  61        
0000410F  206D 6973 6972          dc.b      32,109,105,115,109,97,116,99,104,32,97,116,32
00004113  6D61 7463 
00004117  6820 6174 
0000411B  20        
0000411C  6C6F 6361 6973          dc.b      108,111,99,97,116,105,111,110,32,37,48,56,120
00004120  7469 6F6E 
00004124  2025 3038 
00004128  78        
00004129  2E20 4578 6974          dc.b      46,32,69,120,112,101,99,116,101,100,32,100,97
0000412D  7065 6374 
00004131  6564 2064 
00004135  61        
00004136  7461 203D 6975          dc.b      116,97,32,61,32,37,48,50,120,59,32,65,99,116
0000413A  2025 3032 
0000413E  783B 2041 
00004142  6374      
00004144  7561 6C20 6976          dc.b      117,97,108,32,68,97,116,97,32,37,48,50,120,0
00004148  4461 7461 
0000414C  2025 3032 
00004150  7800      
                    6977   @m68kde~2_28:
00004152  0D0A 2A2A 6978          dc.b      13,10,42,42,42,42,42,42,42,42,87,114,105,116
00004156  2A2A 2A2A 
0000415A  2A2A 5772 
0000415E  6974      
00004160  696E 6720 6979          dc.b      105,110,103,32,67,111,109,112,108,101,116,101
00004164  436F 6D70 
00004168  6C65 7465 
0000416C  642A 2A2A 6980          dc.b      100,42,42,42,42,42,42,42,42,0
00004170  2A2A 2A2A 
00004174  2A00      
                    6981   @m68kde~2_29:
00004176  0D0A 4C6F 6982          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
0000417A  6164 696E 
0000417E  6720 5072 
00004182  6F        
00004183  6772 616D 6983          dc.b      103,114,97,109,32,70,114,111,109,32,70,108,97
00004187  2046 726F 
0000418B  6D20 466C 
0000418F  61        
00004190  7368 2E2E 6984          dc.b      115,104,46,46,46,46,0
00004194  2E2E 00   
                    6985   @m68kde~2_30:
00004198  0D0A 2A2A 6986          dc.b      13,10,42,42,42,42,42,42,42,42,80,114,111,103
0000419C  2A2A 2A2A 
000041A0  2A2A 5072 
000041A4  6F67      
000041A6  7261 6D20 6987          dc.b      114,97,109,32,108,111,97,100,101,100,32,116
000041AA  6C6F 6164 
000041AE  6564 2074 
000041B2  6F20 5241 6988          dc.b      111,32,82,65,77,42,42,42,42,42,42,42,42,0
000041B6  4D2A 2A2A 
000041BA  2A2A 2A2A 
000041BE  2A00      
                    6989   @m68kde~2_31:
000041C0  2425 3038 6990          dc.b      36,37,48,56,88,32,32,0
000041C4  5820 2000 
                    6991   @m68kde~2_32:
000041C8  2000      6992          dc.b      32,0
                    6993   @m68kde~2_33:
000041CA  2E00      6994          dc.b      46,0
                    6995   @m68kde~2_34:
000041CC  2563 00   6996          dc.b      37,99,0
                    6997   @m68kde~2_35:
000041D0  00        6998          dc.b      0
                    6999   @m68kde~2_36:
000041D2  0D0A 0D0A 7000          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
000041D6  2044 3020 
000041DA  3D20 2425 
000041DE  3038 58   
000041E1  2020 4130 7001          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
000041E5  203D 2024 
000041E9  2530 3858 
000041ED  00        
                    7002   @m68kde~2_37:
000041EE  0D0A 2044 7003          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
000041F2  3120 3D20 
000041F6  2425 3038 
000041FA  5820 20   
000041FD  4131 203D 7004          dc.b      65,49,32,61,32,36,37,48,56,88,0
00004201  2024 2530 
00004205  3858 00   
                    7005   @m68kde~2_38:
00004208  0D0A 2044 7006          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
0000420C  3220 3D20 
00004210  2425 3038 
00004214  5820 20   
00004217  4132 203D 7007          dc.b      65,50,32,61,32,36,37,48,56,88,0
0000421B  2024 2530 
0000421F  3858 00   
                    7008   @m68kde~2_39:
00004222  0D0A 2044 7009          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00004226  3320 3D20 
0000422A  2425 3038 
0000422E  5820 20   
00004231  4133 203D 7010          dc.b      65,51,32,61,32,36,37,48,56,88,0
00004235  2024 2530 
00004239  3858 00   
                    7011   @m68kde~2_40:
0000423C  0D0A 2044 7012          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
00004240  3420 3D20 
00004244  2425 3038 
00004248  5820 20   
0000424B  4134 203D 7013          dc.b      65,52,32,61,32,36,37,48,56,88,0
0000424F  2024 2530 
00004253  3858 00   
                    7014   @m68kde~2_41:
00004256  0D0A 2044 7015          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
0000425A  3520 3D20 
0000425E  2425 3038 
00004262  5820 20   
00004265  4135 203D 7016          dc.b      65,53,32,61,32,36,37,48,56,88,0
00004269  2024 2530 
0000426D  3858 00   
                    7017   @m68kde~2_42:
00004270  0D0A 2044 7018          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
00004274  3620 3D20 
00004278  2425 3038 
0000427C  5820 20   
0000427F  4136 203D 7019          dc.b      65,54,32,61,32,36,37,48,56,88,0
00004283  2024 2530 
00004287  3858 00   
                    7020   @m68kde~2_43:
0000428A  0D0A 2044 7021          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
0000428E  3720 3D20 
00004292  2425 3038 
00004296  5820 20   
00004299  4137 203D 7022          dc.b      65,55,32,61,32,36,37,48,56,88,0
0000429D  2024 2530 
000042A1  3858 00   
                    7023   @m68kde~2_44:
000042A4  0D0A 0D0A 7024          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
000042A8  5553 5020 
000042AC  3D20 2425 
000042B0  3038 58   
000042B3  2020 2841 7025          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
000042B7  3729 2055 
000042BB  7365 7220 
000042BF  5350      
000042C1  00        7026          dc.b      0
                    7027   @m68kde~2_45:
000042C2  0D0A 5353 7028          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
000042C6  5020 3D20 
000042CA  2425 3038 
000042CE  5820 20   
000042D1  2841 3729 7029          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
000042D5  2053 7570 
000042D9  6572 7669 
000042DD  73        
000042DE  6F72 2053 7030          dc.b      111,114,32,83,80,0
000042E2  5000      
                    7031   @m68kde~2_46:
000042E4  0D0A 2053 7032          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000042E8  5220 3D20 
000042EC  2425 3034 
000042F0  5820 20   
000042F3  2000      7033          dc.b      32,0
                    7034   @m68kde~2_47:
000042F6  2020 205B 7035          dc.b      32,32,32,91,0
000042FA  00        
                    7036   @m68kde~2_48:
000042FC  0D0A 2050 7037          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00004300  4320 3D20 
00004304  2425 3038 
00004308  5820 20   
0000430B  00        7038          dc.b      0
                    7039   @m68kde~2_49:
0000430C  5B40 2042 7040          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
00004310  5245 414B 
00004314  504F 494E 
00004318  545D 00   
                    7041   @m68kde~2_50:
0000431C  0D0A 5750 7042          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00004320  2564 203D 
00004324  2025 7300 
                    7043   @m68kde~2_51:
00004328  0D0A 0D0A 7044          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
0000432C  0D0A 0D0A 
00004330  0D0A 0D0A 
00004334  5369 6E   
00004337  676C 6520 7045          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
0000433B  5374 6570 
0000433F  2020 3A5B 
00004343  4F        
00004344  4E5D 00   7046          dc.b      78,93,0
                    7047   @m68kde~2_52:
00004348  0D0A 4272 7048          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000434C  6561 6B20 
00004350  506F 696E 
00004354  74        
00004355  7320 3A5B 7049          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00004359  4469 7361 
0000435D  626C 6564 
00004361  5D        
00004362  00        7050          dc.b      0
                    7051   @m68kde~2_53:
00004364  0D0A 5072 7052          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00004368  6573 7320 
0000436C  3C53 5041 
00004370  4345      
00004372  3E20 746F 7053          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00004376  2045 7865 
0000437A  6375 7465 
0000437E  20        
0000437F  4E65 7874 7054          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
00004383  2049 6E73 
00004387  7472 7563 
0000438B  7469 6F6E 7055          dc.b      116,105,111,110,0
0000438F  00        
                    7056   @m68kde~2_54:
00004390  0D0A 5072 7057          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004394  6573 7320 
00004398  3C45 5343 
0000439C  3E20      
0000439E  746F 2052 7058          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
000043A2  6573 756D 
000043A6  6520 5072 
000043AA  6F67 7261 7059          dc.b      111,103,114,97,109,0
000043AE  6D00      
                    7060   @m68kde~2_55:
000043B0  0D0A 496C 7061          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
000043B4  6C65 6761 
000043B8  6C20 4461 
000043BC  74        
000043BD  6120 5265 7062          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
000043C1  6769 7374 
000043C5  6572 203A 
000043C9  20        
000043CA  5573 6520 7063          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
000043CE  4430 2D44 
000043D2  372E 2E2E 
000043D6  2E2E      
000043D8  0D0A 00   7064          dc.b      13,10,0
                    7065   @m68kde~2_56:
000043DC  0D0A 4425 7066          dc.b      13,10,68,37,99,32,61,32,0
000043E0  6320 3D20 
000043E4  00        
                    7067   @m68kde~2_57:
000043E6  0D0A 496C 7068          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000043EA  6C65 6761 
000043EE  6C20 4164 
000043F2  64        
000043F3  7265 7373 7069          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
000043F7  2052 6567 
000043FB  6973 7465 
000043FF  7220 3A20 7070          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
00004403  5573 6520 
00004407  4130 2D41 
0000440B  372E      
0000440D  2E2E 2E2E 7071          dc.b      46,46,46,46,13,10,0
00004411  0D0A 00   
                    7072   @m68kde~2_58:
00004414  0D0A 4125 7073          dc.b      13,10,65,37,99,32,61,32,0
00004418  6320 3D20 
0000441C  00        
                    7074   @m68kde~2_59:
0000441E  0D0A 5573 7075          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00004422  6572 2053 
00004426  5020 3D20 
0000442A  00        
                    7076   @m68kde~2_60:
0000442C  0D0A 496C 7077          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004430  6C65 6761 
00004434  6C20 5265 
00004438  67        
00004439  6973 7465 7078          dc.b      105,115,116,101,114,46,46,46,46,0
0000443D  722E 2E2E 
00004441  2E00      
                    7079   @m68kde~2_61:
00004444  0D0A 5379 7080          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00004448  7374 656D 
0000444C  2053 5020 
00004450  3D        
00004451  2000      7081          dc.b      32,0
                    7082   @m68kde~2_62:
00004454  0D0A 5043 7083          dc.b      13,10,80,67,32,61,32,0
00004458  203D 2000 
                    7084   @m68kde~2_63:
0000445C  0D0A 5352 7085          dc.b      13,10,83,82,32,61,32,0
00004460  203D 2000 
                    7086   @m68kde~2_64:
00004464  0D0A 496C 7087          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004468  6C65 6761 
0000446C  6C20 5265 
00004470  67        
00004471  6973 7465 7088          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00004475  723A 2055 
00004479  7365 2041 
0000447D  30        
0000447E  2D41 372C 7089          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00004482  2044 302D 
00004486  4437 2C20 
0000448A  5353 50   
0000448D  2C20 5553 7090          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
00004491  502C 2050 
00004495  4320 6F72 
00004499  2053      
0000449B  520D 0A00 7091          dc.b      82,13,10,0
                    7092   @m68kde~2_65:
000044A0  0D0A 0D0A 7093          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
000044A4  4E75 6D20 
000044A8  2020 2020 
000044AC  4164      
000044AE  6472 6573 7094          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
000044B2  7320 2020 
000044B6  2020 2049 
000044BA  6E        
000044BB  7374 7275 7095          dc.b      115,116,114,117,99,116,105,111,110,0
000044BF  6374 696F 
000044C3  6E00      
                    7096   @m68kde~2_66:
000044C6  0D0A 2D2D 7097          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000044CA  2D20 2020 
000044CE  2020 2D2D 
000044D2  2D2D 2D   
000044D5  2D2D 2D2D 7098          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
000044D9  2020 2020 
000044DD  2D2D 2D2D 
000044E1  2D2D 2D   
000044E4  2D2D 2D2D 7099          dc.b      45,45,45,45,0
000044E8  00        
                    7100   @m68kde~2_67:
000044EA  0D0A 4E6F 7101          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000044EE  2042 7265 
000044F2  616B 506F 
000044F6  69        
000044F7  6E74 7320 7102          dc.b      110,116,115,32,83,101,116,0
000044FB  5365 7400 
                    7103   @m68kde~2_68:
00004500  0D0A 2533 7104          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00004504  6420 2020 
00004508  2020 2425 
0000450C  3038 78   
0000450F  00        7105          dc.b      0
                    7106   @m68kde~2_69:
00004510  0D0A 4E75 7107          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00004514  6D20 2020 
00004518  2020 4164 
0000451C  6472      
0000451E  6573 7300 7108          dc.b      101,115,115,0
                    7109   @m68kde~2_70:
00004522  0D0A 2D2D 7110          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00004526  2D20 2020 
0000452A  2020 2D2D 
0000452E  2D2D 2D   
00004531  2D2D 2D2D 7111          dc.b      45,45,45,45,0
00004535  00        
                    7112   @m68kde~2_71:
00004536  0D0A 4E6F 7113          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
0000453A  2057 6174 
0000453E  6368 506F 
00004542  69        
00004543  6E74 7320 7114          dc.b      110,116,115,32,83,101,116,0
00004547  5365 7400 
                    7115   @m68kde~2_72:
0000454C  0D0A 456E 7116          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00004550  7465 7220 
00004554  4272 6561 
00004558  6B        
00004559  2050 6F69 7117          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
0000455D  6E74 204E 
00004561  756D 6265 
00004565  72        
00004566  3A20 00   7118          dc.b      58,32,0
                    7119   @m68kde~2_73:
0000456A  0D0A 496C 7120          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
0000456E  6C65 6761 
00004572  6C20 5261 
00004576  6E        
00004577  6765 203A 7121          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
0000457B  2055 7365 
0000457F  2030 202D 
00004583  2037      
00004585  00        7122          dc.b      0
                    7123   @m68kde~2_74:
00004586  0D0A 4272 7124          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000458A  6561 6B20 
0000458E  506F 696E 
00004592  74        
00004593  2043 6C65 7125          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00004597  6172 6564 
0000459B  2E2E 2E2E 
0000459F  2E        
000045A0  0D0A 00   7126          dc.b      13,10,0
                    7127   @m68kde~2_75:
000045A4  0D0A 4272 7128          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000045A8  6561 6B20 
000045AC  506F 696E 
000045B0  74        
000045B1  2077 6173 7129          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
000045B5  6E27 7420 
000045B9  5365 742E 
000045BD  2E        
000045BE  2E2E 2E00 7130          dc.b      46,46,46,0
                    7131   @m68kde~2_76:
000045C2  0D0A 456E 7132          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
000045C6  7465 7220 
000045CA  5761 7463 
000045CE  68        
000045CF  2050 6F69 7133          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000045D3  6E74 204E 
000045D7  756D 6265 
000045DB  72        
000045DC  3A20 00   7134          dc.b      58,32,0
                    7135   @m68kde~2_77:
000045E0  0D0A 5761 7136          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000045E4  7463 6820 
000045E8  506F 696E 
000045EC  74        
000045ED  2043 6C65 7137          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000045F1  6172 6564 
000045F5  2E2E 2E2E 
000045F9  2E        
000045FA  0D0A 00   7138          dc.b      13,10,0
                    7139   @m68kde~2_78:
000045FE  0D0A 5761 7140          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004602  7463 6820 
00004606  506F 696E 
0000460A  74        
0000460B  2057 6173 7141          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
0000460F  206E 6F74 
00004613  2053 6574 
00004617  2E        
00004618  2E2E 2E2E 7142          dc.b      46,46,46,46,0
0000461C  00        
                    7143   @m68kde~2_79:
0000461E  0D0A 4E6F 7144          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00004622  2046 5245 
00004626  4520 4272 
0000462A  6561      
0000462C  6B20 506F 7145          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00004630  696E 7473 
00004634  2E2E 2E2E 
00004638  2E        
00004639  00        7146          dc.b      0
                    7147   @m68kde~2_80:
0000463A  0D0A 4272 7148          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000463E  6561 6B20 
00004642  506F 696E 
00004646  74        
00004647  2041 6464 7149          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000464B  7265 7373 
0000464F  3A20 00   
                    7150   @m68kde~2_81:
00004652  0D0A 4572 7151          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00004656  726F 7220 
0000465A  3A20 4272 
0000465E  65        
0000465F  616B 2050 7152          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004663  6F69 6E74 
00004667  7320 4341 
0000466B  4E        
0000466C  4E4F 5420 7153          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00004670  6265 2073 
00004674  6574 2061 
00004678  74        
00004679  204F 4444 7154          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
0000467D  2061 6464 
00004681  7265 7373 
00004685  65        
00004686  7300      7155          dc.b      115,0
                    7156   @m68kde~2_82:
00004688  0D0A 4572 7157          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
0000468C  726F 7220 
00004690  3A20 4272 
00004694  65        
00004695  616B 2050 7158          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004699  6F69 6E74 
0000469D  7320 4341 
000046A1  4E        
000046A2  4E4F 5420 7159          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
000046A6  6265 2073 
000046AA  6574 2066 
000046AE  6F        
000046AF  7220 524F 7160          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
000046B3  4D20 696E 
000046B7  2052 616E 
000046BB  67        
000046BC  6520 3A20 7161          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
000046C0  5B24 302D 
000046C4  2430 3030 
000046C8  3037 46   
000046CB  4646 5D00 7162          dc.b      70,70,93,0
                    7163   @m68kde~2_83:
000046D0  0D0A 4572 7164          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
000046D4  726F 723A 
000046D8  2042 7265 
000046DC  61        
000046DD  6B20 506F 7165          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
000046E1  696E 7420 
000046E5  416C 7265 
000046E9  6164 7920 7166          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
000046ED  4578 6973 
000046F1  7473 2061 
000046F5  74        
000046F6  2041 6464 7167          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
000046FA  7265 7373 
000046FE  203A 2025 
00004702  30        
00004703  3878 0D0A 7168          dc.b      56,120,13,10,0
00004707  00        
                    7169   @m68kde~2_84:
00004708  0D0A 4272 7170          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000470C  6561 6B20 
00004710  506F 696E 
00004714  74        
00004715  2053 6574 7171          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00004719  2061 7420 
0000471D  4164 6472 
00004721  65        
00004722  7373 3A20 7172          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00004726  5B24 2530 
0000472A  3878 5D00 
                    7173   @m68kde~2_85:
0000472E  0D0A 4E6F 7174          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00004732  2046 5245 
00004736  4520 5761 
0000473A  7463      
0000473C  6820 506F 7175          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00004740  696E 7473 
00004744  2E2E 2E2E 
00004748  2E        
00004749  00        7176          dc.b      0
                    7177   @m68kde~2_86:
0000474A  0D0A 5761 7178          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
0000474E  7463 6820 
00004752  506F 696E 
00004756  74        
00004757  2041 6464 7179          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000475B  7265 7373 
0000475F  3A20 00   
                    7180   @m68kde~2_87:
00004762  0D0A 4572 7181          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00004766  726F 723A 
0000476A  2057 6174 
0000476E  63        
0000476F  6820 506F 7182          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00004773  696E 7420 
00004777  416C 7265 
0000477B  6164 7920 7183          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
0000477F  5365 7420 
00004783  6174 2041 
00004787  64        
00004788  6472 6573 7184          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
0000478C  7320 3A20 
00004790  2530 3878 
00004794  0D        
00004795  0A00      7185          dc.b      10,0
                    7186   @m68kde~2_88:
00004798  0D0A 5761 7187          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
0000479C  7463 6820 
000047A0  506F 696E 
000047A4  74        
000047A5  2053 6574 7188          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000047A9  2061 7420 
000047AD  4164 6472 
000047B1  65        
000047B2  7373 3A20 7189          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
000047B6  5B24 2530 
000047BA  3878 5D00 
                    7190   @m68kde~2_89:
000047BE  0D0A 0D0A 7191          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
000047C2  0D0A 0D0A 
000047C6  4042 5245 
000047CA  414B 50   
000047CD  4F49 4E54 7192          dc.b      79,73,78,84,0
000047D1  00        
                    7193   @m68kde~2_90:
000047D2  0D0A 5369 7194          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000047D6  6E67 6C65 
000047DA  2053 7465 
000047DE  70        
000047DF  203A 205B 7195          dc.b      32,58,32,91,79,78,93,0
000047E3  4F4E 5D00 
                    7196   @m68kde~2_91:
000047E8  0D0A 4272 7197          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
000047EC  6561 6B50 
000047F0  6F69 6E74 
000047F4  73        
000047F5  203A 205B 7198          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
000047F9  456E 6162 
000047FD  6C65 645D 
00004801  00        
                    7199   @m68kde~2_92:
00004802  0D0A 5072 7200          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004806  6573 7320 
0000480A  3C45 5343 
0000480E  3E20      
00004810  746F 2052 7201          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004814  6573 756D 
00004818  6520 5573 
0000481C  6572 2050 7202          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00004820  726F 6772 
00004824  616D 0D0A 
00004828  00        
                    7203   @m68kde~2_93:
0000482A  0D0A 556E 7204          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
0000482E  6B6E 6F77 
00004832  6E20 436F 
00004836  6D        
00004837  6D61 6E64 7205          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
0000483B  2E2E 2E2E 
0000483F  2E0D 0A00 
                    7206   @m68kde~2_94:
00004844  0D0A 5072 7207          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00004848  6F67 7261 
0000484C  6D20 456E 
00004850  64        
00004851  6564 2028 7208          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00004855  5452 4150 
00004859  2023 3135 
0000485D  292E      
0000485F  2E2E 2E00 7209          dc.b      46,46,46,0
                    7210   @m68kde~2_95:
00004864  0D0A 4B69 7211          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00004868  6C6C 2041 
0000486C  6C6C 2042 
00004870  72        
00004871  6561 6B20 7212          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00004875  506F 696E 
00004879  7473 2E2E 
0000487D  2E        
0000487E  2879 2F6E 7213          dc.b      40,121,47,110,41,63,0
00004882  293F 00   
                    7214   @m68kde~2_96:
00004886  0D0A 4B69 7215          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
0000488A  6C6C 2041 
0000488E  6C6C 2057 
00004892  61        
00004893  7463 6820 7216          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00004897  506F 696E 
0000489B  7473 2E2E 
0000489F  2E        
000048A0  2879 2F6E 7217          dc.b      40,121,47,110,41,63,0
000048A4  293F 00   
                    7218   @m68kde~2_97:
000048A8  0D0A 2D2D 7219          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
000048AC  2D2D 2D2D 
000048B0  2D2D 2D2D 
000048B4  2D2D 2D   
000048B7  2D2D 2D2D 7220          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000048BB  2D2D 2D2D 
000048BF  2D2D 2D2D 
000048C3  2D2D 2D   
000048C6  2D2D 2D2D 7221          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000048CA  2D2D 2D2D 
000048CE  2D2D 2D2D 
000048D2  2D2D 2D   
000048D5  2D2D 2D2D 7222          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000048D9  2D2D 2D2D 
000048DD  2D2D 2D2D 
000048E1  2D2D 2D   
000048E4  2D2D 2D2D 7223          dc.b      45,45,45,45,45,45,0
000048E8  2D2D 00   
                    7224   @m68kde~2_98:
000048EC  0D0A 2020 7225          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
000048F0  4465 6275 
000048F4  6767 6572 
000048F8  20        
000048F9  436F 6D6D 7226          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
000048FD  616E 6420 
00004901  5375 6D6D 
00004905  6172 7900 7227          dc.b      97,114,121,0
                    7228   @m68kde~2_99:
0000490A  0D0A 2020 7229          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
0000490E  2E28 7265 
00004912  6729 2020 
00004916  2020      
00004918  2020 202D 7230          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
0000491C  2043 6861 
00004920  6E67 6520 
00004924  5265      
00004926  6769 7374 7231          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
0000492A  6572 733A 
0000492E  2065 2E67 
00004932  2041 302D 7232          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00004936  4137 2C44 
0000493A  302D 4437 
0000493E  2C50 43   
00004941  2C53 5350 7233          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00004945  2C55 5350 
00004949  2C53 5200 
                    7234   @m68kde~2_100:
0000494E  0D0A 2020 7235          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00004952  4244 2F42 
00004956  532F 4243 
0000495A  2F42 4B   
0000495D  2020 2D20 7236          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00004961  4272 6561 
00004965  6B20 506F 
00004969  69        
0000496A  6E74 3A20 7237          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
0000496E  4469 7370 
00004972  6C61 792F 
00004976  53        
00004977  6574 2F43 7238          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
0000497B  6C65 6172 
0000497F  2F4B 696C 
00004983  6C        
00004984  00        7239          dc.b      0
                    7240   @m68kde~2_101:
00004986  0D0A 2020 7241          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
0000498A  4320 2020 
0000498E  2020 2020 
00004992  2020 20   
00004995  2020 2D20 7242          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00004999  436F 7079 
0000499D  2050 726F 
000049A1  67        
000049A2  7261 6D20 7243          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
000049A6  6672 6F6D 
000049AA  2046 6C61 
000049AE  73        
000049AF  6820 746F 7244          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
000049B3  204D 6169 
000049B7  6E20 4D65 
000049BB  6D        
000049BC  6F72 7900 7245          dc.b      111,114,121,0
                    7246   @m68kde~2_102:
000049C0  0D0A 2020 7247          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
000049C4  4420 2020 
000049C8  2020 2020 
000049CC  2020 20   
000049CF  2020 2D20 7248          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000049D3  4475 6D70 
000049D7  204D 656D 
000049DB  6F        
000049DC  7279 2043 7249          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
000049E0  6F6E 7465 
000049E4  6E74 7320 
000049E8  746F 2053 7250          dc.b      116,111,32,83,99,114,101,101,110,0
000049EC  6372 6565 
000049F0  6E00      
                    7251   @m68kde~2_103:
000049F2  0D0A 2020 7252          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
000049F6  4520 2020 
000049FA  2020 2020 
000049FE  2020 20   
00004A01  2020 2D20 7253          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00004A05  456E 7465 
00004A09  7220 5374 
00004A0D  72        
00004A0E  696E 6720 7254          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00004A12  696E 746F 
00004A16  204D 656D 
00004A1A  6F72 7900 7255          dc.b      111,114,121,0
                    7256   @m68kde~2_104:
00004A1E  0D0A 2020 7257          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00004A22  4620 2020 
00004A26  2020 2020 
00004A2A  2020 20   
00004A2D  2020 2D20 7258          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00004A31  4669 6C6C 
00004A35  204D 656D 
00004A39  6F        
00004A3A  7279 2077 7259          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00004A3E  6974 6820 
00004A42  4461 7461 
00004A46  00        
                    7260   @m68kde~2_105:
00004A48  0D0A 2020 7261          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00004A4C  4720 2020 
00004A50  2020 2020 
00004A54  2020 20   
00004A57  2020 2D20 7262          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
00004A5B  476F 2050 
00004A5F  726F 6772 
00004A63  61        
00004A64  6D20 5374 7263          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00004A68  6172 7469 
00004A6C  6E67 2061 
00004A70  74        
00004A71  2041 6464 7264          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00004A75  7265 7373 
00004A79  3A20 2425 
00004A7D  30        
00004A7E  3858 00   7265          dc.b      56,88,0
                    7266   @m68kde~2_106:
00004A82  0D0A 2020 7267          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00004A86  4C20 2020 
00004A8A  2020 2020 
00004A8E  2020 20   
00004A91  2020 2D20 7268          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00004A95  4C6F 6164 
00004A99  2050 726F 
00004A9D  67        
00004A9E  7261 6D20 7269          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00004AA2  282E 4845 
00004AA6  5820 6669 
00004AAA  6C        
00004AAB  6529 2066 7270          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
00004AAF  726F 6D20 
00004AB3  4C61 7074 
00004AB7  6F        
00004AB8  7000      7271          dc.b      112,0
                    7272   @m68kde~2_107:
00004ABA  0D0A 2020 7273          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
00004ABE  4D20 2020 
00004AC2  2020 2020 
00004AC6  2020 20   
00004AC9  2020 2D20 7274          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
00004ACD  4D65 6D6F 
00004AD1  7279 2045 
00004AD5  78        
00004AD6  616D 696E 7275          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
00004ADA  6520 616E 
00004ADE  6420 4368 
00004AE2  61        
00004AE3  6E67 6500 7276          dc.b      110,103,101,0
                    7277   @m68kde~2_108:
00004AE8  0D0A 2020 7278          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
00004AEC  5020 2020 
00004AF0  2020 2020 
00004AF4  2020 20   
00004AF7  2020 2D20 7279          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
00004AFB  5072 6F67 
00004AFF  7261 6D20 
00004B03  46        
00004B04  6C61 7368 7280          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00004B08  204D 656D 
00004B0C  6F72 7920 
00004B10  7769 7468 7281          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00004B14  2055 7365 
00004B18  7220 5072 
00004B1C  6F67 7261 7282          dc.b      111,103,114,97,109,0
00004B20  6D00      
                    7283   @m68kde~2_109:
00004B22  0D0A 2020 7284          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00004B26  5220 2020 
00004B2A  2020 2020 
00004B2E  2020 20   
00004B31  2020 2D20 7285          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00004B35  4469 7370 
00004B39  6C61 7920 
00004B3D  36        
00004B3E  3830 3030 7286          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00004B42  2052 6567 
00004B46  6973 7465 
00004B4A  72        
00004B4B  7300      7287          dc.b      115,0
                    7288   @m68kde~2_110:
00004B4E  0D0A 2020 7289          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00004B52  5320 2020 
00004B56  2020 2020 
00004B5A  2020 20   
00004B5D  2020 2D20 7290          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00004B61  546F 6767 
00004B65  6C65 204F 
00004B69  4E        
00004B6A  2F4F 4646 7291          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00004B6E  2053 696E 
00004B72  676C 6520 
00004B76  53        
00004B77  7465 7020 7292          dc.b      116,101,112,32,77,111,100,101,0
00004B7B  4D6F 6465 
00004B7F  00        
                    7293   @m68kde~2_111:
00004B80  0D0A 2020 7294          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00004B84  544D 2020 
00004B88  2020 2020 
00004B8C  2020 20   
00004B8F  2020 2D20 7295          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00004B93  5465 7374 
00004B97  204D 656D 
00004B9B  6F        
00004B9C  7279 00   7296          dc.b      114,121,0
                    7297   @m68kde~2_112:
00004BA0  0D0A 2020 7298          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00004BA4  5453 2020 
00004BA8  2020 2020 
00004BAC  2020 20   
00004BAF  2020 2D20 7299          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00004BB3  5465 7374 
00004BB7  2053 7769 
00004BBB  74        
00004BBC  6368 6573 7300          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00004BC0  3A20 5357 
00004BC4  372D 3000 
                    7301   @m68kde~2_113:
00004BC8  0D0A 2020 7302          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00004BCC  5444 2020 
00004BD0  2020 2020 
00004BD4  2020 20   
00004BD7  2020 2D20 7303          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00004BDB  5465 7374 
00004BDF  2044 6973 
00004BE3  70        
00004BE4  6C61 7973 7304          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00004BE8  3A20 4C45 
00004BEC  4473 2061 
00004BF0  6E        
00004BF1  6420 372D 7305          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00004BF5  5365 676D 
00004BF9  656E 7400 
                    7306   @m68kde~2_114:
00004BFE  0D0A 2020 7307          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00004C02  5744 2F57 
00004C06  532F 5743 
00004C0A  2F57 4B   
00004C0D  2020 2D20 7308          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00004C11  5761 7463 
00004C15  6820 506F 
00004C19  696E      
00004C1B  743A 2044 7309          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00004C1F  6973 706C 
00004C23  6179 2F53 
00004C27  65        
00004C28  742F 436C 7310          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00004C2C  6561 722F 
00004C30  4B69 6C6C 
00004C34  00        
                    7311   @m68kde~2_115:
00004C36  0D0A 2300 7312          dc.b      13,10,35,0
                    7313   @m68kde~2_116:
00004C3A  0D0A 5072 7314          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00004C3E  6F67 7261 
00004C42  6D20 5275 
00004C46  6E        
00004C47  6E69 6E67 7315          dc.b      110,105,110,103,46,46,46,46,46,0
00004C4B  2E2E 2E2E 
00004C4F  2E00      
                    7316   @m68kde~2_117:
00004C52  0D0A 5072 7317          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00004C56  6573 7320 
00004C5A  3C52 4553 
00004C5E  4554      
00004C60  3E20 6275 7318          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00004C64  7474 6F6E 
00004C68  203C 4B65 
00004C6C  79        
00004C6D  303E 206F 7319          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00004C71  6E20 4445 
00004C75  3120 746F 
00004C79  2073      
00004C7B  746F 7000 7320          dc.b      116,111,112,0
                    7321   @m68kde~2_118:
00004C80  0D0A 4572 7322          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00004C84  726F 723A 
00004C88  2050 7265 
00004C8C  73        
00004C8D  7320 2747 7323          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00004C91  2720 6669 
00004C95  7273 7420 
00004C99  74        
00004C9A  6F20 7374 7324          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00004C9E  6172 7420 
00004CA2  7072 6F67 
00004CA6  7261 6D00 7325          dc.b      114,97,109,0
                    7326   @m68kde~2_119:
00004CAA  0D0A 5369 7327          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004CAE  6E67 6C65 
00004CB2  2053 7465 
00004CB6  70        
00004CB7  2020 3A5B 7328          dc.b      32,32,58,91,79,78,93,0
00004CBB  4F4E 5D00 
                    7329   @m68kde~2_120:
00004CC0  0D0A 5072 7330          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00004CC4  6573 7320 
00004CC8  2747 2720 
00004CCC  74        
00004CCD  6F20 5472 7331          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00004CD1  6163 6520 
00004CD5  5072 6F67 
00004CD9  72        
00004CDA  616D 2066 7332          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00004CDE  726F 6D20 
00004CE2  6164 6472 
00004CE6  6573 7320 7333          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00004CEA  2425 582E 
00004CEE  2E2E 2E2E 
00004CF2  00        
                    7334   @m68kde~2_121:
00004CF4  0D0A 5075 7335          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00004CF8  7368 203C 
00004CFC  5245 5345 
00004D00  5420      
00004D02  4275 7474 7336          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00004D06  6F6E 3E20 
00004D0A  746F 2053 
00004D0E  74        
00004D0F  6F70 2E2E 7337          dc.b      111,112,46,46,46,46,46,0
00004D13  2E2E 2E00 
                    7338   @m68kde~2_122:
00004D18  0D0A 5369 7339          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004D1C  6E67 6C65 
00004D20  2053 7465 
00004D24  70        
00004D25  203A 205B 7340          dc.b      32,58,32,91,79,70,70,93,0
00004D29  4F46 465D 
00004D2D  00        
                    7341   @m68kde~2_123:
00004D2E  0D0A 4272 7342          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004D32  6561 6B20 
00004D36  506F 696E 
00004D3A  74        
00004D3B  7320 3A5B 7343          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00004D3F  456E 6162 
00004D43  6C65 645D 
00004D47  00        
                    7344   @m68kde~2_124:
00004D48  0D0A 5072 7345          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004D4C  6573 7320 
00004D50  3C45 5343 
00004D54  3E20      
00004D56  746F 2052 7346          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004D5A  6573 756D 
00004D5E  6520 5573 
00004D62  6572 2050 7347          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00004D66  726F 6772 
00004D6A  616D 2E2E 
00004D6E  2E        
00004D6F  2E2E 00   7348          dc.b      46,46,0
                    7349   @m68kde~2_125:
00004D72  0D0A 5369 7350          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004D76  6E67 6C65 
00004D7A  2053 7465 
00004D7E  70        
00004D7F  2020 3A5B 7351          dc.b      32,32,58,91,79,70,70,93,0
00004D83  4F46 465D 
00004D87  00        
                    7352   @m68kde~2_126:
00004D88  0D0A 0D0A 7353          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004D8C  5072 6F67 
00004D90  7261 6D20 
00004D94  41        
00004D95  424F 5254 7354          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00004D99  2021 2121 
00004D9D  2121 210D 
00004DA1  0A00      
                    7355   @m68kde~2_127:
00004DA4  2573 0D0A 7356          dc.b      37,115,13,10,0
00004DA8  00        
                    7357   @m68kde~2_128:
00004DAA  0D0A 0D0A 7358          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004DAE  5072 6F67 
00004DB2  7261 6D20 
00004DB6  41        
00004DB7  424F 5254 7359          dc.b      66,79,82,84,32,33,33,33,33,33,0
00004DBB  2021 2121 
00004DBF  2121 00   
                    7360   @m68kde~2_129:
00004DC2  0D0A 556E 7361          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00004DC6  6861 6E64 
00004DCA  6C65 6420 
00004DCE  49        
00004DCF  6E74 6572 7362          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00004DD3  7275 7074 
00004DD7  3A20 4952 
00004DDB  5125 6420 7363          dc.b      81,37,100,32,33,33,33,33,33,0
00004DDF  2121 2121 
00004DE3  2100      
                    7364   @m68kde~2_130:
00004DE6  4144 4452 7365          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00004DEA  4553 5320 
00004DEE  4552 524F 
00004DF2  523A 20   
00004DF5  3136 206F 7366          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00004DF9  7220 3332 
00004DFD  2042 6974 
00004E01  2054      
00004E03  7261 6E73 7367          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00004E07  6665 7220 
00004E0B  746F 2F66 
00004E0F  726F 6D20 7368          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00004E13  616E 204F 
00004E17  4444 2041 
00004E1B  64        
00004E1C  6472 6573 7369          dc.b      100,114,101,115,115,46,46,46,46,0
00004E20  732E 2E2E 
00004E24  2E00      
                    7370   @m68kde~2_131:
00004E26  556E 6861 7371          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00004E2A  6E64 6C65 
00004E2E  6420 5472 
00004E32  6170 2021 7372          dc.b      97,112,32,33,33,33,33,33,0
00004E36  2121 2121 
00004E3A  00        
                    7373   @m68kde~2_132:
00004E3C  4255 5320 7374          dc.b      66,85,83,32,69,114,114,111,114,33,0
00004E40  4572 726F 
00004E44  7221 00   
                    7375   @m68kde~2_133:
00004E48  4144 4452 7376          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00004E4C  4553 5320 
00004E50  4572 726F 
00004E54  7221      
00004E56  00        7377          dc.b      0
                    7378   @m68kde~2_134:
00004E58  494C 4C45 7379          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00004E5C  4741 4C20 
00004E60  494E 5354 
00004E64  5255 43   
00004E67  5449 4F4E 7380          dc.b      84,73,79,78,0
00004E6B  00        
                    7381   @m68kde~2_135:
00004E6C  4449 5649 7382          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00004E70  4445 2042 
00004E74  5920 5A45 
00004E78  524F 00   
                    7383   @m68kde~2_136:
00004E7C  2743 484B 7384          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00004E80  2720 494E 
00004E84  5354 5255 
00004E88  4354 49   
00004E8B  4F4E 00   7385          dc.b      79,78,0
                    7386   @m68kde~2_137:
00004E8E  5452 4150 7387          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00004E92  5620 494E 
00004E96  5354 5255 
00004E9A  4354 49   
00004E9D  4F4E 00   7388          dc.b      79,78,0
                    7389   @m68kde~2_138:
00004EA0  5052 4956 7390          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00004EA4  494C 4547 
00004EA8  4520 5649 
00004EAC  4F4C 41   
00004EAF  5449 4F4E 7391          dc.b      84,73,79,78,0
00004EB3  00        
                    7392   @m68kde~2_139:
00004EB4  554E 494E 7393          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00004EB8  4954 4941 
00004EBC  4C49 5345 
00004EC0  4420 49   
00004EC3  5251 00   7394          dc.b      82,81,0
                    7395   @m68kde~2_140:
00004EC6  5350 5552 7396          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00004ECA  494F 5553 
00004ECE  2049 5251 
00004ED2  00        
                    7397   @m68kde~2_141:
00004ED4  0D0A 5374 7398          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00004ED8  6172 7420 
00004EDC  4164 6472 
00004EE0  65        
00004EE1  7373 2069 7399          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00004EE5  6E20 4D65 
00004EE9  6D6F 7279 
00004EED  3A20 00   7400          dc.b      58,32,0
                    7401   @m68kde~2_142:
00004EF0  0D0A 456E 7402          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00004EF4  7465 7220 
00004EF8  5374 7269 
00004EFC  6E        
00004EFD  6720 2845 7403          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00004F01  5343 2074 
00004F05  6F20 656E 
00004F09  64        
00004F0A  2920 3A00 7404          dc.b      41,32,58,0
                    7405   @m68kde~2_143:
00004F0E  0D0A 5768 7406          dc.b      13,10,87,104,105,99,104,32,77,101,109,111,114
00004F12  6963 6820 
00004F16  4D65 6D6F 
00004F1A  72        
00004F1B  7920 646F 7407          dc.b      121,32,100,111,32,121,111,117,32,119,97,110
00004F1F  2079 6F75 
00004F23  2077 616E 
00004F27  7420 746F 7408          dc.b      116,32,116,111,32,116,101,115,116,63,32,69,110
00004F2B  2074 6573 
00004F2F  743F 2045 
00004F33  6E        
00004F34  7465 7220 7409          dc.b      116,101,114,32,48,32,102,111,114,32,68,82,65
00004F38  3020 666F 
00004F3C  7220 4452 
00004F40  41        
00004F41  4D20 6F72 7410          dc.b      77,32,111,114,32,49,32,102,111,114,32,83,82
00004F45  2031 2066 
00004F49  6F72 2053 
00004F4D  52        
00004F4E  414D 00   7411          dc.b      65,77,0
                    7412   @m68kde~2_144:
00004F52  0D0A 5768 7413          dc.b      13,10,87,104,105,99,104,32,116,101,115,116,32
00004F56  6963 6820 
00004F5A  7465 7374 
00004F5E  20        
00004F5F  646F 2079 7414          dc.b      100,111,32,121,111,117,32,119,97,110,116,32
00004F63  6F75 2077 
00004F67  616E 7420 
00004F6B  746F 2070 7415          dc.b      116,111,32,112,101,114,102,111,114,109,63,32
00004F6F  6572 666F 
00004F73  726D 3F20 
00004F77  456E 7465 7416          dc.b      69,110,116,101,114,32,39,48,39,32,102,111,114
00004F7B  7220 2730 
00004F7F  2720 666F 
00004F83  72        
00004F84  2052 6561 7417          dc.b      32,82,101,97,100,32,111,114,32,39,49,39,32,102
00004F88  6420 6F72 
00004F8C  2027 3127 
00004F90  2066      
00004F92  6F72 2057 7418          dc.b      111,114,32,87,114,105,116,101,58,32,0
00004F96  7269 7465 
00004F9A  3A20 00   
                    7419   @m68kde~2_145:
00004F9E  0D0A 4572 7420          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
00004FA2  726F 723A 
00004FA6  2049 6E76 
00004FAA  61        
00004FAB  6C69 6420 7421          dc.b      108,105,100,32,73,110,112,117,116,0
00004FAF  496E 7075 
00004FB3  7400      
                    7422   @m68kde~2_146:
00004FB6  0D0A 5370 7423          dc.b      13,10,83,112,101,99,105,102,121,32,116,104,101
00004FBA  6563 6966 
00004FBE  7920 7468 
00004FC2  65        
00004FC3  206D 656D 7424          dc.b      32,109,101,109,111,114,121,32,116,101,115,116
00004FC7  6F72 7920 
00004FCB  7465 7374 
00004FCF  2074 7970 7425          dc.b      32,116,121,112,101,46,32,73,110,112,117,116
00004FD3  652E 2049 
00004FD7  6E70 7574 
00004FDB  2027 3027 7426          dc.b      32,39,48,39,32,102,111,114,32,66,121,116,101
00004FDF  2066 6F72 
00004FE3  2042 7974 
00004FE7  65        
00004FE8  732C 2027 7427          dc.b      115,44,32,39,49,39,32,102,111,114,32,87,111
00004FEC  3127 2066 
00004FF0  6F72 2057 
00004FF4  6F        
00004FF5  7264 2C20 7428          dc.b      114,100,44,32,97,110,100,32,39,50,39,32,102
00004FF9  616E 6420 
00004FFD  2732 2720 
00005001  66        
00005002  6F72 204C 7429          dc.b      111,114,32,76,111,110,103,32,87,111,114,100
00005006  6F6E 6720 
0000500A  576F 7264 
0000500E  3A20 00   7430          dc.b      58,32,0
                    7431   @m68kde~2_147:
00005012  0D0A 4572 7432          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
00005016  726F 723A 
0000501A  2049 6E76 
0000501E  61        
0000501F  6C69 6420 7433          dc.b      108,105,100,32,73,110,112,117,116,33,0
00005023  496E 7075 
00005027  7421 00   
                    7434   @m68kde~2_148:
0000502A  0D0A 5072 7435          dc.b      13,10,80,114,111,118,105,100,101,32,97,32,115
0000502E  6F76 6964 
00005032  6520 6120 
00005036  73        
00005037  7461 7274 7436          dc.b      116,97,114,116,32,97,100,100,114,101,115,115
0000503B  2061 6464 
0000503F  7265 7373 
00005043  2066 6F72 7437          dc.b      32,102,111,114,32,121,111,117,114,32,100,97
00005047  2079 6F75 
0000504B  7220 6461 
0000504F  7461 3A20 7438          dc.b      116,97,58,32,0
00005053  00        
                    7439   @m68kde~2_149:
00005054  0D0A 4572 7440          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
00005058  726F 723A 
0000505C  2049 6E76 
00005060  61        
00005061  6C69 6420 7441          dc.b      108,105,100,32,97,100,100,114,101,115,115,33
00005065  6164 6472 
00005069  6573 7321 
0000506D  2053 7461 7442          dc.b      32,83,116,97,114,116,32,97,100,100,114,101,115
00005071  7274 2061 
00005075  6464 7265 
00005079  73        
0000507A  7320 666F 7443          dc.b      115,32,102,111,114,32,83,82,65,77,32,99,97,110
0000507E  7220 5352 
00005082  414D 2063 
00005086  616E      
00005088  6E6F 7420 7444          dc.b      110,111,116,32,98,101,32,108,101,115,115,32
0000508C  6265 206C 
00005090  6573 7320 
00005094  7468 616E 7445          dc.b      116,104,97,110,32,70,48,48,48,48,48,48,48,32
00005098  2046 3030 
0000509C  3030 3030 
000050A0  3020      
000050A2  6F72 2067 7446          dc.b      111,114,32,103,114,101,97,116,101,114,32,116
000050A6  7265 6174 
000050AA  6572 2074 
000050AE  6861 6E20 7447          dc.b      104,97,110,32,48,120,70,48,48,51,70,70,70,70
000050B2  3078 4630 
000050B6  3033 4646 
000050BA  4646      
000050BC  00        7448          dc.b      0
                    7449   @m68kde~2_150:
000050BE  0D0A 4572 7450          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
000050C2  726F 723A 
000050C6  2049 6E76 
000050CA  61        
000050CB  6C69 6420 7451          dc.b      108,105,100,32,97,100,100,114,101,115,115,33
000050CF  6164 6472 
000050D3  6573 7321 
000050D7  2053 7461 7452          dc.b      32,83,116,97,114,116,32,97,100,100,114,101,115
000050DB  7274 2061 
000050DF  6464 7265 
000050E3  73        
000050E4  7320 666F 7453          dc.b      115,32,102,111,114,32,68,82,65,77,32,99,97,110
000050E8  7220 4452 
000050EC  414D 2063 
000050F0  616E      
000050F2  6E6F 7420 7454          dc.b      110,111,116,32,98,101,32,108,101,115,115,32
000050F6  6265 206C 
000050FA  6573 7320 
000050FE  7468 616E 7455          dc.b      116,104,97,110,32,48,57,48,48,48,48,48,48,32
00005102  2030 3930 
00005106  3030 3030 
0000510A  3020      
0000510C  6F72 2067 7456          dc.b      111,114,32,103,114,101,97,116,101,114,32,116
00005110  7265 6174 
00005114  6572 2074 
00005118  6861 6E20 7457          dc.b      104,97,110,32,48,57,55,70,70,70,70,70,0
0000511C  3039 3746 
00005120  4646 4646 
00005124  00        
                    7458   @m68kde~2_151:
00005126  0D0A 4F64 7459          dc.b      13,10,79,100,100,32,97,100,100,114,101,115,115
0000512A  6420 6164 
0000512E  6472 6573 
00005132  73        
00005133  2069 7320 7460          dc.b      32,105,115,32,110,111,116,32,97,108,108,111
00005137  6E6F 7420 
0000513B  616C 6C6F 
0000513F  7765 6420 7461          dc.b      119,101,100,32,102,111,114,32,119,111,114,100
00005143  666F 7220 
00005147  776F 7264 
0000514B  206F 7220 7462          dc.b      32,111,114,32,108,111,110,103,32,119,111,114
0000514F  6C6F 6E67 
00005153  2077 6F72 
00005157  6421 00   7463          dc.b      100,33,0
                    7464   @m68kde~2_152:
0000515A  0D0A 596F 7465          dc.b      13,10,89,111,117,32,104,97,118,101,32,101,110
0000515E  7520 6861 
00005162  7665 2065 
00005166  6E        
00005167  7465 7265 7466          dc.b      116,101,114,101,100,32,37,120,32,102,111,114
0000516B  6420 2578 
0000516F  2066 6F72 
00005173  2074 6865 7467          dc.b      32,116,104,101,32,115,116,97,114,116,32,97,100
00005177  2073 7461 
0000517B  7274 2061 
0000517F  64        
00005180  6472 6573 7468          dc.b      100,114,101,115,115,0
00005184  7300      
                    7469   @m68kde~2_153:
00005186  0D0A 5072 7470          dc.b      13,10,80,114,111,118,105,100,101,32,97,110,32
0000518A  6F76 6964 
0000518E  6520 616E 
00005192  20        
00005193  656E 6420 7471          dc.b      101,110,100,32,97,100,100,114,101,115,115,32
00005197  6164 6472 
0000519B  6573 7320 
0000519F  666F 7220 7472          dc.b      102,111,114,32,121,111,117,114,32,100,97,116
000051A3  796F 7572 
000051A7  2064 6174 
000051AB  613A 2000 7473          dc.b      97,58,32,0
                    7474   @m68kde~2_154:
000051B0  0D0A 4572 7475          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
000051B4  726F 723A 
000051B8  2049 6E76 
000051BC  61        
000051BD  6C69 6420 7476          dc.b      108,105,100,32,97,100,100,114,101,115,115,33
000051C1  6164 6472 
000051C5  6573 7321 
000051C9  2045 6E64 7477          dc.b      32,69,110,100,32,97,100,100,114,101,115,115
000051CD  2061 6464 
000051D1  7265 7373 
000051D5  2066 6F72 7478          dc.b      32,102,111,114,32,83,82,65,77,32,115,104,111
000051D9  2053 5241 
000051DD  4D20 7368 
000051E1  6F        
000051E2  756C 6420 7479          dc.b      117,108,100,32,110,111,116,32,98,101,32,108
000051E6  6E6F 7420 
000051EA  6265 206C 
000051EE  6573 7320 7480          dc.b      101,115,115,32,116,104,97,110,32,111,114,32
000051F2  7468 616E 
000051F6  206F 7220 
000051FA  6571 7561 7481          dc.b      101,113,117,97,108,32,116,111,32,115,116,97
000051FE  6C20 746F 
00005202  2073 7461 
00005206  7274 2061 7482          dc.b      114,116,32,97,100,100,114,101,115,115,32,111
0000520A  6464 7265 
0000520E  7373 206F 
00005212  7220 6772 7483          dc.b      114,32,103,114,101,97,116,101,114,32,116,104
00005216  6561 7465 
0000521A  7220 7468 
0000521E  616E 2046 7484          dc.b      97,110,32,70,48,48,51,70,70,70,70,0
00005222  3030 3346 
00005226  4646 4600 
                    7485   @m68kde~2_155:
0000522A  0D0A 4572 7486          dc.b      13,10,69,114,114,111,114,58,32,73,110,118,97
0000522E  726F 723A 
00005232  2049 6E76 
00005236  61        
00005237  6C69 6420 7487          dc.b      108,105,100,32,97,100,100,114,101,115,115,33
0000523B  6164 6472 
0000523F  6573 7321 
00005243  2045 6E64 7488          dc.b      32,69,110,100,32,97,100,100,114,101,115,115
00005247  2061 6464 
0000524B  7265 7373 
0000524F  2066 6F72 7489          dc.b      32,102,111,114,32,68,82,65,77,32,115,104,111
00005253  2044 5241 
00005257  4D20 7368 
0000525B  6F        
0000525C  756C 6420 7490          dc.b      117,108,100,32,110,111,116,32,98,101,32,108
00005260  6E6F 7420 
00005264  6265 206C 
00005268  6573 7320 7491          dc.b      101,115,115,32,116,104,97,110,32,111,114,32
0000526C  7468 616E 
00005270  206F 7220 
00005274  6571 7561 7492          dc.b      101,113,117,97,108,32,116,111,32,115,116,97
00005278  6C20 746F 
0000527C  2073 7461 
00005280  7274 2061 7493          dc.b      114,116,32,97,100,100,114,101,115,115,32,111
00005284  6464 7265 
00005288  7373 206F 
0000528C  7220 6772 7494          dc.b      114,32,103,114,101,97,116,101,114,32,116,104
00005290  6561 7465 
00005294  7220 7468 
00005298  616E 2030 7495          dc.b      97,110,32,48,57,55,70,70,70,70,70,0
0000529C  3937 4646 
000052A0  4646 4600 
                    7496   @m68kde~2_156:
000052A4  0D0A 4572 7497          dc.b      13,10,69,114,114,111,114,58,32,68,97,116,97
000052A8  726F 723A 
000052AC  2044 6174 
000052B0  61        
000052B1  2063 616E 7498          dc.b      32,99,97,110,110,111,116,32,98,101,32,102,105
000052B5  6E6F 7420 
000052B9  6265 2066 
000052BD  69        
000052BE  7474 6564 7499          dc.b      116,116,101,100,32,105,110,32,103,105,118,101
000052C2  2069 6E20 
000052C6  6769 7665 
000052CA  6E20 6164 7500          dc.b      110,32,97,100,100,114,101,115,115,32,114,97
000052CE  6472 6573 
000052D2  7320 7261 
000052D6  6E67 6500 7501          dc.b      110,103,101,0
                    7502   @m68kde~2_157:
000052DA  0D0A 4572 7503          dc.b      13,10,69,114,114,111,114,58,32,78,111,116,32
000052DE  726F 723A 
000052E2  204E 6F74 
000052E6  20        
000052E7  656E 6F75 7504          dc.b      101,110,111,117,103,104,32,97,100,100,114,101
000052EB  6768 2061 
000052EF  6464 7265 
000052F3  7373 2072 7505          dc.b      115,115,32,114,97,110,103,101,32,116,111,32
000052F7  616E 6765 
000052FB  2074 6F20 
000052FF  7265 6164 7506          dc.b      114,101,97,100,32,116,104,101,32,100,97,116
00005303  2074 6865 
00005307  2064 6174 
0000530B  6100      7507          dc.b      97,0
                    7508   @m68kde~2_158:
0000530E  0D0A 5765 7509          dc.b      13,10,87,101,32,97,114,101,32,110,111,116,32
00005312  2061 7265 
00005316  206E 6F74 
0000531A  20        
0000531B  7375 7070 7510          dc.b      115,117,112,112,111,115,101,100,32,116,111,32
0000531F  6F73 6564 
00005323  2074 6F20 
00005327  6765 7420 7511          dc.b      103,101,116,32,104,101,114,101,33,32,68,101
0000532B  6865 7265 
0000532F  2120 4465 
00005333  6661 756C 7512          dc.b      102,97,117,108,116,32,105,115,32,105,110,99
00005337  7420 6973 
0000533B  2069 6E63 
0000533F  7265 6D65 7513          dc.b      114,101,109,101,110,116,32,98,121,32,49,32,98
00005343  6E74 2062 
00005347  7920 3120 
0000534B  62        
0000534C  7974 652E 7514          dc.b      121,116,101,46,0
00005350  00        
                    7515   @m68kde~2_159:
00005352  0D0A 4461 7516          dc.b      13,10,68,97,116,97,32,97,116,32,108,111,99,97
00005356  7461 2061 
0000535A  7420 6C6F 
0000535E  6361      
00005360  7469 6F6E 7517          dc.b      116,105,111,110,32,37,120,58,32,37,48,50,120
00005364  2025 783A 
00005368  2025 3032 
0000536C  78        
0000536D  00        7518          dc.b      0
                    7519   @m68kde~2_160:
0000536E  0D0A 576F 7520          dc.b      13,10,87,111,114,100,32,97,116,32,108,111,99
00005372  7264 2061 
00005376  7420 6C6F 
0000537A  63        
0000537B  6174 696F 7521          dc.b      97,116,105,111,110,32,37,120,58,32,37,48,50
0000537F  6E20 2578 
00005383  3A20 2530 
00005387  32        
00005388  7825 3032 7522          dc.b      120,37,48,50,120,0
0000538C  7800      
                    7523   @m68kde~2_161:
0000538E  0D0A 4C6F 7524          dc.b      13,10,76,111,110,103,32,119,111,114,100,32,97
00005392  6E67 2077 
00005396  6F72 6420 
0000539A  61        
0000539B  7420 6C6F 7525          dc.b      116,32,108,111,99,97,116,105,111,110,32,37,120
0000539F  6361 7469 
000053A3  6F6E 2025 
000053A7  78        
000053A8  3A20 2530 7526          dc.b      58,32,37,48,50,120,37,48,50,120,37,48,50,120
000053AC  3278 2530 
000053B0  3278 2530 
000053B4  3278      
000053B6  2530 3278 7527          dc.b      37,48,50,120,0
000053BA  00        
                    7528   @m68kde~2_162:
000053BC  0D0A 4669 7529          dc.b      13,10,70,105,110,105,115,104,101,100,32,114
000053C0  6E69 7368 
000053C4  6564 2072 
000053C8  6561 6469 7530          dc.b      101,97,100,105,110,103,0
000053CC  6E67 00   
                    7531   @m68kde~2_163:
000053D0  0D0A 456E 7532          dc.b      13,10,69,110,116,101,114,32,116,104,101,32,100
000053D4  7465 7220 
000053D8  7468 6520 
000053DC  64        
000053DD  6174 6120 7533          dc.b      97,116,97,32,105,110,32,102,111,114,109,97,116
000053E1  696E 2066 
000053E5  6F72 6D61 
000053E9  74        
000053EA  2058 583A 7534          dc.b      32,88,88,58,32,0
000053EE  2000      
                    7535   @m68kde~2_164:
000053F0  0D0A 456E 7536          dc.b      13,10,69,110,116,101,114,32,116,104,101,32,100
000053F4  7465 7220 
000053F8  7468 6520 
000053FC  64        
000053FD  6174 6120 7537          dc.b      97,116,97,32,105,110,32,102,111,114,109,97,116
00005401  696E 2066 
00005405  6F72 6D61 
00005409  74        
0000540A  2058 5858 7538          dc.b      32,88,88,88,88,58,32,0
0000540E  583A 2000 
                    7539   @m68kde~2_165:
00005412  0D0A 456E 7540          dc.b      13,10,69,110,116,101,114,32,116,104,101,32,100
00005416  7465 7220 
0000541A  7468 6520 
0000541E  64        
0000541F  6174 6120 7541          dc.b      97,116,97,32,105,110,32,102,111,114,109,97,116
00005423  696E 2066 
00005427  6F72 6D61 
0000542B  74        
0000542C  2058 5858 7542          dc.b      32,88,88,88,88,88,88,88,88,58,32,0
00005430  5858 5858 
00005434  583A 2000 
                    7543   @m68kde~2_166:
00005438  0D0A 5772 7544          dc.b      13,10,87,114,105,116,105,110,103,32,37,120,32
0000543C  6974 696E 
00005440  6720 2578 
00005444  20        
00005445  6174 206C 7545          dc.b      97,116,32,108,111,99,97,116,105,111,110,32,37
00005449  6F63 6174 
0000544D  696F 6E20 
00005451  25        
00005452  7800      7546          dc.b      120,0
                    7547   @m68kde~2_167:
00005454  0D0A 4572 7548          dc.b      13,10,69,114,114,111,114,32,119,114,105,116
00005458  726F 7220 
0000545C  7772 6974 
00005460  696E 6720 7549          dc.b      105,110,103,32,37,120,32,116,111,32,97,100,100
00005464  2578 2074 
00005468  6F20 6164 
0000546C  64        
0000546D  7265 7373 7550          dc.b      114,101,115,115,32,37,120,0
00005471  2025 7800 
                    7551   @m68kde~2_168:
00005476  0D0A 4572 7552          dc.b      13,10,69,114,114,111,114,58,32,69,110,100,32
0000547A  726F 723A 
0000547E  2045 6E64 
00005482  20        
00005483  6164 6472 7553          dc.b      97,100,100,114,101,115,115,32,108,105,109,105
00005487  6573 7320 
0000548B  6C69 6D69 
0000548F  7420 7265 7554          dc.b      116,32,114,101,97,99,104,101,100,0
00005493  6163 6865 
00005497  6400      
                    7555   @m68kde~2_169:
0000549A  0D0A 4361 7556          dc.b      13,10,67,97,110,110,111,116,32,119,114,105,116
0000549E  6E6E 6F74 
000054A2  2077 7269 
000054A6  74        
000054A7  6520 2578 7557          dc.b      101,32,37,120,32,97,110,100,32,37,120,0
000054AB  2061 6E64 
000054AF  2025 7800 
                    7558   @m68kde~2_170:
000054B4  0D0A 5772 7559          dc.b      13,10,87,114,105,116,105,110,103,32,102,105
000054B8  6974 696E 
000054BC  6720 6669 
000054C0  6E69 7368 7560          dc.b      110,105,115,104,101,100,32,97,116,32,37,48,56
000054C4  6564 2061 
000054C8  7420 2530 
000054CC  38        
000054CD  7800      7561          dc.b      120,0
                    7562   @m68kde~2_171:
000054D0  5374 7564 7563          dc.b      83,116,117,100,101,110,116,39,115,32,78,97,109
000054D4  656E 7427 
000054D8  7320 4E61 
000054DC  6D        
000054DD  6573 3A20 7564          dc.b      101,115,58,32,74,105,110,105,108,32,80,97,116
000054E1  4A69 6E69 
000054E5  6C20 5061 
000054E9  74        
000054EA  656C 2061 7565          dc.b      101,108,32,97,110,100,32,83,97,105,102,32,65
000054EE  6E64 2053 
000054F2  6169 6620 
000054F6  41        
000054F7  6264 656C 7566          dc.b      98,100,101,108,97,122,105,109,0
000054FB  617A 696D 
000054FF  00        
                    7567   @m68kde~2_172:
00005500  5374 7564 7568          dc.b      83,116,117,100,101,110,116,32,35,58,32,51,56
00005504  656E 7420 
00005508  233A 2033 
0000550C  38        
0000550D  3234 3037 7569          dc.b      50,52,48,55,50,55,32,97,110,100,32,32,54,50
00005511  3237 2061 
00005515  6E64 2020 
00005519  3632      
0000551B  3633 3934 7570          dc.b      54,51,57,52,50,50,0
0000551F  3232 00   
                    7571   @m68kde~2_173:
00005522  0D0A 5350 7572          dc.b      13,10,83,80,73,32,104,97,115,32,98,101,101,110
00005526  4920 6861 
0000552A  7320 6265 
0000552E  656E      
00005530  2069 6E69 7573          dc.b      32,105,110,105,116,105,97,108,105,122,101,100
00005534  7469 616C 
00005538  697A 6564 
0000553C  2073 7563 7574          dc.b      32,115,117,99,99,101,115,115,102,117,108,108
00005540  6365 7373 
00005544  6675 6C6C 
00005548  792E 00   7575          dc.b      121,46,0
                    7576   @m68kde~2_174:
0000554C  0D0A 5275 7577          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
00005550  6E6E 696E 
00005554  672E 2E2E 
00005558  2E        
00005559  2E00      7578          dc.b      46,0
                    7579   @m68kde~2_175:
0000555C  5275 6E6E 7580          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
00005560  696E 672E 
00005564  2E2E 2E2E 
00005568  00        
                    7581   @m68kde~2_176:
0000556A  4279 3A20 7582          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
0000556E  504A 2044 
00005572  6176 6965 
00005576  73        
00005577  00        7583          dc.b      0
                    7584   @m68kde~2_177:
00005578  0D0A 2573 7585          dc.b      13,10,37,115,0
0000557C  00        
                    7586   @itoa_1:
0000557E  2D32 3134 7587          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00005582  3734 3833 
00005586  3634 3800 
                    7588   __ctype:
0000558A  0040 4040 7589          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
0000558E  4040 4040 
00005592  4040 5050 
00005596  5050 50   
00005599  4040 4040 7590          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
0000559D  4040 4040 
000055A1  4040 4040 
000055A5  4040 40   
000055A8  4040 40D0 7591          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
000055AC  A0A0 A0A0 
000055B0  A0A0 A0A0 
000055B4  A0A0 A0A0 7592          dc.b      160,160,160,160,160,160,160,140,140,140,140
000055B8  A0A0 A08C 
000055BC  8C8C 8C   
000055BF  8C8C 8C8C 7593          dc.b      140,140,140,140,140,140,160,160,160,160,160
000055C3  8C8C A0A0 
000055C7  A0A0 A0   
000055CA  A0A0 8A8A 7594          dc.b      160,160,138,138,138,138,138,138,130,130,130
000055CE  8A8A 8A8A 
000055D2  8282 82   
000055D5  8282 8282 7595          dc.b      130,130,130,130,130,130,130,130,130,130,130
000055D9  8282 8282 
000055DD  8282 82   
000055E0  8282 8282 7596          dc.b      130,130,130,130,130,130,160,160,160,160,160
000055E4  8282 A0A0 
000055E8  A0A0 A0   
000055EB  A089 8989 7597          dc.b      160,137,137,137,137,137,137,129,129,129,129
000055EF  8989 8981 
000055F3  8181 81   
000055F6  8181 8181 7598          dc.b      129,129,129,129,129,129,129,129,129,129,129
000055FA  8181 8181 
000055FE  8181 81   
00005601  8181 8181 7599          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
00005605  81A0 A0A0 
00005609  A040 0000 
0000560D  00        
0000560E  0000 0000 7600          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00005612  0000 0000 
00005616  0000 0000 
0000561A  0000 0000 
0000561E  0000 0000 
00005622  0000      
00005624  0000 0000 7601          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00005628  0000 0000 
0000562C  0000 0000 
00005630  0000 0000 
00005634  0000 0000 
00005638  0000      
0000563A  0000 0000 7602          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0000563E  0000 0000 
00005642  0000 0000 
00005646  0000 0000 
0000564A  0000 0000 
0000564E  0000      
00005650  0000 0000 7603          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00005654  0000 0000 
00005658  0000 0000 
0000565C  0000 0000 
00005660  0000 0000 
00005664  0000      
00005666  0000 0000 7604          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0000566A  0000 0000 
0000566E  0000 0000 
00005672  0000 0000 
00005676  0000 0000 
0000567A  0000      
0000567C  0000 0000 7605          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00005680  0000 0000 
00005684  0000 0000 
00005688  0000 00   
                    7606          section   data
0000568C            7607                   align
          0000 568C 7608   DataStart       equ       *
                    7609   
                    7610   *********************************************************************************************************
                    7611   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    7612   * to ram as part of the CStart routine in this file
                    7613   *********************************************************************************************************
                    7614   
                    7615          section   bss
0000568C            7616                   align
          0000 568C 7617   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    7618   
                    7619   *********************************************************************************************************
                    7620   * Section for Uninitialised Data held in ROM as constants
                    7621   *********************************************************************************************************
                    7622   
0B000000            7623                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0000 7624   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    7625   
                    7626   
0B000000            7627   bss             org       bss
                    7628   
                    7629   *********************************************************************************************************
                    7630   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    7631   * install the exception handler using the C function InstallExceptionHandler()
                    7632   *********************************************************************************************************
                    7633   
                    7634   
                    7635   
0B000000            7636   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            7637   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            7638   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            7639   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            7640   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            7641   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            7642   VCheck           ds.l    1      ditto
0B00001C            7643   VTrapV           ds.l    1      ditto
0B000020            7644   VPrivilege       ds.l    1      ditto
0B000024            7645   VTrace           ds.l    1
0B000028            7646   VLine1010emul    ds.l    1
0B00002C            7647   VLine1111emul    ds.l    1
0B000030            7648   VUnassigned1     ds.l    1
0B000034            7649   VUnassigned2     ds.l    1
0B000038            7650   VUnassigned3     ds.l    1
0B00003C            7651   VUninit_IRQ      ds.l    1
0B000040            7652   VUnassigned4     ds.l    1
0B000044            7653   VUnassigned5     ds.l    1
0B000048            7654   VUnassigned6     ds.l    1
0B00004C            7655   VUnassigned7     ds.l    1
0B000050            7656   VUnassigned8     ds.l    1
0B000054            7657   VUnassigned9     ds.l    1
0B000058            7658   VUnassigned10    ds.l    1
0B00005C            7659   VUnassigned11    ds.l    1
0B000060            7660   VSpuriousIRQ     ds.l    1
                    7661   
                    7662   * Interrupt handlers Vector 25-31
0B000064            7663   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            7664   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            7665   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            7666   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            7667   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            7668   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            7669   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7670   
                    7671   * Trap Handler vectors 32-47
0B000080            7672   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            7673   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            7674   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            7675   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            7676   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            7677   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            7678   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            7679   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            7680   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            7681   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            7682   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            7683   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            7684   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            7685   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            7686   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            7687   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7688   
                    7689   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    7690   
                    7691   ***********************************************************************************************************
                    7692   * Other Variables
                    7693   ***********************************************************************************************************
                    7694   *__DebugA5       ds.l    1
                    7695   *__UserA5        ds.l    1
                    7696   
                    7697   ***********************************************************************************************************
0B0000C0            7698   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            7699   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            7700   __heap:         ds.l    0       ; pointers for malloc functions
                    7701   
                    7702   *__himem:       ds.l    himem            ; highest memory location + 1
                    7703   *__stklen:      ds.l    stklen           ; default stack size
                    7704   
                    7705   *********************************************************************************************************
                    7706   * Section for Heap
                    7707   *********************************************************************************************************
                    7708   
                    7709   _i:
0B0000C4            7710          ds.b      4
                    7711   _x:
0B0000C8            7712          ds.b      4
                    7713   _y:
0B0000CC            7714          ds.b      4
                    7715   _z:
0B0000D0            7716          ds.b      4
                    7717   _PortA_Count:
0B0000D4            7718          ds.b      4
                    7719   _Trace:
0B0000D8            7720          ds.b      4
                    7721   _GoFlag:
0B0000DC            7722          ds.b      4
                    7723   _Echo:
0B0000E0            7724          ds.b      4
                    7725   _d0:
0B0000E4            7726          ds.b      4
                    7727   _d1:
0B0000E8            7728          ds.b      4
                    7729   _d2:
0B0000EC            7730          ds.b      4
                    7731   _d3:
0B0000F0            7732          ds.b      4
                    7733   _d4:
0B0000F4            7734          ds.b      4
                    7735   _d5:
0B0000F8            7736          ds.b      4
                    7737   _d6:
0B0000FC            7738          ds.b      4
                    7739   _d7:
0B000100            7740          ds.b      4
                    7741   _a0:
0B000104            7742          ds.b      4
                    7743   _a1:
0B000108            7744          ds.b      4
                    7745   _a2:
0B00010C            7746          ds.b      4
                    7747   _a3:
0B000110            7748          ds.b      4
                    7749   _a4:
0B000114            7750          ds.b      4
                    7751   _a5:
0B000118            7752          ds.b      4
                    7753   _a6:
0B00011C            7754          ds.b      4
                    7755   _PC:
0B000120            7756          ds.b      4
                    7757   _SSP:
0B000124            7758          ds.b      4
                    7759   _USP:
0B000128            7760          ds.b      4
                    7761   _SR:
0B00012C            7762          ds.b      2
                    7763   _BreakPointAddress:
0B00012E            7764          ds.b      32
                    7765   _BreakPointInstruction:
0B00014E            7766          ds.b      16
                    7767   _BreakPointSetOrCleared:
0B00015E            7768          ds.b      32
                    7769   _InstructionSize:
0B00017E            7770          ds.b      4
                    7771   _WatchPointAddress:
0B000182            7772          ds.b      32
                    7773   _WatchPointSetOrCleared:
0B0001A2            7774          ds.b      32
                    7775   _WatchPointString:
0B0001C2            7776          ds.b      800
                    7777   _TempString:
0B0004E2            7778          ds.b      100
                    7779          section   heap
0B000546            7780                   align
          0B00 0546 7781   bssEnd          equ *                   end of storage space for unitialised variables
                    7782   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0546 7783   heap   equ       *
0B000546            7784                    align
          0000 0000

Assembly errors: 0
